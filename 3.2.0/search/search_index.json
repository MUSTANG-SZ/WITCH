{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"WITCH (WHERE IS THAT CLUSTER HIDING)","text":"<p>This repository contains tools for modeling and fitting SZ data of galaxy clusters. While this code was originally written for MUSTANG-2 it is largely generic enough to work with data for other telescopes.</p>"},{"location":"#the-witch-library","title":"The <code>WITCH</code> Library","text":"<p>The core of this repository is the <code>WITCH</code> library. While the name contains <code>minkasi</code> it does not actually require the <code>minkasi</code> mapmaker to be used; rather, it produces models of galaxy clusters and their gradients in a format that can be consumed by <code>minkasi</code>'s fitting code.</p> <p>The core concept of <code>WITCH</code> is to model the cluster as a 3D pressure profile and then apply modifications to that profile to represent substructure. For example, a cavity can be modeled as a multiplicative suppression of the pressure within a certain region. The profile is then integrated along the line of sight to produce a signal like we would observe via the SZ effect. To produce gradients of the clusters and JIT expensive computations we employ <code>jax</code>.</p> <p>This framework makes it very easy to add new types of models, see the Contributing section for more.</p>"},{"location":"#the-fitterpy-script","title":"The <code>fitter.py</code> Script","text":"<p>The other main part of this repository is the <code>fitter.py</code> script. It is generically a script to perform fit models and make maps using <code>minkasi</code>, but there are a two key points that make it nice to use:</p> <ol> <li>A flexible configuration system that allows the user to control mapmaking and fitting parameters, model specification, IO, etc. via yaml files.</li> <li>First class support for models from the <code>WITCH</code> library.</li> </ol> <p>For the most part the config files are easy to make by using one of the files in the <code>configs</code> folder as a base. However there are some subtleties and advanced configurations that will eventually get documented properly.</p>"},{"location":"#installation","title":"Installation","text":"<p>To install the <code>WITCH</code> library first clone this repository and from within it run:</p> <pre><code>pip install .\n</code></pre> <p>Note that this will only install <code>WITCH</code> and its dependencies, to also install dependencies for <code>fitter.py</code> do:</p> <pre><code>pip install .[fitter]\n</code></pre> <p>If you are going to be actively working on the <code>WITCH</code> library you probably want to include the <code>-e</code> flag.</p> <p>All the dependencies should be installed by <code>pip</code> with the one exception being <code>minkasi</code> itself (only needed for <code>fitter.py</code>). Instructions on installing <code>minkasi</code> can be found here.</p>"},{"location":"#contributing","title":"Contributing","text":"<p>All are welcome to contribute to this repository, be it code or config files. In general contributions other than minor changes should follow the branch/fork -&gt; PR -&gt; merge workflow. If you are going to contribute regularly, contact one of us to get push access to the repository.</p>"},{"location":"#style-and-standards","title":"Style and Standards","text":"<p>In general contributions should be PEP8 with commits in the conventional commits format. This library follows semantic versioning, so changes that bump the version should do so by editing <code>pyproject.toml</code>.</p> <p>In order to make following these rules easier this repository is setup to work with commitizen and pre-commit. It is recommended that you make use of these tools to save time.</p>"},{"location":"#getting-started","title":"Getting Started","text":"<ol> <li>Install both tools with <code>pip install commitizen pre-commit</code>.</li> <li><code>cd</code> into the <code>WITCH</code> repository it you aren't already in it.</li> <li>(Optional) Setup <code>commitizen</code> to automatically run when you run <code>git commit</code>. Follow instruction here.</li> <li>Make sure the <code>pre-commit</code> hook is installed by running <code>pre-commit install</code>.</li> </ol>"},{"location":"#example-workflow","title":"Example Workflow","text":"<ol> <li>Make a branch for the edits you want to make.</li> <li>Code.</li> <li>Commit your code with a conventional commit message.</li> <li><code>cz c</code> gives you a wizard that will do this for you, if you followed Step 3 above then <code>git commit</code> will also do this (but not <code>git commit -m</code>).</li> <li>Repeat step 3 and 4 until the goal if your branch has been completed.</li> <li>Put in a PR.</li> <li>Once the PR is merged the repo version and tag will update automatically.</li> </ol>"},{"location":"#adding-new-models","title":"Adding New Models","text":"<p>When adding new models to <code>WITCH</code>, be they profiles or substructure, there are some changes that need to be made to <code>core.py</code> to expose them properly.</p> <ol> <li>A variable <code>N_PAR_{MODEL}</code> needs to be defined with the number of fittable parameters in the model. Do not include parameters like the grid here.</li> <li>A parameter <code>n_{model}</code> needs to be added to the functions <code>helper</code>, <code>model</code>, and <code>model_grad</code>. Remember to update the <code>static_argnums</code> for <code>model</code> and <code>model_grad</code>. In <code>helper</code> set a default value of <code>0</code> for backwards compatibility.</li> <li>A block grabbing the parameters for the model needs to be added to <code>model</code>. This can largely be copied from the other models, just remember to swap out the relevant variables.</li> <li>A block applying model needs to be added to <code>model</code>. Pressure profiles should come first then substructure. This can largely be copied from the other models, just remember to swap out the relevant variables.</li> </ol> <p>Adding a new model also (usually) means you should bump the minor version in the version number.</p>"},{"location":"#profiling-code","title":"Profiling Code","text":"<p>The script <code>scratch/profile.py</code> uses <code>jax</code> profiling tools to benchmark the library. It outputs a trace file understandable perfetto as well as a text file containing metadata about the software and hardware used while profiling. To use non default settings use <code>python profile.py --help</code> but in most cases the default settings are fine.</p> <p>The profiling script has some additional dependencies. To install them run:</p> <pre><code>pip install .[profile]\n</code></pre>"}]}