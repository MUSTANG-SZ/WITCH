{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"WITCH (WHERE IS THAT CLUSTER HIDING)","text":"<p>This repository contains tools for modeling and fitting SZ data of galaxy clusters. While this code was originally written for MUSTANG-2 it is largely generic enough to work with data for other telescopes.</p>"},{"location":"#the-witch-library","title":"The <code>WITCH</code> Library","text":"<p>The core of this repository is the <code>WITCH</code> library. While the name contains <code>minkasi</code> it does not actually require the <code>minkasi</code> mapmaker to be used; rather, it produces models of galaxy clusters and their gradients in a format that can be consumed by <code>minkasi</code>'s fitting code.</p> <p>The core concept of <code>WITCH</code> is to model the cluster as a 3D pressure profile and then apply modifications to that profile to represent substructure. For example, a cavity can be modeled as a multiplicative suppression of the pressure within a certain region. The profile is then integrated along the line of sight to produce a signal like we would observe via the SZ effect. To produce gradients of the clusters and JIT expensive computations we employ <code>jax</code>.</p> <p>This framework makes it very easy to add new types of models, see the Contributing section for more.</p>"},{"location":"#the-fitterpy-script","title":"The <code>fitter.py</code> Script","text":"<p>The other main part of this repository is the <code>fitter.py</code> script. It is generically a script to perform fit models and make maps using <code>minkasi</code>, but there are a two key points that make it nice to use:</p> <ol> <li>A flexible configuration system that allows the user to control mapmaking and fitting parameters, model specification, IO, etc. via yaml files.</li> <li>First class support for models from the <code>WITCH</code> library.</li> </ol> <p>For the most part the config files are easy to make by using one of the files in the <code>configs</code> folder as a base. However there are some subtleties and advanced configurations that will eventually get documented properly.</p>"},{"location":"#installation","title":"Installation","text":"<p>To install the <code>WITCH</code> library first clone this repository and from within it run:</p> <pre><code>pip install .\n</code></pre> <p>Note that this will only install <code>WITCH</code> and its dependencies, to also install dependencies for <code>fitter.py</code> do:</p> <pre><code>pip install .[fitter]\n</code></pre> <p>If you are going to be actively working on the <code>WITCH</code> library you probably want to include the <code>-e</code> flag.</p> <p>All the dependencies should be installed by <code>pip</code> with the one exception being <code>minkasi</code> itself (only needed for <code>fitter.py</code>). Instructions on installing <code>minkasi</code> can be found here.</p>"},{"location":"#contributing","title":"Contributing","text":"<p>All are welcome to contribute to this repository, be it code or config files. In general contributions other than minor changes should follow the branch/fork -&gt; PR -&gt; merge workflow. If you are going to contribute regularly, contact one of us to get push access to the repository.</p>"},{"location":"#style-and-standards","title":"Style and Standards","text":"<p>In general contributions should be PEP8 with commits in the conventional commits format. This library follows semantic versioning, so changes that bump the version should do so by editing <code>pyproject.toml</code>.</p> <p>In order to make following these rules easier this repository is setup to work with commitizen and pre-commit. It is recommended that you make use of these tools to save time.</p>"},{"location":"#getting-started","title":"Getting Started","text":"<ol> <li>Install both tools with <code>pip install commitizen pre-commit</code>.</li> <li><code>cd</code> into the <code>WITCH</code> repository it you aren't already in it.</li> <li>(Optional) Setup <code>commitizen</code> to automatically run when you run <code>git commit</code>. Follow instruction here.</li> <li>Make sure the <code>pre-commit</code> hook is installed by running <code>pre-commit install</code>.</li> </ol>"},{"location":"#example-workflow","title":"Example Workflow","text":"<ol> <li>Make a branch for the edits you want to make.</li> <li>Code.</li> <li>Commit your code with a conventional commit message.</li> <li><code>cz c</code> gives you a wizard that will do this for you, if you followed Step 3 above then <code>git commit</code> will also do this (but not <code>git commit -m</code>).</li> <li>Repeat step 3 and 4 until the goal if your branch has been completed.</li> <li>Put in a PR.</li> <li>Once the PR is merged the repo version and tag will update automatically.</li> </ol>"},{"location":"#adding-new-models","title":"Adding New Models","text":"<p>When adding new models to <code>WITCH</code>, be they profiles or substructure, there are some changes that need to be made to <code>core.py</code> to expose them properly.</p> <ol> <li>A variable <code>N_PAR_{MODEL}</code> needs to be defined with the number of fittable parameters in the model. Do not include parameters like the grid here.</li> <li>A parameter <code>n_{model}</code> needs to be added to the functions <code>helper</code>, <code>model</code>, and <code>model_grad</code>. Remember to update the <code>static_argnums</code> for <code>model</code> and <code>model_grad</code>. In <code>helper</code> set a default value of <code>0</code> for backwards compatibility.</li> <li>A block grabbing the parameters for the model needs to be added to <code>model</code>. This can largely be copied from the other models, just remember to swap out the relevant variables.</li> <li>A block applying model needs to be added to <code>model</code>. Pressure profiles should come first then substructure. This can largely be copied from the other models, just remember to swap out the relevant variables.</li> </ol> <p>Adding a new model also (usually) means you should bump the minor version in the version number.</p>"},{"location":"#profiling-code","title":"Profiling Code","text":"<p>The script <code>scratch/profile.py</code> uses <code>jax</code> profiling tools to benchmark the library. It outputs a trace file understandable perfetto as well as a text file containing metadata about the software and hardware used while profiling. To use non default settings use <code>python profile.py --help</code> but in most cases the default settings are fine.</p> <p>The profiling script has some additional dependencies. To install them run:</p> <pre><code>pip install .[profile]\n</code></pre>"},{"location":"reference/SUMMARY/","title":"SUMMARY","text":"<ul> <li>bowling</li> <li>containers</li> <li>core</li> <li>fitter</li> <li>forward_modeling</li> <li>mapmaking</li> <li>structure</li> <li>utils</li> </ul>"},{"location":"reference/bowling/","title":"bowling","text":"<p>Tools for dealing with bowling in maps</p>"},{"location":"reference/bowling/#witch.bowling.jac_potato_grad","title":"<code>jac_potato_grad(pn, p, tods)</code>","text":"<p>Gradient of shitty potato chip (hyperbolic parabaloid) model for removing scan signal from maps Arguments:</p> <pre><code>pn: Which version of p is passed in, see below for details\n\np: Parameter vector with entries:\n\n   * A, the overall amplitude\n   * c0, an overall offset\n   * c1 and c2, linear slopes\n   * c3 and c4, parabolic amplitudes\n   * theta, a rotation angle\n\n   Acceptable subsets are:\n\n   * (A, c0, c1, c2, c3, c4, theta) for pn = 0\n   * (A, c1, c2, c3, c4, theta) for pn = 1\n   * (A, c1, c3, c4, theta) for pn = 2\n   * (c1, theta) for pn = 3\n\ntods: (x, y) vectors\n</code></pre> <p>Returns:</p> <pre><code>grad: Gradient for this model with respect to p\n</code></pre> Source code in <code>witch/bowling.py</code> <pre><code>@partial(jax.jit, static_argnums=(0))\ndef jac_potato_grad(pn, p, tods):\n    \"\"\"\n    Gradient of shitty potato chip (hyperbolic parabaloid) model for removing scan signal from maps\n    Arguments:\n\n        pn: Which version of p is passed in, see below for details\n\n        p: Parameter vector with entries:\n\n           * A, the overall amplitude\n           * c0, an overall offset\n           * c1 and c2, linear slopes\n           * c3 and c4, parabolic amplitudes\n           * theta, a rotation angle\n\n           Acceptable subsets are:\n\n           * (A, c0, c1, c2, c3, c4, theta) for pn = 0\n           * (A, c1, c2, c3, c4, theta) for pn = 1\n           * (A, c1, c3, c4, theta) for pn = 2\n           * (c1, theta) for pn = 3\n\n        tods: (x, y) vectors\n\n    Returns:\n\n        grad: Gradient for this model with respect to p\n    \"\"\"\n    return jax.jacfwd(potato_chip, argnums=0)(pn, p, tods[0], tods[1])\n</code></pre>"},{"location":"reference/bowling/#witch.bowling.jit_potato_full","title":"<code>jit_potato_full(pn, p, tods)</code>","text":"<p>Shitty potato chip and its gradient (hyperbolic parabaloid) model for removing scan signal from maps Arguments:</p> <pre><code>pn: Which version of p is passed in, see below for details\n\np: Parameter vector with entries:\n\n   * A, the overall amplitude\n   * c0, an overall offset\n   * c1 and c2, linear slopes\n   * c3 and c4, parabolic amplitudes\n   * theta, a rotation angle\n\n   Acceptable subsets are:\n\n   * (A, c0, c1, c2, c3, c4, theta) for pn = 0\n   * (A, c1, c2, c3, c4, theta) for pn = 1\n   * (A, c1, c3, c4, theta) for pn = 2\n   * (c1, theta) for pn = 3\n\ntods: (x, y) vectors\n</code></pre> <p>Returns:</p> <pre><code>pred: A vector of values for this model given p at the xi, yi\n\ngrad: Gradient for this model with respect to p\n</code></pre> Source code in <code>witch/bowling.py</code> <pre><code>@partial(jax.jit, static_argnums=(0))\ndef jit_potato_full(pn, p, tods):\n    \"\"\"\n    Shitty potato chip and its gradient (hyperbolic parabaloid) model for removing scan signal from maps\n    Arguments:\n\n        pn: Which version of p is passed in, see below for details\n\n        p: Parameter vector with entries:\n\n           * A, the overall amplitude\n           * c0, an overall offset\n           * c1 and c2, linear slopes\n           * c3 and c4, parabolic amplitudes\n           * theta, a rotation angle\n\n           Acceptable subsets are:\n\n           * (A, c0, c1, c2, c3, c4, theta) for pn = 0\n           * (A, c1, c2, c3, c4, theta) for pn = 1\n           * (A, c1, c3, c4, theta) for pn = 2\n           * (c1, theta) for pn = 3\n\n        tods: (x, y) vectors\n\n    Returns:\n\n        pred: A vector of values for this model given p at the xi, yi\n\n        grad: Gradient for this model with respect to p\n    \"\"\"\n    pred = potato_chip(pn, p, tods[0], tods[1])\n    grad = jax.jacfwd(potato_chip, argnums=0)(pn, p, tods[0], tods[1])\n\n    return pred, grad\n</code></pre>"},{"location":"reference/bowling/#witch.bowling.poly","title":"<code>poly(x, c0, c1, c2)</code>","text":"<p>JITed second order polynomial</p> <p>Arguments:</p> <pre><code>x: X value(s) of polynomial\n\nc0: 0th order constant\n\nc1: 1st order constant\n\nc2: 2nd order constant\n</code></pre> <p>Returns:</p> <pre><code>poly: Polynomial values at x\n</code></pre> Source code in <code>witch/bowling.py</code> <pre><code>@partial(jax.jit, static_argnums=(1, 2, 3))\ndef poly(x, c0, c1, c2):\n    \"\"\"\n    JITed second order polynomial\n\n    Arguments:\n\n        x: X value(s) of polynomial\n\n        c0: 0th order constant\n\n        c1: 1st order constant\n\n        c2: 2nd order constant\n\n    Returns:\n\n        poly: Polynomial values at x\n    \"\"\"\n    return c0 + c1 * x + c2 * x**2\n</code></pre>"},{"location":"reference/bowling/#witch.bowling.poly_sub","title":"<code>poly_sub(x, y)</code>","text":"<p>Fit a second order TOD to data. Nominally used to fit out atmosphere.</p>"},{"location":"reference/bowling/#witch.bowling.poly_sub--inputs-designed-to-work-with","title":"Inputs: designed to work with","text":"<p>Arguments:     x: X values, nominally tod.info'apix'</p> <pre><code>y: Y values, nominally tod.info['dat_calib'][j] - tod.info['cm']\n</code></pre> <p>Returns:</p> <pre><code>res.x: The best fit parameters in the order c0, c1, c2 for y = c0 + c1*x + c2*x**2\n</code></pre> Source code in <code>witch/bowling.py</code> <pre><code>@jax.jit\ndef poly_sub(x, y):\n    \"\"\"\n    Fit a second order TOD to data.\n    Nominally used to fit out atmosphere.\n\n    # Inputs: designed to work with\n    Arguments:\n        x: X values, nominally tod.info['apix'][j]\n\n        y: Y values, nominally tod.info['dat_calib'][j] - tod.info['cm']\n\n    Returns:\n\n        res.x: The best fit parameters in the order c0, c1, c2 for y = c0 + c1*x + c2*x**2\n    \"\"\"\n    # compute the residual function for a 2nd degree poly, using res**2\n    poly_resid = lambda p, x, y: jnp.sum(((p[0] + p[1] * x + p[2] * x**2) - y) ** 2)\n    p0 = jnp.array([0.1, 0.1, 0.1])\n    # minimize the residual\n    res = sopt.minimize(poly_resid, p0, args=(x, y), method=\"BFGS\")\n\n    return res.x\n</code></pre>"},{"location":"reference/bowling/#witch.bowling.potato_chip","title":"<code>potato_chip(pn, p, xi, yi)</code>","text":"<p>A shitty potato chip (hyperbolic parabaloid) model for removing scan signal from maps Arguments:</p> <pre><code>pn: Which version of p is passed in, see below for details\n\np: Parameter vector with entries:\n\n   * A, the overall amplitude\n   * c0, an overall offset\n   * c1 and c2, linear slopes\n   * c3 and c4, parabolic amplitudes\n   * theta, a rotation angle\n\n   Acceptable subsets are:\n\n   * (A, c0, c1, c2, c3, c4, theta) for pn = 0\n   * (A, c1, c2, c3, c4, theta) for pn = 1\n   * (A, c1, c3, c4, theta) for pn = 2\n   * (c1, theta) for pn = 3\n\nxi: X vector\n\nyi: Y vectors\n</code></pre> <p>Returns:</p> <pre><code>chip: A vector of values for this model given p at the xi, yi\n</code></pre> Source code in <code>witch/bowling.py</code> <pre><code>@partial(jax.jit, static_argnums=(0))\ndef potato_chip(pn, p, xi, yi):\n    \"\"\"\n    A shitty potato chip (hyperbolic parabaloid) model for removing scan signal from maps\n    Arguments:\n\n        pn: Which version of p is passed in, see below for details\n\n        p: Parameter vector with entries:\n\n           * A, the overall amplitude\n           * c0, an overall offset\n           * c1 and c2, linear slopes\n           * c3 and c4, parabolic amplitudes\n           * theta, a rotation angle\n\n           Acceptable subsets are:\n\n           * (A, c0, c1, c2, c3, c4, theta) for pn = 0\n           * (A, c1, c2, c3, c4, theta) for pn = 1\n           * (A, c1, c3, c4, theta) for pn = 2\n           * (c1, theta) for pn = 3\n\n        xi: X vector\n\n        yi: Y vectors\n\n    Returns:\n\n        chip: A vector of values for this model given p at the xi, yi\n    \"\"\"\n    if pn == 0:\n        A, c0, c1, c2, c3, c4, theta = p\n    elif pn == 1:\n        A, c1, c2, c3, c4, theta = p\n    elif pn == 2:\n        A, c1, c3, c4, theta = p\n    elif pn == 3:\n        c1, theta = p\n    else:\n        return 0\n\n    x1, x2 = (\n        jnp.cos(theta) * xi + yi * jnp.sin(theta),\n        -1 * jnp.sin(theta) * xi + jnp.cos(theta) * yi,\n    )\n\n    if pn == 0:\n        return A * (c0 + c1 * x1 + c2 * x2 + x1**2 / c3 - x2**2 / c4)\n    elif pn == 1:\n        return A * (1 + c1 * x1 + c2 * x2 + x1**2 / c3 - x2**2 / c4)\n    elif pn == 2:\n        return A * (c1 * x1 + x1**2 / c3 - x2**2 / c4)\n    elif pn == 3:\n        return c1 * x1\n</code></pre>"},{"location":"reference/containers/","title":"containers","text":"<p>Data classes for describing models in a structured way</p>"},{"location":"reference/containers/#witch.containers.Model","title":"<code>Model</code>  <code>dataclass</code>","text":"Source code in <code>witch/containers.py</code> <pre><code>@dataclass\nclass Model:\n    name: str\n    structures: list[Structure]\n    xyz: tuple[jax.Array, jax.Array, jax.Array, float, float]  # arcseconds\n    dz: float  # arcseconds * unknown\n    beam: jax.Array\n    n_rounds: int\n    cur_round: int = 0\n    chisq: float = np.inf\n    original_order: list[int] = field(init=False)\n\n    def __post_init__(self):\n        # Make sure the structure is in the order that core expects\n        structure_idx = np.argsort(\n            [core.ORDER.index(structure.structure) for structure in self.structures]\n        )\n        self.structures = [self.structures[i] for i in structure_idx]\n        self.original_order = list(np.sort(structure_idx))\n\n    def __set_attr__(self, name, value):\n        if name == \"cur_round\":\n            self.__dict__.pop(\"model_grad\", None)\n        return super().__setattr__(name, value)\n\n    @cached_property\n    def n_struct(self) -&gt; list[int]:\n        n_struct = [0] * len(core.ORDER)\n        for structure in self.structures:\n            idx = core.ORDER.index(structure.structure)\n            n_struct[idx] += 1\n        return n_struct\n\n    @property\n    def pars(self) -&gt; list[float]:\n        pars = []\n        for structure in self.structures:\n            pars += [parameter.val for parameter in structure.parameters]\n        return pars\n\n    @cached_property\n    def par_names(self) -&gt; list[str]:\n        par_names = []\n        for structure in self.structures:\n            par_names += [parameter.name for parameter in structure.parameters]\n        return par_names\n\n    @property\n    def errs(self) -&gt; list[float]:\n        errs = []\n        for structure in self.structures:\n            errs += [parameter.err for parameter in structure.parameters]\n        return errs\n\n    @cached_property\n    def priors(self) -&gt; list[Optional[tuple[float, float]]]:\n        priors = []\n        for structure in self.structures:\n            priors += [parameter.prior for parameter in structure.parameters]\n        return priors\n\n    @property\n    def to_fit(self) -&gt; list[bool]:\n        to_fit = []\n        for structure in self.structures:\n            to_fit += [\n                parameter.fit[self.cur_round] for parameter in structure.parameters\n            ]\n        return to_fit\n\n    @cached_property\n    def to_fit_ever(self) -&gt; list[bool]:\n        to_fit = []\n        for structure in self.structures:\n            to_fit += [parameter.fit_ever for parameter in structure.parameters]\n        return to_fit\n\n    @cached_property\n    def model(self) -&gt; jax.Array:\n        return core.model(\n            self.xyz,\n            tuple(self.n_struct),\n            self.dz,\n            self.beam,\n            *self.pars,\n        )\n\n    def to_tod(self, dx, dy) -&gt; jax.Array:\n        \"\"\"\n        Project the model into a TOD.\n\n        Arguments:\n\n            dx: The RA TOD in arcseconds.\n\n            dy: The Dec TOD in arcseconds.\n\n        Returns:\n\n            tod: The model as a TOD.\n                 Same shape as dx.\n        \"\"\"\n        return wu.bilinear_interp(\n            dx, dy, self.xyz[0].ravel(), self.xyz[1].ravel(), self.model\n        )\n\n    @cached_property\n    def model_grad(self) -&gt; tuple[jax.Array, jax.Array]:\n        argnums = tuple(np.where(self.to_fit)[0] + core.ARGNUM_SHIFT)\n        return core.model_grad(\n            self.xyz,\n            tuple(self.n_struct),\n            self.dz,\n            self.beam,\n            argnums,\n            *self.pars,\n        )\n\n    def to_tod_grad(self, dx, dy) -&gt; tuple[jax.Array, jax.Array]:\n        \"\"\"\n        Project the model and gradient into a TOD.\n\n        Arguments:\n\n            dx: The RA TOD in arcseconds.\n\n            dy: The Dec TOD in arcseconds.\n\n        Returns:\n\n            tod: The model as a TOD.\n                 Same shape as dx.\n\n            grad_tod: The gradient a TOD.\n                      Has shape (npar,) + dx.shape\n        \"\"\"\n        model, grad = self.model_grad\n        tod = wu.bilinear_interp(\n            dx, dy, self.xyz[0].ravel(), self.xyz[1].ravel(), model\n        )\n        grad_tod = jnp.array(\n            [\n                (\n                    wu.bilinear_interp(\n                        dx, dy, self.xyz[0].ravel(), self.xyz[1].ravel(), _grad\n                    )\n                    if _fit\n                    else jnp.zeros_like(tod)\n                )\n                for _grad, _fit in zip(grad, self.to_fit)\n            ]\n        )\n\n        return tod, grad_tod\n\n    def __repr__(self) -&gt; str:\n        rep = self.name + \":\\n\"\n        rep += f\"Round {self.cur_round + 1} out of {self.n_rounds}\\n\"\n        for i in self.original_order:\n            struct = self.structures[i]\n            rep += \"\\t\" + struct.name + \":\\n\"\n            for par in struct.parameters:\n                rep += (\n                    \"\\t\\t\"\n                    + par.name\n                    + \"*\" * par.fit[self.cur_round]\n                    + str(par.prior) * (par.prior is not None)\n                    + \" = \"\n                    + str(par.val)\n                    + \" \u00b1 \"\n                    + str(par.err)\n                    + \"\\n\"\n                )\n        rep += f\"chisq is {self.chisq}\"\n        return rep\n\n    def update(self, vals, errs, chisq):\n        if not np.array_equal(self.pars, vals):\n            self.__dict__.pop(\"model\", None)\n            self.__dict__.pop(\"model_grad\", None)\n        n = 0\n        for struct in self.structures:\n            for par in struct.parameters:\n                par.val = vals[n]\n                par.err = errs[n]\n                n += 1\n        self.chisq = chisq\n\n    def minkasi_helper(\n        self, params: NDArray[np.floating], tod: Tod\n    ) -&gt; tuple[NDArray[np.floating], NDArray[np.floating]]:\n        \"\"\"\n        Helper function to work with minkasi fitting routines.\n\n        Arguments:\n\n            params: An array of model parameters.\n\n            tod: A minkasi tod instance.\n                'dx' and 'dy' must be in tod.info and be in radians.\n\n        Returns:\n\n            grad: The gradient of the model with respect to the model parameters.\n\n            pred: The model with the specified substructure.\n        \"\"\"\n        self.update(params, self.errs, self.chisq)\n        dx = tod.info[\"dx\"] * wu.rad_to_arcsec\n        dy = tod.info[\"dy\"] * wu.rad_to_arcsec\n\n        pred_tod, grad_tod = self.to_tod_grad(dx, dy)\n        pred_tod = jax.device_get(pred_tod)\n        grad_tod = jax.device_get(grad_tod)\n\n        return grad_tod, pred_tod\n\n    def save(self, path: str):\n        \"\"\"\n        Serialize the model to a file with dill.\n\n        Arguments:\n\n            path: The file to save to.\n        \"\"\"\n        with open(path, \"wb\") as f:\n            dill.dump(self, f)\n\n    @classmethod\n    def load(cls, path: str) -&gt; Self:\n        \"\"\"\n        Load the model from a file with dill.\n\n        Arguments:\n\n            path: The path to the saved model\n        \"\"\"\n        with open(path, \"rb\") as f:\n            return dill.load(f)\n\n    @classmethod\n    def from_cfg(cls, cfg: dict) -&gt; Self:\n        \"\"\"\n        Create an instance of model from a witch config.\n\n        Arguments:\n\n            cfg: Config loaded into a dict.\n        \"\"\"\n        # Do imports\n        for module, name in cfg.get(\"imports\", {}).items():\n            mod = import_module(module)\n            if isinstance(name, str):\n                locals()[name] = mod\n            elif isinstance(name, list):\n                for n in name:\n                    locals()[n] = getattr(mod, n)\n            else:\n                raise TypeError(\"Expect import name to be a string or a list\")\n\n        # Load constants\n        constants = {\n            name: eval(str(const)) for name, const in cfg.get(\"constants\", {}).items()\n        }  # pyright: ignore [reportUnusedVariable]\n\n        # Get jax device\n        dev_id = cfg.get(\"jax_device\", 0)\n        device = jax.devices()[dev_id]\n\n        # Setup coordindate stuff\n        r_map = eval(str(cfg[\"coords\"][\"r_map\"]))\n        dr = eval(str(cfg[\"coords\"][\"dr\"]))\n        dz = eval(str(cfg[\"coords\"].get(\"dz\", dr)))\n        x0 = eval(str(cfg[\"coords\"][\"x0\"]))\n        y0 = eval(str(cfg[\"coords\"][\"y0\"]))\n\n        xyz_host = wu.make_grid(\n            r_map, dr, dr, dz, x0 * wu.rad_to_arcsec, y0 * wu.rad_to_arcsec\n        )\n        xyz = jax.device_put(xyz_host, device)\n        xyz[0].block_until_ready()\n        xyz[1].block_until_ready()\n        xyz[2].block_until_ready()\n\n        # Make beam\n        beam = wu.beam_double_gauss(\n            dr,\n            eval(str(cfg[\"beam\"][\"fwhm1\"])),\n            eval(str(cfg[\"beam\"][\"amp1\"])),\n            eval(str(cfg[\"beam\"][\"fwhm2\"])),\n            eval(str(cfg[\"beam\"][\"amp2\"])),\n        )\n        beam = jax.device_put(beam, device)\n\n        n_rounds = cfg.get(\"n_rounds\", 1)\n        dz = dz * eval(str(cfg[\"model\"][\"unit_conversion\"]))\n\n        structures = []\n        for name, structure in cfg[\"model\"][\"structures\"].items():\n            parameters = []\n            for par_name, param in structure[\"parameters\"].items():\n                val = eval(str(param[\"value\"]))\n                fit = param.get(\"to_fit\", [False] * n_rounds)\n                if isinstance(fit, bool):\n                    fit = [fit] * n_rounds\n                if len(fit) != n_rounds:\n                    raise ValueError(\n                        f\"to_fit has {len(fit)} entries but we only have {n_rounds} rounds\"\n                    )\n                priors = param.get(\"priors\", None)\n                if priors is not None:\n                    priors = eval(str(priors))\n                parameters.append(Parameter(par_name, fit, val, 0.0, priors))\n            structures.append(Structure(name, structure[\"structure\"], parameters))\n        name = cfg[\"model\"].get(\n            \"name\", \"-\".join([structure.name for structure in structures])\n        )\n\n        return cls(name, structures, xyz, dz, beam, n_rounds)\n</code></pre>"},{"location":"reference/containers/#witch.containers.Model.from_cfg","title":"<code>from_cfg(cfg)</code>  <code>classmethod</code>","text":"<p>Create an instance of model from a witch config.</p> <p>Arguments:</p> <pre><code>cfg: Config loaded into a dict.\n</code></pre> Source code in <code>witch/containers.py</code> <pre><code>@classmethod\ndef from_cfg(cls, cfg: dict) -&gt; Self:\n    \"\"\"\n    Create an instance of model from a witch config.\n\n    Arguments:\n\n        cfg: Config loaded into a dict.\n    \"\"\"\n    # Do imports\n    for module, name in cfg.get(\"imports\", {}).items():\n        mod = import_module(module)\n        if isinstance(name, str):\n            locals()[name] = mod\n        elif isinstance(name, list):\n            for n in name:\n                locals()[n] = getattr(mod, n)\n        else:\n            raise TypeError(\"Expect import name to be a string or a list\")\n\n    # Load constants\n    constants = {\n        name: eval(str(const)) for name, const in cfg.get(\"constants\", {}).items()\n    }  # pyright: ignore [reportUnusedVariable]\n\n    # Get jax device\n    dev_id = cfg.get(\"jax_device\", 0)\n    device = jax.devices()[dev_id]\n\n    # Setup coordindate stuff\n    r_map = eval(str(cfg[\"coords\"][\"r_map\"]))\n    dr = eval(str(cfg[\"coords\"][\"dr\"]))\n    dz = eval(str(cfg[\"coords\"].get(\"dz\", dr)))\n    x0 = eval(str(cfg[\"coords\"][\"x0\"]))\n    y0 = eval(str(cfg[\"coords\"][\"y0\"]))\n\n    xyz_host = wu.make_grid(\n        r_map, dr, dr, dz, x0 * wu.rad_to_arcsec, y0 * wu.rad_to_arcsec\n    )\n    xyz = jax.device_put(xyz_host, device)\n    xyz[0].block_until_ready()\n    xyz[1].block_until_ready()\n    xyz[2].block_until_ready()\n\n    # Make beam\n    beam = wu.beam_double_gauss(\n        dr,\n        eval(str(cfg[\"beam\"][\"fwhm1\"])),\n        eval(str(cfg[\"beam\"][\"amp1\"])),\n        eval(str(cfg[\"beam\"][\"fwhm2\"])),\n        eval(str(cfg[\"beam\"][\"amp2\"])),\n    )\n    beam = jax.device_put(beam, device)\n\n    n_rounds = cfg.get(\"n_rounds\", 1)\n    dz = dz * eval(str(cfg[\"model\"][\"unit_conversion\"]))\n\n    structures = []\n    for name, structure in cfg[\"model\"][\"structures\"].items():\n        parameters = []\n        for par_name, param in structure[\"parameters\"].items():\n            val = eval(str(param[\"value\"]))\n            fit = param.get(\"to_fit\", [False] * n_rounds)\n            if isinstance(fit, bool):\n                fit = [fit] * n_rounds\n            if len(fit) != n_rounds:\n                raise ValueError(\n                    f\"to_fit has {len(fit)} entries but we only have {n_rounds} rounds\"\n                )\n            priors = param.get(\"priors\", None)\n            if priors is not None:\n                priors = eval(str(priors))\n            parameters.append(Parameter(par_name, fit, val, 0.0, priors))\n        structures.append(Structure(name, structure[\"structure\"], parameters))\n    name = cfg[\"model\"].get(\n        \"name\", \"-\".join([structure.name for structure in structures])\n    )\n\n    return cls(name, structures, xyz, dz, beam, n_rounds)\n</code></pre>"},{"location":"reference/containers/#witch.containers.Model.load","title":"<code>load(path)</code>  <code>classmethod</code>","text":"<p>Load the model from a file with dill.</p> <p>Arguments:</p> <pre><code>path: The path to the saved model\n</code></pre> Source code in <code>witch/containers.py</code> <pre><code>@classmethod\ndef load(cls, path: str) -&gt; Self:\n    \"\"\"\n    Load the model from a file with dill.\n\n    Arguments:\n\n        path: The path to the saved model\n    \"\"\"\n    with open(path, \"rb\") as f:\n        return dill.load(f)\n</code></pre>"},{"location":"reference/containers/#witch.containers.Model.minkasi_helper","title":"<code>minkasi_helper(params, tod)</code>","text":"<p>Helper function to work with minkasi fitting routines.</p> <p>Arguments:</p> <pre><code>params: An array of model parameters.\n\ntod: A minkasi tod instance.\n    'dx' and 'dy' must be in tod.info and be in radians.\n</code></pre> <p>Returns:</p> <pre><code>grad: The gradient of the model with respect to the model parameters.\n\npred: The model with the specified substructure.\n</code></pre> Source code in <code>witch/containers.py</code> <pre><code>def minkasi_helper(\n    self, params: NDArray[np.floating], tod: Tod\n) -&gt; tuple[NDArray[np.floating], NDArray[np.floating]]:\n    \"\"\"\n    Helper function to work with minkasi fitting routines.\n\n    Arguments:\n\n        params: An array of model parameters.\n\n        tod: A minkasi tod instance.\n            'dx' and 'dy' must be in tod.info and be in radians.\n\n    Returns:\n\n        grad: The gradient of the model with respect to the model parameters.\n\n        pred: The model with the specified substructure.\n    \"\"\"\n    self.update(params, self.errs, self.chisq)\n    dx = tod.info[\"dx\"] * wu.rad_to_arcsec\n    dy = tod.info[\"dy\"] * wu.rad_to_arcsec\n\n    pred_tod, grad_tod = self.to_tod_grad(dx, dy)\n    pred_tod = jax.device_get(pred_tod)\n    grad_tod = jax.device_get(grad_tod)\n\n    return grad_tod, pred_tod\n</code></pre>"},{"location":"reference/containers/#witch.containers.Model.save","title":"<code>save(path)</code>","text":"<p>Serialize the model to a file with dill.</p> <p>Arguments:</p> <pre><code>path: The file to save to.\n</code></pre> Source code in <code>witch/containers.py</code> <pre><code>def save(self, path: str):\n    \"\"\"\n    Serialize the model to a file with dill.\n\n    Arguments:\n\n        path: The file to save to.\n    \"\"\"\n    with open(path, \"wb\") as f:\n        dill.dump(self, f)\n</code></pre>"},{"location":"reference/containers/#witch.containers.Model.to_tod","title":"<code>to_tod(dx, dy)</code>","text":"<p>Project the model into a TOD.</p> <p>Arguments:</p> <pre><code>dx: The RA TOD in arcseconds.\n\ndy: The Dec TOD in arcseconds.\n</code></pre> <p>Returns:</p> <pre><code>tod: The model as a TOD.\n     Same shape as dx.\n</code></pre> Source code in <code>witch/containers.py</code> <pre><code>def to_tod(self, dx, dy) -&gt; jax.Array:\n    \"\"\"\n    Project the model into a TOD.\n\n    Arguments:\n\n        dx: The RA TOD in arcseconds.\n\n        dy: The Dec TOD in arcseconds.\n\n    Returns:\n\n        tod: The model as a TOD.\n             Same shape as dx.\n    \"\"\"\n    return wu.bilinear_interp(\n        dx, dy, self.xyz[0].ravel(), self.xyz[1].ravel(), self.model\n    )\n</code></pre>"},{"location":"reference/containers/#witch.containers.Model.to_tod_grad","title":"<code>to_tod_grad(dx, dy)</code>","text":"<p>Project the model and gradient into a TOD.</p> <p>Arguments:</p> <pre><code>dx: The RA TOD in arcseconds.\n\ndy: The Dec TOD in arcseconds.\n</code></pre> <p>Returns:</p> <pre><code>tod: The model as a TOD.\n     Same shape as dx.\n\ngrad_tod: The gradient a TOD.\n          Has shape (npar,) + dx.shape\n</code></pre> Source code in <code>witch/containers.py</code> <pre><code>def to_tod_grad(self, dx, dy) -&gt; tuple[jax.Array, jax.Array]:\n    \"\"\"\n    Project the model and gradient into a TOD.\n\n    Arguments:\n\n        dx: The RA TOD in arcseconds.\n\n        dy: The Dec TOD in arcseconds.\n\n    Returns:\n\n        tod: The model as a TOD.\n             Same shape as dx.\n\n        grad_tod: The gradient a TOD.\n                  Has shape (npar,) + dx.shape\n    \"\"\"\n    model, grad = self.model_grad\n    tod = wu.bilinear_interp(\n        dx, dy, self.xyz[0].ravel(), self.xyz[1].ravel(), model\n    )\n    grad_tod = jnp.array(\n        [\n            (\n                wu.bilinear_interp(\n                    dx, dy, self.xyz[0].ravel(), self.xyz[1].ravel(), _grad\n                )\n                if _fit\n                else jnp.zeros_like(tod)\n            )\n            for _grad, _fit in zip(grad, self.to_fit)\n        ]\n    )\n\n    return tod, grad_tod\n</code></pre>"},{"location":"reference/core/","title":"core","text":"<p>Core module for generating models aed their gradients.</p>"},{"location":"reference/core/#witch.core.model","title":"<code>model = jax.jit(model, static_argnums=model_static)</code>  <code>module-attribute</code>","text":"<p>Generically create models with substructure.</p> <p>Arguments:</p> <pre><code>xyz: Coordinate grid to compute profile on.\n\nn_struct: Number of each structure to use.\n          Should be in the same order as `order`.\n\ndz: Factor to scale by while integrating.\n    Since it is a global factor it can contain unit conversions.\n    Historically equal to y2K_RJ * dr * da * XMpc / me.\n\nbeam: Beam to convolve by, should be a 2d array.\n\nparams: 1D array of model parameters.\n</code></pre> <p>Returns:</p> <pre><code>model: The model with the specified substructure evaluated on the grid.\n</code></pre>"},{"location":"reference/core/#witch.core.model_grad","title":"<code>model_grad = jax.jit(model_grad, static_argnums=model_grad_static)</code>  <code>module-attribute</code>","text":"<p>A wrapper around model that also returns the gradients of the model. Only the additional arguments are described here, see model for the others. Note that the additional arguments are passed before the *params argument.</p> <p>Arguments:</p> <pre><code>argnums: The arguments to evaluate the gradient at\n</code></pre> <p>Returns:</p> <pre><code>model: The model with the specified substructure.\n\ngrad: The gradient of the model with respect to the model parameters.\n</code></pre>"},{"location":"reference/fitter/","title":"fitter","text":"<p>Master fitting and map making script. Docs will exist someday...</p>"},{"location":"reference/fitter/#witch.fitter.deep_merge","title":"<code>deep_merge(a, b)</code>","text":"<p>Based on https://gist.github.com/angstwad/bf22d1822c38a92ec0a9?permalink_comment_id=3517209</p> Source code in <code>witch/fitter.py</code> <pre><code>def deep_merge(a: dict, b: dict) -&gt; dict:\n    \"\"\"\n    Based on https://gist.github.com/angstwad/bf22d1822c38a92ec0a9?permalink_comment_id=3517209\n    \"\"\"\n    result = deepcopy(a)\n    for bk, bv in b.items():\n        av = result.get(bk)\n        if isinstance(av, dict) and isinstance(bv, dict):\n            result[bk] = deep_merge(av, bv)\n        else:\n            result[bk] = deepcopy(bv)\n    return result\n</code></pre>"},{"location":"reference/fitter/#witch.fitter.load_config","title":"<code>load_config(start_cfg, cfg_path)</code>","text":"<p>We want to load a config and if it has the key \"base\", load that as well and merge them. We only want to take things from base that are not in the original config so we merge the original into the newly loaded one.</p> Source code in <code>witch/fitter.py</code> <pre><code>def load_config(start_cfg, cfg_path):\n    \"\"\"\n    We want to load a config and if it has the key \"base\",\n    load that as well and merge them.\n    We only want to take things from base that are not in the original config\n    so we merge the original into the newly loaded one.\n    \"\"\"\n    with open(cfg_path) as file:\n        new_cfg = yaml.safe_load(file)\n    cfg = deep_merge(new_cfg, start_cfg)\n    if \"base\" in new_cfg:\n        base_path = new_cfg[\"base\"]\n        if not os.path.isabs(base_path):\n            base_path = os.path.join(os.path.dirname(cfg_path), base_path)\n        return load_config(cfg, base_path)\n    return cfg\n</code></pre>"},{"location":"reference/fitter/#witch.fitter.print_once","title":"<code>print_once(*args)</code>","text":"<p>Helper function to print only once when running with MPI. Only the rank 0 process will print.</p> <p>Arguments:</p> <pre><code>*args: Arguments to pass to print.\n</code></pre> Source code in <code>witch/fitter.py</code> <pre><code>def print_once(*args):\n    \"\"\"\n    Helper function to print only once when running with MPI.\n    Only the rank 0 process will print.\n\n    Arguments:\n\n        *args: Arguments to pass to print.\n    \"\"\"\n    if minkasi.myrank == 0:\n        print(*args)\n        sys.stdout.flush()\n</code></pre>"},{"location":"reference/forward_modeling/","title":"forward_modeling","text":"<p>Functions for performing forward modeling</p>"},{"location":"reference/forward_modeling/#witch.forward_modeling.get_chis","title":"<code>get_chis(m, idx, idy, rhs, v, weight, dd=None)</code>","text":"<p>A faster, but more importantly much less memory intensive, way to get chis. The idea is chi^2 = (d-Am)^T N^-1 (d-Am). Previously we would calculate the residuals d-Am and calculate directly. However d-Am has shape [ndet, nsamp], which is very big. m has shape [nx, ny], much smaller. A, the pointing reconstruction, can be encapsulated into a few pars. Therefore if we can do everthing in map shape, we save a lot on the ammount of stuff we need to put on the GPU. We can expand chi^2 as</p> <p>d^T N^-1 d -2d^T N^-1 A m + m^T A^T N^-1 A m = dd - 2*dot(m, rhs) + mm</p> <p>the first term only has to do with the data. If we care about the absolute value of chi2, which we do at the end, then we can include it in calculation. For MCMC however, we only care about the relative delta chi2 between models. So we can drop that term. For the other terms</p> <p>mm = m^T A^T N^-1 A m</p> <p>This term is essentially what we've been doing before, except that m is now in map shape, whereas before m was in tod shape so we essentially had Am. So we need to do Am, but this is in general fast and Jon has a very fast way of doing it. Finally rhs need only be computed once, and while it is an additional thing to put on the gpu it is small, map shape.</p> <p>Parameters:</p> Name Type Description Default <code>m</code> <code>NDArray[floating]</code> <p>The model evaluated at all the map pixels</p> required <code>idx</code> <code>NDArray[floating]</code> <p>tod.info[\"model_idx\"], the x index output by tod_to_index</p> required <code>idy</code> <code>NDArray[floating]</code> <p>tod.info[\"model_idy\"], the y index output by tod_to_index</p> required <code>rhs</code> <code>NDArray[floating]</code> <p>The map output of todvec.make_rhs. Note this is how the data enters into the chi2 calc.</p> required <code>v</code> <code>NDArray[floating]</code> <p>The right singular vectors for the noise SVD. These rotate the data into the basis of the SVD.</p> required <code>weight</code> <code>NDArray[floating]</code> <p>The noise weights, in fourier space, SVD decomposed.</p> required <code>dd</code> <code>None | floating</code> <p>Optional chi2 from dd. Not necessary for MCMC but is important for evaluating goodness of fit.</p> <code>None</code> Outputs <p>chi2 : np.floating     The chi2 of the model m to the data.</p> Source code in <code>witch/forward_modeling.py</code> <pre><code>@jax.jit\ndef get_chis(m, idx, idy, rhs, v, weight, dd=None):\n    \"\"\"\n    A faster, but more importantly much less memory intensive, way to get chis.\n    The idea is chi^2 = (d-Am)^T N^-1 (d-Am). Previously we would calculate the residuals d-Am\n    and calculate directly. However d-Am has shape [ndet, nsamp], which is very big. m has shape\n    [nx, ny], much smaller. A, the pointing reconstruction, can be encapsulated into a few pars.\n    Therefore if we can do everthing in map shape, we save a lot on the ammount of stuff we\n    need to put on the GPU. We can expand chi^2 as\n\n    d^T N^-1 d -2d^T N^-1 A m + m^T A^T N^-1 A m = dd - 2*dot(m, rhs) + mm\n\n    the first term only has to do with the data. If we care about the absolute value of chi2,\n    which we do at the end, then we can include it in calculation. For MCMC however, we only\n    care about the relative delta chi2 between models. So we can drop that term. For the other\n    terms\n\n    mm = m^T A^T N^-1 A m\n\n    This term is essentially what we've been doing before, except that m is now in map shape,\n    whereas before m was in tod shape so we essentially had Am. So we need to do Am, but this is\n    in general fast and Jon has a very fast way of doing it. Finally rhs need only be computed\n    once, and while it is an additional thing to put on the gpu it is small, map shape.\n\n    Parameters\n    ----------\n    m : NDArray[np.floating]\n        The model evaluated at all the map pixels\n    idx : NDArray[np.floating]\n        tod.info[\"model_idx\"], the x index output by tod_to_index\n    idy : NDArray[np.floating]\n        tod.info[\"model_idy\"], the y index output by tod_to_index\n    rhs : NDArray[np.floating]\n        The map output of todvec.make_rhs. Note this is how the data enters into the chi2 calc.\n    v : NDArray[np.floating]\n        The right singular vectors for the noise SVD. These rotate the data into the basis of\n        the SVD.\n    weight : NDArray[np.floating]\n        The noise weights, in fourier space, SVD decomposed.\n    dd : None | np.floating\n        Optional chi2 from dd. Not necessary for MCMC but is important for evaluating goodness\n        of fit.\n\n    Outputs\n    -------\n    chi2 : np.floating\n        The chi2 of the model m to the data.\n    \"\"\"\n\n    model = m.at[idy.astype(int), idx.astype(int)].get(mode=\"fill\", fill_value=0)\n\n    # model = model.at[:,0].set((jnp.sqrt(0.5)*model)[:,0]) #This doesn't actually do anything\n    # model = model.at[:,-1].set((jnp.sqrt(0.5)*model)[:,-1])\n    model_rot = jnp.dot(v, model)\n    tmp = jnp.hstack(\n        [model_rot, jnp.fliplr(model_rot[:, 1:-1])]\n    )  # mirror pred so we can do dct of first kind\n    predft = jnp.real(jnp.fft.rfft(tmp, axis=1))\n    nn = predft.shape[1]\n\n    chisq = (\n        jnp.sum(weight[:, :nn] * predft**2) - 2 * jnp.dot(rhs.ravel(), m.ravel()) / 2\n    )  # Man IDK about this factor of 2\n\n    return chisq\n</code></pre>"},{"location":"reference/forward_modeling/#witch.forward_modeling.sample","title":"<code>sample(model_params, xyz, beam, params, tods)</code>","text":"<p>Generate a model realization and compute the chis of that model to data.</p> <p>Arguements:</p> <pre><code>tods: Array of tod parameters. See prep tods\n\nparams: model parameters\n\nmodel_params: number of each model componant\n\nxyz: grid to evaluate model at\n\nbeam: Beam to smooth by\n</code></pre> <p>Returns:</p> <pre><code>chi2: the chi2 difference of the model to the tods\n</code></pre> Source code in <code>witch/forward_modeling.py</code> <pre><code>def sample(model_params, xyz, beam, params, tods):  # , model_params, xyz, beam):\n    \"\"\"\n    Generate a model realization and compute the chis of that model to data.\n\n    Arguements:\n\n        tods: Array of tod parameters. See prep tods\n\n        params: model parameters\n\n        model_params: number of each model componant\n\n        xyz: grid to evaluate model at\n\n        beam: Beam to smooth by\n\n    Returns:\n\n        chi2: the chi2 difference of the model to the tods\n\n    \"\"\"\n    log_like = 0\n    n_iso, n_gnfw, n_gauss, n_egauss, n_uni, n_expo, n_power, n_power_cos = model_params\n\n    m = model(\n        xyz,\n        n_iso,\n        n_gnfw,\n        n_gauss,\n        n_egauss,\n        n_uni,\n        n_expo,\n        n_power,\n        n_power_cos,\n        -2.5e-05,\n        beam,\n        params,\n    )\n\n    for i, tod in enumerate(tods):\n        x, y, rhs, v, weight, norm = tod  # unravel tod\n\n        log_like += jget_chis(m, x, y, rhs, v, weight) / norm\n\n    return log_like\n</code></pre>"},{"location":"reference/mapmaking/","title":"mapmaking","text":"<p>Functions that wrap useful minkasi recipes</p>"},{"location":"reference/mapmaking/#witch.mapmaking.get_grad_prior","title":"<code>get_grad_prior(todvec, mapset, gradmap, *args, **kwargs)</code>","text":"<p>Make a gradient based prior. This helps avoid errors due to sharp features.</p> <p>Arguments:</p> <pre><code>todvec: The TODs what we are mapmaking.\n\nmapset: The mapset to compute priors with.\n        We assume that the first element is the map we care about.\n\ngradmap: Containter to use as the gradient map.\n\n*args: Additional arguments to pass to get_grad_mask_2d.\n\n**kwargs: Kewword arguments to pass to get_grad_mask_2d.\n</code></pre> <p>Returns:</p> <pre><code>new_mapset: A mapset with the original map and a cleared prior map.\n</code></pre> Source code in <code>witch/mapmaking.py</code> <pre><code>def get_grad_prior(\n    todvec: minkasi.tods.TodVec,\n    mapset: minkasi.maps.Mapset,\n    gradmap: minkasi.maps.MapType,\n    *args,\n    **kwargs,\n) -&gt; tuple[minkasi.mapmaking.pcg.HasPrior, minkasi.maps.Mapset]:\n    \"\"\"\n    Make a gradient based prior. This helps avoid errors due to sharp features.\n\n    Arguments:\n\n        todvec: The TODs what we are mapmaking.\n\n        mapset: The mapset to compute priors with.\n                We assume that the first element is the map we care about.\n\n        gradmap: Containter to use as the gradient map.\n\n        *args: Additional arguments to pass to get_grad_mask_2d.\n\n        **kwargs: Kewword arguments to pass to get_grad_mask_2d.\n\n    Returns:\n\n        new_mapset: A mapset with the original map and a cleared prior map.\n    \"\"\"\n    gradmap.map[:] = minkasi.mapmaking.noise.get_grad_mask_2d(\n        mapset.maps[0], todvec, *args, **kwargs\n    )\n    prior = minkasi.mapmaking.timestream.tsModel(todvec, minkasi.tods.cuts.CutsCompact)\n    for tod in todvec.tods:\n        prior.data[tod.info[\"fname\"]] = tod.prior_from_skymap(gradmap)\n        print(\n            \"prior on tod \"\n            + tod.info[\"fname\"]\n            + \" length is \"\n            + repr(prior.data[tod.info[\"fname\"]].map.size)\n        )\n\n    new_mapset = minkasi.maps.Mapset()\n    new_mapset.add_map(mapset.maps[0])\n    pp = prior.copy()\n    pp.clear()\n    new_mapset.add_map(pp)\n\n    return new_mapset\n</code></pre>"},{"location":"reference/mapmaking/#witch.mapmaking.make_naive","title":"<code>make_naive(todvec, skymap, outdir)</code>","text":"<p>Make a naive map where we just bin common mode subtracted TODs.</p> <p>Arguments:</p> <pre><code>todvec: The TODs to mapmake.\n\nskymap: Map to use as footprint for outputs.\n</code></pre> <p>Returns:</p> <pre><code>naive: The navie map.\n\nhits: The hit count map.\nWe use this as a preconditioner which helps small-scale convergence quite a bit.\n</code></pre> Source code in <code>witch/mapmaking.py</code> <pre><code>def make_naive(\n    todvec: minkasi.tods.TodVec, skymap: minkasi.maps.MapType, outdir: str\n) -&gt; tuple[minkasi.maps.MapType, minkasi.maps.MapType]:\n    \"\"\"\n    Make a naive map where we just bin common mode subtracted TODs.\n\n    Arguments:\n\n        todvec: The TODs to mapmake.\n\n        skymap: Map to use as footprint for outputs.\n\n    Returns:\n\n        naive: The navie map.\n\n        hits: The hit count map.\n        We use this as a preconditioner which helps small-scale convergence quite a bit.\n    \"\"\"\n    hits = minkasi.mapmaking.make_hits(todvec, skymap)\n\n    # Make a naive map where we just bin the CM subbed tods\n    naive = skymap.copy()\n    naive.clear()\n    for tod in todvec.tods:\n        tmp = tod.info[\"dat_calib\"].copy()\n        u, s, v = np.linalg.svd(tmp, False)\n        tmp -= np.outer(u[:, 0], s[0] * v[0, :])\n        naive.tod2map(tod, tmp)\n    naive.mpi_reduce()\n    naive.map[hits.map &gt; 0] = naive.map[hits.map &gt; 0] / hits.map[hits.map &gt; 0]\n    if minkasi.myrank == 0:\n        naive.write(os.path.join(outdir, \"naive.fits\"))\n        hits.write(os.path.join(outdir, \"hits.fits\"))\n\n    return naive, hits\n</code></pre>"},{"location":"reference/mapmaking/#witch.mapmaking.make_weights","title":"<code>make_weights(todvec, skymap, outdir)</code>","text":"<p>Make weights and noise map.</p> <p>Arguments:</p> <pre><code>todvec: The TODs to mapmake.\n\nskymap: Map to use as footprint for outputs.\n</code></pre> <p>Returns:</p> <pre><code>weightmap: The weights map.\n\nnoisemap: The noise map.\n          This is just 1/sqrt(weights).\n</code></pre> Source code in <code>witch/mapmaking.py</code> <pre><code>def make_weights(\n    todvec: minkasi.tods.TodVec, skymap: minkasi.maps.MapType, outdir: str\n) -&gt; tuple[minkasi.maps.MapType, minkasi.maps.MapType]:\n    \"\"\"\n    Make weights and noise map.\n\n    Arguments:\n\n        todvec: The TODs to mapmake.\n\n        skymap: Map to use as footprint for outputs.\n\n    Returns:\n\n        weightmap: The weights map.\n\n        noisemap: The noise map.\n                  This is just 1/sqrt(weights).\n    \"\"\"\n    weightmap = minkasi.mapmaking.make_hits(todvec, skymap, do_weights=True)\n    mask = weightmap.map &gt; 0\n    tmp = weightmap.map.copy()\n    tmp[mask] = 1.0 / np.sqrt(tmp[mask])\n    noisemap = weightmap.copy()\n    noisemap.map[:] = tmp\n    if minkasi.myrank == 0:\n        noisemap.write(os.path.join(outdir, \"noise.fits\"))\n        weightmap.write(os.path.join(outdir, \"weights.fits\"))\n\n    return weightmap, noisemap\n</code></pre>"},{"location":"reference/mapmaking/#witch.mapmaking.reestimate_noise_from_map","title":"<code>reestimate_noise_from_map(todvec, mapset, noise_class, noise_args, noise_kwargs)</code>","text":"<p>Use the current guess at the map to reestimate the noise:</p> <p>Arguments:</p> <pre><code>todvec: The TODs to reestimate noise for.\n\nmapset: Mapset containing the current map solution.\n\nnoise_class: Which noise model to use.\n\nnoise_args: Additional arguments to pass to set_noise.\n\nnoise_kwargs: Additional keyword argmuents to pass to set_noise.\n</code></pre> Source code in <code>witch/mapmaking.py</code> <pre><code>def reestimate_noise_from_map(\n    todvec: minkasi.tods.TodVec,\n    mapset: minkasi.maps.Mapset,\n    noise_class: minkasi.mapmaking.NoiseModelType,\n    noise_args: list,\n    noise_kwargs: dict,\n):\n    \"\"\"\n    Use the current guess at the map to reestimate the noise:\n\n    Arguments:\n\n        todvec: The TODs to reestimate noise for.\n\n        mapset: Mapset containing the current map solution.\n\n        noise_class: Which noise model to use.\n\n        noise_args: Additional arguments to pass to set_noise.\n\n        noise_kwargs: Additional keyword argmuents to pass to set_noise.\n    \"\"\"\n    for tod in todvec.tods:\n        mat = 0 * tod.info[\"dat_calib\"]\n        for mm in mapset.maps:\n            mm.map2tod(tod, mat)\n        tod.set_noise(\n            noise_class,\n            dat=tod.info[\"dat_calib\"] - mat,\n            *noise_args,\n            **noise_kwargs,\n        )\n</code></pre>"},{"location":"reference/mapmaking/#witch.mapmaking.solve_map","title":"<code>solve_map(todvec, x0, ihits, prior, maxiters, save_iters, outdir, desc_str)</code>","text":"<p>Solve for map with PCG.</p> <p>Arguments:</p> <pre><code>todvec: The TODs what we are mapmaking.\n\nx0: The initial guess mapset.\n\nihits: The inverse hits map.\n\nprior: Prior to use when mapmaking, set to None to not use.\n\nmaxiters: Maximum PCG iters to use.\n\nsave_iters: Which iterations to save the map at.\n\noutdir: The output directory\n\ndesc_str: String used to deterime outroot.\n</code></pre> <p>Returns:</p> <pre><code>mapset: The mapset with the solved map.\n</code></pre> Source code in <code>witch/mapmaking.py</code> <pre><code>def solve_map(\n    todvec: minkasi.tods.TodVec,\n    x0: minkasi.maps.Mapset,\n    ihits: minkasi.maps.MapType,\n    prior: Optional[minkasi.mapmaking.pcg.HasPrior],\n    maxiters: int,\n    save_iters: list[int],\n    outdir: str,\n    desc_str: str,\n) -&gt; minkasi.maps.Mapset:\n    \"\"\"\n    Solve for map with PCG.\n\n    Arguments:\n\n        todvec: The TODs what we are mapmaking.\n\n        x0: The initial guess mapset.\n\n        ihits: The inverse hits map.\n\n        prior: Prior to use when mapmaking, set to None to not use.\n\n        maxiters: Maximum PCG iters to use.\n\n        save_iters: Which iterations to save the map at.\n\n        outdir: The output directory\n\n        desc_str: String used to deterime outroot.\n\n    Returns:\n\n        mapset: The mapset with the solved map.\n    \"\"\"\n    # make A^T N^1 d.  TODs need to understand what to do with maps\n    # but maps don't necessarily need to understand what to do with TODs,\n    # hence putting make_rhs in the vector of TODs.\n    # Again, make_rhs is MPI-aware, so this should do the right thing\n    # if you run with many processes.\n    rhs = x0.copy()\n    todvec.make_rhs(rhs)\n\n    # Preconditioner is 1/ hit count map.\n    # Helps a lot for convergence.\n    precon = x0.copy()\n    precon.maps[0].map[:] = ihits.map[:]\n\n    # run PCG to solve\n    # Supressing print here, probably want a verbosity setting on the minkasi side...\n    with open(os.devnull, \"w\") as f, contextlib.redirect_stdout(f):\n        mapset = minkasi.mapmaking.run_pcg_wprior(\n            rhs,\n            x0,\n            todvec,\n            prior,\n            precon,\n            maxiter=maxiters,\n            outroot=os.path.join(outdir, desc_str),\n            save_iters=save_iters,\n        )\n\n    if minkasi.myrank == 0:\n        mapset.maps[0].write(\n            os.path.join(outdir, f\"{desc_str}.fits\")\n        )  # and write out the map as a FITS file\n\n    return mapset\n</code></pre>"},{"location":"reference/structure/","title":"structure","text":"<p>Functions for generating structure. This includes both cluster profiles and substructure.</p>"},{"location":"reference/structure/#witch.structure.a10","title":"<code>a10(dx, dy, dz, theta, P0, c500, m500, gamma, alpha, beta, z, xyz)</code>","text":"<p>gNFW pressure profile in 3d based on Arnaud2010. Compared to the function gnfw, this function fixes r1/r2/r3 to r500. This function does not include smoothing or declination stretch which should be applied at the end.</p> <p>Arguments:</p> <pre><code>dx: RA of cluster center relative to grid origin\n\ndy: Dec of cluster center relative to grid origin\n\ndz: Line of sight offset of cluster center relative to grid origin\n\ntheta: Angle to rotate in xy-plane\n\nP0: Amplitude of the pressure profile\n\nc500: Concentration parameter at a density contrast of 500\n\nm500: Mass at a density contrast of 500\n\ngamma: The central slope\n\nalpha: The intermediate slope\n\nbeta: The outer slope\n\nz: Redshift of cluster\n\nxyz: Coordinte grid to calculate model on\n</code></pre> <p>Returns:</p> <pre><code>model: The gnfw model\n</code></pre> Source code in <code>witch/structure.py</code> <pre><code>@jax.jit\ndef a10(dx, dy, dz, theta, P0, c500, m500, gamma, alpha, beta, z, xyz):\n    \"\"\"\n    gNFW pressure profile in 3d based on Arnaud2010.\n    Compared to the function gnfw, this function fixes r1/r2/r3 to r500.\n    This function does not include smoothing or declination stretch\n    which should be applied at the end.\n\n    Arguments:\n\n        dx: RA of cluster center relative to grid origin\n\n        dy: Dec of cluster center relative to grid origin\n\n        dz: Line of sight offset of cluster center relative to grid origin\n\n        theta: Angle to rotate in xy-plane\n\n        P0: Amplitude of the pressure profile\n\n        c500: Concentration parameter at a density contrast of 500\n\n        m500: Mass at a density contrast of 500\n\n        gamma: The central slope\n\n        alpha: The intermediate slope\n\n        beta: The outer slope\n\n        z: Redshift of cluster\n\n        xyz: Coordinte grid to calculate model on\n\n    Returns:\n\n        model: The gnfw model\n    \"\"\"\n\n    nz = get_nz(z)\n    hz = get_hz(z)\n    da = get_da(z)  # TODO pass these arguments rather than recompute them everytime???\n\n    r500 = (m500 / (4.00 * jnp.pi / 3.00) / 5.00e02 / nz) ** (1.00 / 3.00)\n    r_1, r_2, r_3 = r500 / da, r500 / da, r500 / da\n\n    x, y, z = transform_grid(dx, dy, dz, r_1, r_2, r_3, theta, xyz)\n\n    r = c500 * jnp.sqrt(x**2 + y**2 + z**2)\n    denominator = (r**gamma) * (1 + r**alpha) ** ((beta - gamma) / alpha)\n\n    P500 = (\n        1.65e-03\n        * (m500 / (3.00e14 / h70)) ** (2.00 / 3.00 + ap)\n        * hz ** (8.00 / 3.00)\n        * h70**2\n    )\n\n    return P500 * P0 / denominator\n</code></pre>"},{"location":"reference/structure/#witch.structure.add_exponential","title":"<code>add_exponential(pressure, xyz, dx, dy, dz, r_1, r_2, r_3, theta, amp, xk, x0, yk, y0, zk, z0)</code>","text":"<p>Add ellipsoid with exponential structure to 3d pressure profile.</p> <p>Arguments:</p> <pre><code>pressure: The pressure profile\n\nxyz: Coordinate grids, see make_grid for details\n\ndx: RA of ellipsoid center relative to grid origin\n\ndy: Dec of ellipsoid center relative to grid origin\n\ndz: Line of sight offset of ellipsoid center relative to grid origin\n\nr_1: Amount to scale ellipsoid along x-axis\n\nr_2: Amount to scale ellipsoid along y-axis\n\nr_3: Amount to scale ellipsoid along z-axis\n\ntheta: Angle to rotate ellipsoid in xy-plane\n\namp: Factor by which pressure is enhanced at peak of exponential\n\nxk: Power of exponential in RA direction\n\nx0: RA offset of exponential.\n    Note that this is in transformed coordinates so x0=1 is at xs + sr_1.\n\nyk: Power of exponential in Dec direction\n\ny0: Dec offset of exponential.\n    Note that this is in transformed coordinates so y0=1 is at ys + sr_2.\n\nzk: Power of exponential along the line of sight\n\nz0: Line of sight offset of exponential.\n    Note that this is in transformed coordinates so z0=1 is at zs + sr_3.\n</code></pre> <p>Returns:</p> <pre><code>new_pressure: Pressure profile with ellipsoid added\n</code></pre> Source code in <code>witch/structure.py</code> <pre><code>@jax.jit\ndef add_exponential(\n    pressure, xyz, dx, dy, dz, r_1, r_2, r_3, theta, amp, xk, x0, yk, y0, zk, z0\n):\n    \"\"\"\n    Add ellipsoid with exponential structure to 3d pressure profile.\n\n    Arguments:\n\n        pressure: The pressure profile\n\n        xyz: Coordinate grids, see make_grid for details\n\n        dx: RA of ellipsoid center relative to grid origin\n\n        dy: Dec of ellipsoid center relative to grid origin\n\n        dz: Line of sight offset of ellipsoid center relative to grid origin\n\n        r_1: Amount to scale ellipsoid along x-axis\n\n        r_2: Amount to scale ellipsoid along y-axis\n\n        r_3: Amount to scale ellipsoid along z-axis\n\n        theta: Angle to rotate ellipsoid in xy-plane\n\n        amp: Factor by which pressure is enhanced at peak of exponential\n\n        xk: Power of exponential in RA direction\n\n        x0: RA offset of exponential.\n            Note that this is in transformed coordinates so x0=1 is at xs + sr_1.\n\n        yk: Power of exponential in Dec direction\n\n        y0: Dec offset of exponential.\n            Note that this is in transformed coordinates so y0=1 is at ys + sr_2.\n\n        zk: Power of exponential along the line of sight\n\n        z0: Line of sight offset of exponential.\n            Note that this is in transformed coordinates so z0=1 is at zs + sr_3.\n\n    Returns:\n\n        new_pressure: Pressure profile with ellipsoid added\n    \"\"\"\n    x, y, z = transform_grid(dx, dy, dz, r_1, r_2, r_3, theta, xyz)\n\n    exponential = amp * jnp.exp(((x - x0) * xk) + ((y - y0) * yk) + ((z - z0) * zk))\n\n    new_pressure = jnp.where(\n        jnp.sqrt(x**2 + y**2 + z**2) &gt; 1, pressure, (1 + exponential) * pressure\n    )\n    return new_pressure\n</code></pre>"},{"location":"reference/structure/#witch.structure.add_powerlaw","title":"<code>add_powerlaw(pressure, xyz, dx, dy, dz, r_1, r_2, r_3, theta, amp, phi0, k_r, k_phi)</code>","text":"<p>Add ellipsoid with power law structure to 3d pressure profile.</p> <p>Arguments:</p> <pre><code>pressure: The pressure profile\n\nxyz: Coordinate grids, see make_grid for details\n\ndx: RA of ellipsoid center relative to grid origin\n\ndy: Dec of ellipsoid center relative to grid origin\n\ndz: Line of sight offset of ellipsoid center relative to grid origin\n\nr_1: Amount to scale ellipsoid along x-axis\n\nr_2: Amount to scale ellipsoid along y-axis\n\nr_3: Amount to scale ellipsoid along z-axis\n\ntheta: Angle to rotate ellipsoid in xy-plane\n\namp: Factor by which pressure is enhanced at peak of power law\n\nphi0: Polar angle of nose of power law\n\nk_r: Slope of power law in radial dirction\n\nk_phi: Slope of power law in polar direction\n</code></pre> <p>Returns:</p> <pre><code>new_pressure: Pressure profile with ellipsoid added\n</code></pre> Source code in <code>witch/structure.py</code> <pre><code>@jax.jit\ndef add_powerlaw(\n    pressure, xyz, dx, dy, dz, r_1, r_2, r_3, theta, amp, phi0, k_r, k_phi\n):\n    \"\"\"\n    Add ellipsoid with power law structure to 3d pressure profile.\n\n    Arguments:\n\n        pressure: The pressure profile\n\n        xyz: Coordinate grids, see make_grid for details\n\n        dx: RA of ellipsoid center relative to grid origin\n\n        dy: Dec of ellipsoid center relative to grid origin\n\n        dz: Line of sight offset of ellipsoid center relative to grid origin\n\n        r_1: Amount to scale ellipsoid along x-axis\n\n        r_2: Amount to scale ellipsoid along y-axis\n\n        r_3: Amount to scale ellipsoid along z-axis\n\n        theta: Angle to rotate ellipsoid in xy-plane\n\n        amp: Factor by which pressure is enhanced at peak of power law\n\n        phi0: Polar angle of nose of power law\n\n        k_r: Slope of power law in radial dirction\n\n        k_phi: Slope of power law in polar direction\n\n    Returns:\n\n        new_pressure: Pressure profile with ellipsoid added\n    \"\"\"\n    x, y, z = transform_grid(dx, dy, dz, r_1, r_2, r_3, theta, xyz)\n    r = jnp.sqrt(x**2 + y**2 + z**2)\n    phi = abs((jnp.arctan2(y, x) - phi0) % (2 * jnp.pi) - jnp.pi) / jnp.pi\n\n    powerlaw = (\n        amp\n        * (1 - jnp.float_power(1 + r, -1.0 * k_r))\n        * (1 - jnp.float_power(1 + phi, -1 * k_phi))\n    )\n    new_pressure = jnp.where(r &gt; 1, pressure, (1 + powerlaw) * pressure)\n    return new_pressure\n</code></pre>"},{"location":"reference/structure/#witch.structure.add_powerlaw_cos","title":"<code>add_powerlaw_cos(pressure, xyz, dx, dy, dz, r_1, r_2, r_3, theta, amp, phi0, k_r, omega)</code>","text":"<p>Add ellipsoid with radial power law and angular cos dependant structure to 3d pressure profile.</p> <p>Arguments:</p> <pre><code>pressure: The pressure profile\n\nxyz: Coordinate grids, see make_grid for details\n\ndx: RA of ellipsoid center relative to grid origin\n\ndy: Dec of ellipsoid center relative to grid origin\n\ndz: Line of sight offset of ellipsoid center relative to grid origin\n\nr_1: Amount to scale ellipsoid along x-axis\n\nr_2: Amount to scale ellipsoid along y-axis\n\nr_3: Amount to scale ellipsoid along z-axis\n\ntheta: Angle to rotate ellipsoid in xy-plane\n\namp: Factor by which pressure is enhanced at peak of power law\n\nphi0: Polar angle of nose of power law\n\nk_r: Slope of power law in radial dirction\n\nomega: Angular freqency if cos term\n</code></pre> <p>Returns:</p> <pre><code>new_pressure: Pressure profile with ellipsoid added\n</code></pre> Source code in <code>witch/structure.py</code> <pre><code>@jax.jit\ndef add_powerlaw_cos(\n    pressure, xyz, dx, dy, dz, r_1, r_2, r_3, theta, amp, phi0, k_r, omega\n):\n    \"\"\"\n    Add ellipsoid with radial power law and angular cos dependant structure to 3d pressure profile.\n\n    Arguments:\n\n        pressure: The pressure profile\n\n        xyz: Coordinate grids, see make_grid for details\n\n        dx: RA of ellipsoid center relative to grid origin\n\n        dy: Dec of ellipsoid center relative to grid origin\n\n        dz: Line of sight offset of ellipsoid center relative to grid origin\n\n        r_1: Amount to scale ellipsoid along x-axis\n\n        r_2: Amount to scale ellipsoid along y-axis\n\n        r_3: Amount to scale ellipsoid along z-axis\n\n        theta: Angle to rotate ellipsoid in xy-plane\n\n        amp: Factor by which pressure is enhanced at peak of power law\n\n        phi0: Polar angle of nose of power law\n\n        k_r: Slope of power law in radial dirction\n\n        omega: Angular freqency if cos term\n\n    Returns:\n\n        new_pressure: Pressure profile with ellipsoid added\n    \"\"\"\n    x, y, z = transform_grid(dx, dy, dz, r_1, r_2, r_3, theta, xyz)\n    r = jnp.sqrt(x**2 + y**2 + z**2)\n    phi = (jnp.arctan2(y, x) - phi0) % (2 * jnp.pi)\n\n    powerlaw = amp * (1 - jnp.float_power(1 + r, -1.0 * k_r)) * jnp.cos(omega * phi)\n    new_pressure = jnp.where(r &gt; 1, pressure, (1 + powerlaw) * pressure)\n    return new_pressure\n</code></pre>"},{"location":"reference/structure/#witch.structure.add_uniform","title":"<code>add_uniform(pressure, xyz, dx, dy, dz, r_1, r_2, r_3, theta, amp)</code>","text":"<p>Add ellipsoid with uniform structure to 3d pressure profile.</p> <p>Arguments:</p> <pre><code>pressure: The pressure profile\n\nxyz: Coordinate grids, see make_grid for details\n\ndx: RA of ellipsoid center relative to grid origin\n\ndy: Dec of ellipsoid center relative to grid origin\n\ndz: Line of sight offset of ellipsoid center relative to grid origin\n\nr_1: Amount to scale ellipsoid along x-axis\n\nr_2: Amount to scale ellipsoid along y-axis\n\nr_3: Amount to scale ellipsoid along z-axis\n\ntheta: Angle to rotate ellipsoid in xy-plane\n\namp: Factor by which pressure is enhanced at peak of exponential\n</code></pre> <p>Returns:</p> <pre><code>new_pressure: Pressure profile with ellipsoid added\n</code></pre> Source code in <code>witch/structure.py</code> <pre><code>@jax.jit\ndef add_uniform(pressure, xyz, dx, dy, dz, r_1, r_2, r_3, theta, amp):\n    \"\"\"\n    Add ellipsoid with uniform structure to 3d pressure profile.\n\n    Arguments:\n\n        pressure: The pressure profile\n\n        xyz: Coordinate grids, see make_grid for details\n\n        dx: RA of ellipsoid center relative to grid origin\n\n        dy: Dec of ellipsoid center relative to grid origin\n\n        dz: Line of sight offset of ellipsoid center relative to grid origin\n\n        r_1: Amount to scale ellipsoid along x-axis\n\n        r_2: Amount to scale ellipsoid along y-axis\n\n        r_3: Amount to scale ellipsoid along z-axis\n\n        theta: Angle to rotate ellipsoid in xy-plane\n\n        amp: Factor by which pressure is enhanced at peak of exponential\n\n    Returns:\n\n        new_pressure: Pressure profile with ellipsoid added\n    \"\"\"\n    x, y, z = transform_grid(dx, dy, dz, r_1, r_2, r_3, theta, xyz)\n\n    new_pressure = jnp.where(\n        jnp.sqrt(x**2 + y**2 + z**2) &gt; 1, pressure, (1 + amp) * pressure\n    )\n    return new_pressure\n</code></pre>"},{"location":"reference/structure/#witch.structure.ea10","title":"<code>ea10(dx, dy, dz, r_1, r_2, r_3, theta, P0, c500, m500, gamma, alpha, beta, z, xyz)</code>","text":"<p>Eliptical gNFW pressure profile in 3d based on Arnaud2010. r_ell is computed in the usual way for an a10 profile, then the axes are scaled according to r_1, r_2, r_3, with a normalization applied. This function does not include smoothing or declination stretch which should be applied at the end.</p> <p>Arguments:</p> <pre><code>dx: RA of cluster center relative to grid origin\n\ndy: Dec of cluster center relative to grid origin\n\ndz: Line of sight offset of cluster center relative to grid origin\n\nr_1: X-axis scaling. Units are arbitrary, only radio of r_1/r_2, r_1/r_3, r_2/r_3 matters\n\nr_2: Y-axis scaling.\n\nr_3: Z-axis scaling.\n\ntheta: Angle to rotate in xy-plane\n\nP0: Amplitude of the pressure profile\n\nc500: Concentration parameter at a density contrast of 500\n\nm500: Mass at a density contrast of 500\n\ngamma: The central slope\n\nalpha: The intermediate slope\n\nbeta: The outer slope\n\nz: Redshift of cluster\n\nxyz: Coordinte grid to calculate model on\n</code></pre> <p>Returns:</p> <pre><code>model: The gnfw model\n</code></pre> Source code in <code>witch/structure.py</code> <pre><code>@jax.jit\ndef ea10(dx, dy, dz, r_1, r_2, r_3, theta, P0, c500, m500, gamma, alpha, beta, z, xyz):\n    \"\"\"\n    Eliptical gNFW pressure profile in 3d based on Arnaud2010.\n    r_ell is computed in the usual way for an a10 profile, then the axes are\n    scaled according to r_1, r_2, r_3, with a normalization applied.\n    This function does not include smoothing or declination stretch\n    which should be applied at the end.\n\n    Arguments:\n\n        dx: RA of cluster center relative to grid origin\n\n        dy: Dec of cluster center relative to grid origin\n\n        dz: Line of sight offset of cluster center relative to grid origin\n\n        r_1: X-axis scaling. Units are arbitrary, only radio of r_1/r_2, r_1/r_3, r_2/r_3 matters\n\n        r_2: Y-axis scaling.\n\n        r_3: Z-axis scaling.\n\n        theta: Angle to rotate in xy-plane\n\n        P0: Amplitude of the pressure profile\n\n        c500: Concentration parameter at a density contrast of 500\n\n        m500: Mass at a density contrast of 500\n\n        gamma: The central slope\n\n        alpha: The intermediate slope\n\n        beta: The outer slope\n\n        z: Redshift of cluster\n\n        xyz: Coordinte grid to calculate model on\n\n    Returns:\n\n        model: The gnfw model\n    \"\"\"\n    nz = get_nz(z)\n    hz = get_hz(z)\n    da = get_da(z)  # TODO pass these arguments rather than recompute them everytime???\n\n    r500 = (m500 / (4.00 * jnp.pi / 3.00) / 5.00e02 / nz) ** (1.00 / 3.00)\n    r_ell = r500 / da\n    r_norm = jnp.sqrt(r_1**2 + r_2**2 + r_3**2)\n\n    r_1 *= r_ell / r_norm\n    r_2 *= r_ell / r_norm\n    r_3 *= r_ell / r_norm\n\n    x, y, z = transform_grid(dx, dy, dz, r_1, r_2, r_3, theta, xyz)\n\n    r = c500 * jnp.sqrt(x**2 + y**2 + z**2)\n    denominator = (r**gamma) * (1 + r**alpha) ** ((beta - gamma) / alpha)\n\n    P500 = (\n        1.65e-03\n        * (m500 / (3.00e14 / h70)) ** (2.00 / 3.00 + ap)\n        * hz ** (8.00 / 3.00)\n        * h70**2\n    )\n\n    return P500 * P0 / denominator\n</code></pre>"},{"location":"reference/structure/#witch.structure.egaussian","title":"<code>egaussian(dx, dy, dz, r_1, r_2, r_3, theta, sigma, amp, xyz)</code>","text":"<p>Elliptical gaussian profile in 3d. This function does not include smoothing or declination stretch which should be applied at the end.</p> <p>Arguments:</p> <pre><code>dx: RA of gaussian center relative to grid origin\n\ndy: Dec of gaussian center relative to grid origin\n\ndz: Line of sight offset of gaussian center relative to grid origin\n\nr_1: Amount to scale along x-axis\n\nr_2: Amount to scale along y-axis\n\nr_3: Amount to scale along z-axis\n\ntheta: Angle to rotate in xy-plane\n\nsigma: Sigma of the gaussian\n\namp: Amplitude of the gaussian\n\nxyz: Coordinte grid to calculate model on\n</code></pre> <p>Returns:</p> <pre><code>model: The gaussian\n</code></pre> Source code in <code>witch/structure.py</code> <pre><code>@jax.jit\ndef egaussian(dx, dy, dz, r_1, r_2, r_3, theta, sigma, amp, xyz):\n    \"\"\"\n    Elliptical gaussian profile in 3d.\n    This function does not include smoothing or declination stretch\n    which should be applied at the end.\n\n    Arguments:\n\n        dx: RA of gaussian center relative to grid origin\n\n        dy: Dec of gaussian center relative to grid origin\n\n        dz: Line of sight offset of gaussian center relative to grid origin\n\n        r_1: Amount to scale along x-axis\n\n        r_2: Amount to scale along y-axis\n\n        r_3: Amount to scale along z-axis\n\n        theta: Angle to rotate in xy-plane\n\n        sigma: Sigma of the gaussian\n\n        amp: Amplitude of the gaussian\n\n        xyz: Coordinte grid to calculate model on\n\n    Returns:\n\n        model: The gaussian\n    \"\"\"\n    x, y, z = transform_grid(dx, dy, dz, r_1, r_2, r_3, theta, xyz)\n\n    rr = x**2 + y**2 + z**2\n    power = -1 * rr / (2 * sigma**2)\n\n    return amp * jnp.exp(power)\n</code></pre>"},{"location":"reference/structure/#witch.structure.gaussian","title":"<code>gaussian(dx, dy, sigma, amp, xyz)</code>","text":"<p>Standard gaussian profile in 3d. This function does not include smoothing or declination stretch which should be applied at the end. The transform_grid call is awkward and can probably be removed/worked around. Function exists to match existing guassian interfaces.</p> <p>Arguments:</p> <pre><code>dx: RA of gaussian center relative to grid origin\n\ndy: Dec of gaussian center relative to grid origin\n\nsigma: The effective, beam-convolved half-width of the point source.\n\namp: Amplitude of the gaussian\n\nxyz: Coordinte grid to calculate model on\n</code></pre> <p>Returns:</p> <pre><code>model: The gaussian\n</code></pre> Source code in <code>witch/structure.py</code> <pre><code>@jax.jit\ndef gaussian(dx, dy, sigma, amp, xyz):\n    \"\"\"\n    Standard gaussian profile in 3d.\n    This function does not include smoothing or declination stretch\n    which should be applied at the end. The transform_grid call is\n    awkward and can probably be removed/worked around. Function exists\n    to match existing guassian interfaces.\n\n    Arguments:\n\n        dx: RA of gaussian center relative to grid origin\n\n        dy: Dec of gaussian center relative to grid origin\n\n        sigma: The effective, beam-convolved half-width of the point source.\n\n        amp: Amplitude of the gaussian\n\n        xyz: Coordinte grid to calculate model on\n\n    Returns:\n\n        model: The gaussian\n    \"\"\"\n    x, y, z = transform_grid(dx, dy, 0, 1, 1, 1, 0, xyz)\n    rr = x[..., 0] ** 2 + y[..., 0] ** 2\n    power = -1 * rr / (2 * sigma**2)\n\n    return amp * jnp.exp(power)\n</code></pre>"},{"location":"reference/structure/#witch.structure.gnfw","title":"<code>gnfw(dx, dy, dz, r_1, r_2, r_3, theta, P0, c500, m500, gamma, alpha, beta, z, xyz)</code>","text":"<p>Elliptical gNFW pressure profile in 3d. This function does not include smoothing or declination stretch which should be applied at the end.</p> <p>Arguments:</p> <pre><code>dx: RA of cluster center relative to grid origin\n\ndy: Dec of cluster center relative to grid origin\n\ndz: Line of sight offset of cluster center relative to grid origin\n\nr_1: Amount to scale along x-axis\n\nr_2: Amount to scale along y-axis\n\nr_3: Amount to scale along z-axis\n\ntheta: Angle to rotate in xy-plane\n\nP0: Amplitude of the pressure profile\n\nc500: Concentration parameter at a density contrast of 500\n\nm500: Mass at a density contrast of 500\n\ngamma: The central slope\n\nalpha: The intermediate slope\n\nbeta: The outer slope\n\nz: Redshift of cluster\n\nxyz: Coordinte grid to calculate model on\n</code></pre> <p>Returns:</p> <pre><code>model: The gnfw model\n</code></pre> Source code in <code>witch/structure.py</code> <pre><code>@jax.jit\ndef gnfw(dx, dy, dz, r_1, r_2, r_3, theta, P0, c500, m500, gamma, alpha, beta, z, xyz):\n    \"\"\"\n    Elliptical gNFW pressure profile in 3d.\n    This function does not include smoothing or declination stretch\n    which should be applied at the end.\n\n    Arguments:\n\n        dx: RA of cluster center relative to grid origin\n\n        dy: Dec of cluster center relative to grid origin\n\n        dz: Line of sight offset of cluster center relative to grid origin\n\n        r_1: Amount to scale along x-axis\n\n        r_2: Amount to scale along y-axis\n\n        r_3: Amount to scale along z-axis\n\n        theta: Angle to rotate in xy-plane\n\n        P0: Amplitude of the pressure profile\n\n        c500: Concentration parameter at a density contrast of 500\n\n        m500: Mass at a density contrast of 500\n\n        gamma: The central slope\n\n        alpha: The intermediate slope\n\n        beta: The outer slope\n\n        z: Redshift of cluster\n\n        xyz: Coordinte grid to calculate model on\n\n    Returns:\n\n        model: The gnfw model\n    \"\"\"\n    nz = get_nz(z)\n    hz = get_hz(z)\n\n    x, y, z = transform_grid(dx, dy, dz, r_1, r_2, r_3, theta, xyz)\n\n    r500 = (m500 / (4.00 * jnp.pi / 3.00) / 5.00e02 / nz) ** (1.00 / 3.00)\n\n    r = c500 * jnp.sqrt(x**2 + y**2 + z**2) / r500\n    denominator = (r**gamma) * (1 + r**alpha) ** ((beta - gamma) / alpha)\n\n    P500 = (\n        1.65e-03\n        * (m500 / (3.00e14 / h70)) ** (2.00 / 3.00 + ap)\n        * hz ** (8.00 / 3.00)\n        * h70**2\n    )\n\n    return P500 * P0 / denominator\n</code></pre>"},{"location":"reference/structure/#witch.structure.isobeta","title":"<code>isobeta(dx, dy, dz, r_1, r_2, r_3, theta, beta, amp, xyz)</code>","text":"<p>Elliptical isobeta pressure profile in 3d. This function does not include smoothing or declination stretch which should be applied at the end.</p> <p>Arguments:</p> <pre><code>dx: RA of cluster center relative to grid origin\n\ndy: Dec of cluster center relative to grid origin\n\ndz: Line of sight offset of cluster center relative to grid origin\n\nr_1: Amount to scale along x-axis\n\nr_2: Amount to scale along y-axis\n\nr_3: Amount to scale along z-axis\n\ntheta: Angle to rotate in xy-plane\n\nbeta: Beta value of isobeta model\n\namp: Amplitude of isobeta model\n\nxyz: Coordinte grid to calculate model on\n</code></pre> <p>Returns:</p> <pre><code>model: The isobeta model\n</code></pre> Source code in <code>witch/structure.py</code> <pre><code>@jax.jit\ndef isobeta(dx, dy, dz, r_1, r_2, r_3, theta, beta, amp, xyz):\n    \"\"\"\n    Elliptical isobeta pressure profile in 3d.\n    This function does not include smoothing or declination stretch\n    which should be applied at the end.\n\n    Arguments:\n\n        dx: RA of cluster center relative to grid origin\n\n        dy: Dec of cluster center relative to grid origin\n\n        dz: Line of sight offset of cluster center relative to grid origin\n\n        r_1: Amount to scale along x-axis\n\n        r_2: Amount to scale along y-axis\n\n        r_3: Amount to scale along z-axis\n\n        theta: Angle to rotate in xy-plane\n\n        beta: Beta value of isobeta model\n\n        amp: Amplitude of isobeta model\n\n        xyz: Coordinte grid to calculate model on\n\n    Returns:\n\n        model: The isobeta model\n    \"\"\"\n    x, y, z = transform_grid(dx, dy, dz, r_1, r_2, r_3, theta, xyz)\n\n    rr = 1 + x**2 + y**2 + z**2\n    power = -1.5 * beta\n    rrpow = rr**power\n\n    return amp * rrpow\n</code></pre>"},{"location":"reference/utils/","title":"utils","text":"<p>A set of utility functions and constants used for unit conversions and adding generic structure common to multiple models.</p>"},{"location":"reference/utils/#witch.utils.K_CMB2K_RJ","title":"<code>K_CMB2K_RJ(freq)</code>","text":"<p>Convert from K_CMB to K_RJ.</p> <p>Arguments:</p> <pre><code>freq: The observing frequency in Hz.\n</code></pre> <p>Returns:</p> <pre><code>K_CMB2K_RJ: Conversion factor from K_CMB to K_RJ.\n</code></pre> Source code in <code>witch/utils.py</code> <pre><code>@partial(jax.jit, static_argnums=(0,))\ndef K_CMB2K_RJ(freq):\n    \"\"\"\n    Convert from K_CMB to K_RJ.\n\n    Arguments:\n\n        freq: The observing frequency in Hz.\n\n    Returns:\n\n        K_CMB2K_RJ: Conversion factor from K_CMB to K_RJ.\n    \"\"\"\n    x = freq * h / kb / Tcmb\n    return jnp.exp(x) * x * x / jnp.expm1(x) ** 2\n</code></pre>"},{"location":"reference/utils/#witch.utils.beam_double_gauss","title":"<code>beam_double_gauss(dr, fwhm1=9.735, amp1=0.9808, fwhm2=32.627, amp2=0.0192)</code>","text":"<p>Helper function to generate a double gaussian beam.</p> <p>Arguments:</p> <pre><code>dr: Pixel size.\n\nfwhm1: Full width half max of the primary gaussian.\n\namp1: Amplitude of the primary gaussian.\n\nfwhm2: Full width half max of the secondairy gaussian.\n\namp2: Amplitude of the secondairy gaussian.\n</code></pre> <p>Returns:</p> <pre><code>beam: Double gaussian beam.\n</code></pre> Source code in <code>witch/utils.py</code> <pre><code>def beam_double_gauss(dr, fwhm1=9.735, amp1=0.9808, fwhm2=32.627, amp2=0.0192):\n    \"\"\"\n    Helper function to generate a double gaussian beam.\n\n    Arguments:\n\n        dr: Pixel size.\n\n        fwhm1: Full width half max of the primary gaussian.\n\n        amp1: Amplitude of the primary gaussian.\n\n        fwhm2: Full width half max of the secondairy gaussian.\n\n        amp2: Amplitude of the secondairy gaussian.\n\n    Returns:\n\n        beam: Double gaussian beam.\n    \"\"\"\n    x = jnp.arange(-1.5 * fwhm1 // (dr), 1.5 * fwhm1 // (dr)) * (dr)\n    beam_xx, beam_yy = jnp.meshgrid(x, x)\n    beam_rr = jnp.sqrt(beam_xx**2 + beam_yy**2)\n    beam = amp1 * jnp.exp(-4 * jnp.log(2) * beam_rr**2 / fwhm1**2) + amp2 * jnp.exp(\n        -4 * jnp.log(2) * beam_rr**2 / fwhm2**2\n    )\n    return beam / jnp.sum(beam)\n</code></pre>"},{"location":"reference/utils/#witch.utils.bilinear_interp","title":"<code>bilinear_interp(x, y, xp, yp, fp)</code>","text":"<p>JAX implementation of bilinear interpolation. Out of bounds values are set to 0. Using the repeated linear interpolation method here, see https://en.wikipedia.org/wiki/Bilinear_interpolation#Repeated_linear_interpolation.</p> <p>Arguments:</p> <pre><code>x: X values to return interpolated values at.\n\ny: Y values to return interpolated values at.\n\nxp: X values to interpolate with, should be 1D.\n    Assumed to be sorted.\n\nyp: Y values to interpolate with, should be 1D.\n    Assumed to be sorted.\n\nfp: Functon values at (xp, yp), should have shape (len(xp), len(yp)).\n    Note that if you are using meshgrid, we assume 'ij' indexing.\n</code></pre> <p>Return:</p> <pre><code>f: The interpolated values\n</code></pre> Source code in <code>witch/utils.py</code> <pre><code>@jax.jit\ndef bilinear_interp(x, y, xp, yp, fp):\n    \"\"\"\n    JAX implementation of bilinear interpolation.\n    Out of bounds values are set to 0.\n    Using the repeated linear interpolation method here,\n    see https://en.wikipedia.org/wiki/Bilinear_interpolation#Repeated_linear_interpolation.\n\n    Arguments:\n\n        x: X values to return interpolated values at.\n\n        y: Y values to return interpolated values at.\n\n        xp: X values to interpolate with, should be 1D.\n            Assumed to be sorted.\n\n        yp: Y values to interpolate with, should be 1D.\n            Assumed to be sorted.\n\n        fp: Functon values at (xp, yp), should have shape (len(xp), len(yp)).\n            Note that if you are using meshgrid, we assume 'ij' indexing.\n\n    Return:\n\n        f: The interpolated values\n    \"\"\"\n    if len(xp.shape) != 1:\n        raise ValueError(\"xp must be 1D\")\n    if len(yp.shape) != 1:\n        raise ValueError(\"yp must be 1D\")\n    if fp.shape != xp.shape + yp.shape:\n        raise ValueError(\n            \"Incompatible shapes for fp, xp, yp: %s, %s, %s\",\n            fp.shape,\n            xp.shape,\n            yp.shape,\n        )\n\n    # Figure out bounds and mapping\n    # This breaks if xp, yp is not sorted\n    ix = jnp.clip(jnp.searchsorted(xp, x, side=\"right\"), 1, len(xp) - 1)\n    iy = jnp.clip(jnp.searchsorted(yp, y, side=\"right\"), 1, len(yp) - 1)\n    q_11 = fp[ix - 1, iy - 1]\n    q_21 = fp[ix, iy - 1]\n    q_12 = fp[ix - 1, iy]\n    q_22 = fp[ix, iy]\n\n    # Interpolate in x to start\n    denom_x = xp[ix] - xp[ix - 1]\n    dx_1 = x - xp[ix - 1]\n    dx_2 = xp[ix] - x\n    f_xy1 = (dx_2 * q_11 + dx_1 * q_21) / denom_x\n    f_xy2 = (dx_2 * q_12 + dx_1 * q_22) / denom_x\n\n    # Now do y as well\n    denom_y = yp[iy] - yp[iy - 1]\n    dy_1 = y - yp[iy - 1]\n    dy_2 = yp[iy] - y\n    f = (dy_2 * f_xy1 + dy_1 * f_xy2) / denom_y\n\n    # Zero out the out of bounds values\n    f = jnp.where((x &lt; xp[0]) + (x &gt; xp[-1]) + (y &lt; yp[0]) + (y &gt; yp[-1]), 0.0, f)\n\n    return f\n</code></pre>"},{"location":"reference/utils/#witch.utils.fft_conv","title":"<code>fft_conv(image, kernel)</code>","text":"<p>Perform a convolution using FFTs for speed.</p> <p>Arguments:</p> <pre><code>image: Data to be convolved\n\nkernel: Convolution kernel\n</code></pre> <p>Returns:</p> <pre><code>convolved_map: Image convolved with kernel.\n</code></pre> Source code in <code>witch/utils.py</code> <pre><code>@jax.jit\ndef fft_conv(image, kernel):\n    \"\"\"\n    Perform a convolution using FFTs for speed.\n\n    Arguments:\n\n        image: Data to be convolved\n\n        kernel: Convolution kernel\n\n    Returns:\n\n        convolved_map: Image convolved with kernel.\n    \"\"\"\n    Fmap = jnp.fft.fft2(jnp.fft.fftshift(image))\n    Fkernel = jnp.fft.fft2(jnp.fft.fftshift(kernel))\n    convolved_map = jnp.fft.fftshift(jnp.real(jnp.fft.ifft2(Fmap * Fkernel)))\n\n    return convolved_map\n</code></pre>"},{"location":"reference/utils/#witch.utils.get_da","title":"<code>get_da(z)</code>","text":"<p>Get factor to convert from arcseconds to MPc.</p> <p>Arguments:</p> <pre><code>z: The redshift at which to compute the factor.\n</code></pre> <p>Returns:</p> <pre><code>da: Conversion factor from arcseconds to MPc\n</code></pre> Source code in <code>witch/utils.py</code> <pre><code>def get_da(z):\n    \"\"\"\n    Get factor to convert from arcseconds to MPc.\n\n    Arguments:\n\n        z: The redshift at which to compute the factor.\n\n    Returns:\n\n        da: Conversion factor from arcseconds to MPc\n    \"\"\"\n    return jnp.interp(z, dzline, daline)\n</code></pre>"},{"location":"reference/utils/#witch.utils.get_hz","title":"<code>get_hz(z)</code>","text":"<p>Get h(z).</p> <p>Arguments:</p> <pre><code>z: The redshift at which to compute the factor.\n</code></pre> <p>Returns:</p> <pre><code>hz: h at the given z.\n</code></pre> Source code in <code>witch/utils.py</code> <pre><code>def get_hz(z):\n    \"\"\"\n    Get h(z).\n\n    Arguments:\n\n        z: The redshift at which to compute the factor.\n\n    Returns:\n\n        hz: h at the given z.\n    \"\"\"\n    return jnp.interp(z, dzline, hzline)\n</code></pre>"},{"location":"reference/utils/#witch.utils.get_nz","title":"<code>get_nz(z)</code>","text":"<p>Get n(z).</p> <p>Arguments:</p> <pre><code>z: The redshift at which to compute the factor.\n</code></pre> <p>Returns:</p> <pre><code>nz: n at the given z.\n</code></pre> Source code in <code>witch/utils.py</code> <pre><code>def get_nz(z):\n    \"\"\"\n    Get n(z).\n\n    Arguments:\n\n        z: The redshift at which to compute the factor.\n\n    Returns:\n\n        nz: n at the given z.\n    \"\"\"\n    return jnp.interp(z, dzline, nzline)\n</code></pre>"},{"location":"reference/utils/#witch.utils.make_grid","title":"<code>make_grid(r_map, dx, dy=None, dz=None, x0=0, y0=0)</code>","text":"<p>Make coordinate grids to build models in. All grids are sparse and are int(2*r_map / dr) in each dimension.</p> <p>Arguments:</p> <pre><code>r_map: Size of grid radially.\n\ndx: Grid resolution in x, should be in same units as r_map.\n\ndy: Grid resolution in y, should be in same units as r_map.\n    If None then dy is set to dx.\n\ndz: Grid resolution in z, should be in same units as r_map.\n    If None then dz is set to dx.\n\nx0: Origin of grid in RA, assumed to be in same units as r_map.\n\ny0: Origin of grid in Dec, assumed to be in same units as r_map.\n</code></pre> <p>Returns:</p> <pre><code>x: Grid of x coordinates in same units as r_map.\n\ny: Grid of y coordinates in same units as r_map\n\nz: Grid of z coordinates in same units as r_map\n</code></pre> Source code in <code>witch/utils.py</code> <pre><code>def make_grid(r_map, dx, dy=None, dz=None, x0=0, y0=0):\n    \"\"\"\n    Make coordinate grids to build models in.\n    All grids are sparse and are int(2*r_map / dr) in each dimension.\n\n    Arguments:\n\n        r_map: Size of grid radially.\n\n        dx: Grid resolution in x, should be in same units as r_map.\n\n        dy: Grid resolution in y, should be in same units as r_map.\n            If None then dy is set to dx.\n\n        dz: Grid resolution in z, should be in same units as r_map.\n            If None then dz is set to dx.\n\n        x0: Origin of grid in RA, assumed to be in same units as r_map.\n\n        y0: Origin of grid in Dec, assumed to be in same units as r_map.\n\n    Returns:\n\n        x: Grid of x coordinates in same units as r_map.\n\n        y: Grid of y coordinates in same units as r_map\n\n        z: Grid of z coordinates in same units as r_map\n    \"\"\"\n    if dy is None:\n        dy = dx\n    if dz is None:\n        dz = dx\n\n    # Make grid with resolution dr and size r_map\n    x = (\n        jnp.linspace(-1 * r_map, r_map, 2 * int(r_map / dx))\n        / jnp.cos(y0 / rad_to_arcsec)\n        + x0\n    )\n    y = jnp.linspace(-1 * r_map, r_map, 2 * int(r_map / dy)) + y0\n    z = jnp.linspace(-1 * r_map, r_map, 2 * int(r_map / dz))\n\n    return tuple(jnp.meshgrid(x, y, z, sparse=True, indexing=\"ij\") + [x0, y0])\n</code></pre>"},{"location":"reference/utils/#witch.utils.make_grid_from_skymap","title":"<code>make_grid_from_skymap(skymap, z_map, dz, x0=None, y0=None)</code>","text":"<p>Make coordinate grids to build models in. All grids are sparse and are int(2*r_map / dr) in each dimension.</p> <p>Arguments:</p> <pre><code>z_map: Size of grid along LOS, in radians.\n\ndz: Grid resolution along LOS, in radians.\n\nx0: Map x center in radians. If None, grid center is used.\n\ny0: Map y center in radians. If None, grid center is used.\n</code></pre> <p>Returns:</p> <pre><code>x: Grid of x coordinates in radians.\n\ny: Grid of y coordinates in radians.\n\nz: Grid of z coordinates in radians.\n</code></pre> Source code in <code>witch/utils.py</code> <pre><code>def make_grid_from_skymap(skymap, z_map, dz, x0=None, y0=None):\n    \"\"\"\n    Make coordinate grids to build models in.\n    All grids are sparse and are int(2*r_map / dr) in each dimension.\n\n    Arguments:\n\n        z_map: Size of grid along LOS, in radians.\n\n        dz: Grid resolution along LOS, in radians.\n\n        x0: Map x center in radians. If None, grid center is used.\n\n        y0: Map y center in radians. If None, grid center is used.\n\n    Returns:\n\n        x: Grid of x coordinates in radians.\n\n        y: Grid of y coordinates in radians.\n\n        z: Grid of z coordinates in radians.\n    \"\"\"\n    # make grid\n    _x = jnp.arange(skymap.nx, dtype=float)\n    _y = jnp.arange(skymap.ny, dtype=float)\n    _z = jnp.linspace(-1 * z_map, z_map, 2 * int(z_map / dz), dtype=float)\n    x, y, z = jnp.meshgrid(_x, _y, _z, sparse=True, indexing=\"ij\")\n\n    # Pad so we don't need to broadcast\n    x_flat = x.ravel()\n    y_flat = y.ravel()\n    len_diff = len(x_flat) - len(y_flat)\n    if len_diff &gt; 0:\n        y_flat = jnp.pad(y_flat, (0, len_diff), \"edge\")\n    elif len_diff &lt; 0:\n        x_flat = jnp.pad(x_flat, (0, abs(len_diff)), \"edge\")\n\n    # Convert x and y to ra/dec\n    ra_dec = skymap.wcs.wcs_pix2world(\n        jnp.column_stack((x_flat, y_flat)), 0, ra_dec_order=True\n    )\n    ra_dec = np.deg2rad(ra_dec)\n    ra = ra_dec[:, 0]\n    dec = ra_dec[:, 1]\n\n    # Remove padding\n    if len_diff &gt; 0:\n        dec = dec[: (-1 * len_diff)]\n    elif len_diff &lt; 0:\n        ra = ra[:len_diff]\n\n    if not x0:\n        x0 = (skymap.lims[1] + skymap.lims[0]) / 2\n    if not y0:\n        y0 = (skymap.lims[3] + skymap.lims[2]) / 2\n\n    ra -= x0\n    dec -= y0\n\n    # Sparse indexing to save mem\n    x = x.at[:, 0, 0].set(ra)\n    y = y.at[0, :, 0].set(dec)\n\n    return x, y, z\n</code></pre>"},{"location":"reference/utils/#witch.utils.tod_hi_pass","title":"<code>tod_hi_pass(tod, N_filt)</code>","text":"<p>High pass a tod with a tophat</p> <p>Arguments:</p> <pre><code>tod: TOD to high pass\n\nN_filt: N_filt of tophat\n</code></pre> <p>Returns:</p> <pre><code>tod_filtered: Filtered TOD\n</code></pre> Source code in <code>witch/utils.py</code> <pre><code>@partial(jax.jit, static_argnums=(1,))\ndef tod_hi_pass(tod, N_filt):\n    \"\"\"\n    High pass a tod with a tophat\n\n    Arguments:\n\n        tod: TOD to high pass\n\n        N_filt: N_filt of tophat\n\n\n    Returns:\n\n        tod_filtered: Filtered TOD\n    \"\"\"\n    mask = jnp.ones(tod.shape)\n    mask = jax.ops.index_update(mask, jax.ops.index[..., :N_filt], 0.0)\n\n    ## apply the filter in fourier space\n    Ftod = jnp.fft.fft(tod)\n    Ftod_filtered = Ftod * mask\n    tod_filtered = jnp.fft.ifft(Ftod_filtered).real\n    return tod_filtered\n</code></pre>"},{"location":"reference/utils/#witch.utils.tod_to_index","title":"<code>tod_to_index(xi, yi, x0, y0, grid, conv_factor)</code>","text":"<p>Convert RA/Dec TODs to index space.</p> <p>Arguments:</p> <pre><code>xi: RA TOD\n\nyi: Dec TOD\n\nx0: RA at center of model. Nominally the cluster center.\n\ny0: Dec at center of model. Nominally the cluster center.\n\ngrid: The grid to index on.\n\nconv_factor: Conversion factor to put RA and Dec in same units as r_map.\n             Nominally (da * 180 * 3600) / pi\n</code></pre> <p>Returns:</p> <pre><code>idx: The RA TOD in index space\n\nidy: The Dec TOD in index space.\n</code></pre> Source code in <code>witch/utils.py</code> <pre><code>def tod_to_index(xi, yi, x0, y0, grid, conv_factor):\n    \"\"\"\n    Convert RA/Dec TODs to index space.\n\n    Arguments:\n\n        xi: RA TOD\n\n        yi: Dec TOD\n\n        x0: RA at center of model. Nominally the cluster center.\n\n        y0: Dec at center of model. Nominally the cluster center.\n\n        grid: The grid to index on.\n\n        conv_factor: Conversion factor to put RA and Dec in same units as r_map.\n                     Nominally (da * 180 * 3600) / pi\n\n    Returns:\n\n        idx: The RA TOD in index space\n\n        idy: The Dec TOD in index space.\n    \"\"\"\n    dx = (xi - x0) * jnp.cos(yi)\n    dy = yi - y0\n\n    dx *= conv_factor\n    dy *= conv_factor\n\n    # Assuming sparse indexing here\n    idx = np.digitize(dx, grid[0].ravel())\n    idy = np.digitize(dy, grid[1].ravel())\n\n    idx = np.rint(idx).astype(int)\n    idy = np.rint(idy).astype(int)\n\n    # Ensure out of bounds for stuff not in grid\n    idx = jnp.where((idx &lt; 0) + (idx &gt;= grid[0].shape[0]), 2 * grid[0].shape[0], idx)\n    idy = jnp.where((idy &lt; 0) + (idy &gt;= grid[1].shape[1]), 2 * grid[1].shape[1], idy)\n\n    return idx, idy\n</code></pre>"},{"location":"reference/utils/#witch.utils.transform_grid","title":"<code>transform_grid(dx, dy, dz, r_1, r_2, r_3, theta, xyz)</code>","text":"<p>Shift, rotate, and apply ellipticity to coordinate grid.</p> <p>Arguments:</p> <pre><code>dx: RA of cluster center relative to grid origin\n\ndy: Dec of cluster center relative to grid origin\n\ndz: Line of sight offset of cluster center relative to grid origin\n\nr_1: Amount to scale along x-axis\n\nr_2: Amount to scale along y-axis\n\nr_3: Amount to scale along z-axis\n\ntheta: Angle to rotate in xy-plane\n\nxyz: Coordinte grid to transform\n</code></pre> <p>Returns:</p> <pre><code>xyz: Transformed coordinate grid\n</code></pre> Source code in <code>witch/utils.py</code> <pre><code>@jax.jit\ndef transform_grid(dx, dy, dz, r_1, r_2, r_3, theta, xyz):\n    \"\"\"\n    Shift, rotate, and apply ellipticity to coordinate grid.\n\n    Arguments:\n\n        dx: RA of cluster center relative to grid origin\n\n        dy: Dec of cluster center relative to grid origin\n\n        dz: Line of sight offset of cluster center relative to grid origin\n\n        r_1: Amount to scale along x-axis\n\n        r_2: Amount to scale along y-axis\n\n        r_3: Amount to scale along z-axis\n\n        theta: Angle to rotate in xy-plane\n\n        xyz: Coordinte grid to transform\n\n    Returns:\n\n        xyz: Transformed coordinate grid\n    \"\"\"\n    # Get origin\n    x0, y0 = xyz[3], xyz[4]\n    # Shift origin\n    x = (xyz[0] - (x0 + dx / jnp.cos(y0 / rad_to_arcsec))) * jnp.cos(\n        (y0 + dy) / rad_to_arcsec\n    )\n    y = xyz[1] - (y0 + dy)\n    z = xyz[2] - dz\n\n    # Rotate\n    xx = x * jnp.cos(theta) + y * jnp.sin(theta)\n    yy = y * jnp.cos(theta) - x * jnp.sin(theta)\n\n    # Apply ellipticity\n    x = xx / r_1\n    y = yy / r_2\n    z = z / r_3\n\n    return x, y, z\n</code></pre>"},{"location":"reference/utils/#witch.utils.y2K_CMB","title":"<code>y2K_CMB(freq, Te)</code>","text":"<p>Convert from compton y to K_CMB.</p> <p>Arguments:</p> <pre><code>freq: The observing frequency in Hz.\n\nTe: Electron temperature\n</code></pre> <p>Returns:</p> <pre><code>y2K_CMB: Conversion factor from compton y to K_CMB.\n</code></pre> Source code in <code>witch/utils.py</code> <pre><code>@partial(jax.jit, static_argnums=(0, 1))\ndef y2K_CMB(freq, Te):\n    \"\"\"\n    Convert from compton y to K_CMB.\n\n    Arguments:\n\n        freq: The observing frequency in Hz.\n\n        Te: Electron temperature\n\n    Returns:\n\n        y2K_CMB: Conversion factor from compton y to K_CMB.\n    \"\"\"\n    x = freq * h / kb / Tcmb\n    xt = x / jnp.tanh(0.5 * x)\n    st = x / jnp.sinh(0.5 * x)\n    # fmt:off\n    Y0 = -4.0 + xt\n    Y1 = (-10.0\n        + ((47.0 / 2.0) + (-(42.0 / 5.0) + (7.0 / 10.0) * xt) * xt) * xt\n        + st * st * (-(21.0 / 5.0) + (7.0 / 5.0) * xt)\n    )\n    Y2 = ((-15.0 / 2.0)\n        + ((1023.0 / 8.0) + ((-868.0 / 5.0) + ((329.0 / 5.0) + ((-44.0 / 5.0) + (11.0 / 30.0) * xt) * xt) * xt) * xt) * xt\n        + ((-434.0 / 5.0) + ((658.0 / 5.0) + ((-242.0 / 5.0) + (143.0 / 30.0) * xt) * xt) * xt\n        + (-(44.0 / 5.0) + (187.0 / 60.0) * xt) * (st * st)) * st * st\n    )\n    Y3 = ((15.0 / 2.0)\n        + ((2505.0 / 8.0) + ((-7098.0 / 5.0) + ((14253.0 / 10.0) + ((-18594.0 / 35.0) \n         + ((12059.0 / 140.0) + ((-128.0 / 21.0) + (16.0 / 105.0) * xt) * xt) * xt) * xt) * xt) * xt) * xt\n        + (((-7098.0 / 10.0) + ((14253.0 / 5.0) + ((-102267.0 / 35.0) + ((156767.0 / 140.0)\n         + ((-1216.0 / 7.0) + (64.0 / 7.0) * xt) * xt) * xt) * xt) * xt)\n         + (((-18594.0 / 35.0) + ((205003.0 / 280.0) + ((-1920.0 / 7.0) + (1024.0 / 35.0) * xt) * xt) * xt)\n          + ((-544.0 / 21.0) + (992.0 / 105.0) * xt) * st * st) * st * st) * st * st\n    )\n    Y4 = ((-135.0 / 32.0)\n        + ((30375.0 / 128.0) + ((-62391.0 / 10.0) + ((614727.0 / 40.0) + ((-124389.0 / 10.0) + ((355703.0 / 80.0) + ((-16568.0 / 21.0)\n         + ((7516.0 / 105.0) + ((-22.0 / 7.0) + (11.0 / 210.0) * xt) * xt) * xt) * xt) * xt) * xt) * xt) * xt) * xt\n        + ((-62391.0 / 20.0) + ((614727.0 / 20.0) + ((-1368279.0 / 20.0) + ((4624139.0 / 80.0) + ((-157396.0 / 7.0) + ((30064.0 / 7.0)\n         + ((-2717.0 / 7.0) + (2761.0 / 210.0) * xt) * xt) * xt) * xt) * xt) * xt) * xt\n         + ((-124389.0 / 10.0)\n          + ((6046951.0 / 160.0) + ((-248520.0 / 7.0) + ((481024.0 / 35.0) + ((-15972.0 / 7.0) + (18689.0 / 140.0) * xt) * xt) * xt) * xt) * xt\n          + ((-70414.0 / 21.0) + ((465992.0 / 105.0) + ((-11792.0 / 7.0) + (19778.0 / 105.0) * xt) * xt) * xt\n           + ((-682.0 / 7.0) + (7601.0 / 210.0) * xt) * st * st) * st * st) * st * st) * st * st\n    )\n    # fmt:on\n    factor = Y0 + (Te / me) * (\n        Y1 + (Te / me) * (Y2 + (Te / me) * (Y3 + (Te / me) * Y4))\n    )\n    return factor * Tcmb\n</code></pre>"},{"location":"reference/utils/#witch.utils.y2K_RJ","title":"<code>y2K_RJ(freq, Te)</code>","text":"<p>Convert from compton y to K_RJ.</p> <p>Arguments:</p> <pre><code>freq: The observing frequency in Hz.\n\nTe: Electron temperature\n</code></pre> <p>Returns:</p> <pre><code>y2K_RJ: Conversion factor from compton y to K_RJ.\n</code></pre> Source code in <code>witch/utils.py</code> <pre><code>@partial(jax.jit, static_argnums=(0, 1))\ndef y2K_RJ(freq, Te):\n    \"\"\"\n    Convert from compton y to K_RJ.\n\n    Arguments:\n\n        freq: The observing frequency in Hz.\n\n        Te: Electron temperature\n\n    Returns:\n\n        y2K_RJ: Conversion factor from compton y to K_RJ.\n    \"\"\"\n    factor = y2K_CMB(freq, Te)\n    return factor * K_CMB2K_RJ(freq)\n</code></pre>"}]}