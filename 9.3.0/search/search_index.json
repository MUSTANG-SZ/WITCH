{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"WITCH (WHERE IS THAT CLUSTER HIDING)","text":"<p>This repository contains tools for modeling and fitting SZ data of galaxy clusters. While this code was originally written for MUSTANG-2 it is largely generic enough to work with data for other telescopes.</p>"},{"location":"#the-witch-library","title":"The <code>WITCH</code> Library","text":"<p>The core of this repository is the <code>WITCH</code> library. <code>WITCH</code> produces models of galaxy clusters and their gradients in a format that can be consumed by <code>minkasi</code>'s fitting code.</p> <p>The core concept of <code>WITCH</code> is to model the cluster as a 3D pressure profile and then apply modifications to that profile to represent substructure. For example, a cavity can be modeled as a multiplicative suppression of the pressure within a certain region. The profile is then integrated along the line of sight to produce a signal like we would observe via the SZ effect. To produce gradients of the clusters and JIT expensive computations we employ <code>jax</code>.</p> <p>This framework makes it very easy to add new types of models, see the Contributing section for more.</p>"},{"location":"#end-users-and-the-fitterpy-script","title":"End Users and the <code>fitter.py</code> Script","text":"<p>End users (i.e., users who will not be developing <code>WITCH</code>) should interact with the software entirely by writing configs yamls. Once <code>WITCH</code> is built, the command line executable <code>witcher</code> will be made available, which basically wraps <code>fitter.py</code>.  This fitter injests config files and performs the fitting. The usage is <pre><code>mpirun -n N witcher /PATH/TO/my_config.yaml\n</code></pre> where the <code>mpirun</code> call is optional and will automatically run the code in parallel. The screen output can of course optionally be pipped to an output file, but necessary outputs (model parameters, uncertainties, etc.) will be saved as part of the <code>witcher</code> call.</p>"},{"location":"#writing-config-files","title":"Writing Config Files","text":"<p>This section is an abreviation of the more extensive documentation available here.</p> <p>For end users, config files are the only thing you need to change to run <code>WITCH</code>. In these files, you specify what data you would like to fit, how you would like to fit it, and what model you would like to fit to that data. Config files can refer to other config files, in which case they will be collated into one config before execution. This makes it easy to fit your data to many different models, by specifying one <code>_base.yaml</code> which defines the data processing, and a series of <code>_model.yaml</code>s which specify the model to be fit and refer back to <code>_base.yaml</code>. When running <code>witcher</code>, the highest level yaml should be passed as a commandline argument; in the example below, that is <code>RXJ1347_a10.yaml</code>. </p> <p>We will use the <code>yaml</code> files <code>RXJ1347_a10.yaml</code> and <code>base_unit.yaml</code>, both found in the <code>unit_tests</code> directory as examples. These files are well commented and should be read through in addition to reading this section. Starting with <code>base_unit.yaml</code>, this file defines the data used in the fit and which data  processing routines to use. These configs are a good place to start for writing your own configs, especially if you are fitting MUSTANG-2 data.</p> <p>Firstly, <code>fit</code> and <code>sub</code> tell the script to fit the model to the data and to make residuals of the model to the data. <code>nrounds</code>  tells the script how many rounds of fitting to perform. <code>contstants</code> defines a number of constants used in the fitting, including <code>Te</code> the electron  temperature, <code>freq</code>, the frequency of observation, and <code>z</code>, the redshift of the cluster. <code>paths</code> specifies the path <code>witcher</code> should search to obtain data to fit, as well as the outroot to save the data to. All paths are relative to the global environmental variables <code>WITCH_DATAROOT</code> (for data) and <code>WITCH_OUTROOT</code> (for outputs), which you should set in your <code>.bashrc</code>.</p> <p><code>coords</code> defines the grid on which the model will be built. The larger and higher resolution the grid, the more accurate the results will be, at the cost of computation time. In general, <code>r_map</code> should be larger than the largest scale in your model you are interested in.  Keep in mind atmospheric effects restrict MUSTANG-2 to recover scales of 2.5' radisu and smaller. <code>dr</code> should be a few times smaller than the instrument beam, which is 9\" for MUSTANG-2. <code>dz</code> is the line-of-sight (LoS) resolution and is to integrate the model along the LoS.  Generally the accuracy is less sensitive to <code>dz</code>, which can be set somewhat higher than <code>dr</code>. If you're unsure what to do for <code>grid</code>, the defaults in <code>base_config.yaml</code> should be safe.</p> <p><code>datasets</code> defines the functions which load, process, and apply noise to the data used by <code>WITCH</code>. These are defined on a per-instrument basis  for the purposes of joint fitting; if you are only fitting one data set, only one sub-header should be defined. The <code>noise</code> field defines what noise model to use when fitting. <code>funcs</code> defines the experiment-specific functions which are used to load the data, perform preprocessing, etc. These are defined in the <code>WITCH/external</code> submodule. <code>beam</code> defines the beam parameters, while <code>dograd</code> and <code>npass</code> are options for mapmakting which can be left to their defaults. If you are only working with MUSTANG-2 data, all these values can be left at their defaults from <code>base_config.yaml</code>.</p> <p><code>fitter</code> sets hyper-parameters for the fitting routine, specifically the maximum number of interations to take per step and the <code>chitol</code> which sets delta-chi-squared minimum for a step to be considered converged. Finally, <code>imports</code> defines additional packages to be loaded into the script at runtime. Again, these can all be left at their default values.</p> <p><code>RXJ1347_a10</code> defines a specific Arnaud 2010 model which will be fit to the data loaded in <code>base_unit.yaml</code>.  First, the <code>base</code> header tells <code>witcher</code> to load the config specified in <code>base</code> as part of the full config. <code>name</code> is self explanatory, although note this has to match the name used for the TOD directory. <code>noise_map</code> and <code>model_map</code> tell <code>witcher</code> to make maps of just the noise and of the model, respectively. </p> <p>The <code>model</code> contains the actual specification for the model that will be fit to the data. At the top, <code>unit_conversion</code> defines the conversion from the units of the model (typically pressure in something like keV / cm^3) to map units (K Rayleigh\u2013Jeans for MUSTANG-2). If you are only fitting MUSTANG-2, you should stick to using the default specified in <code>RXJ1347_a10</code>. This unit conversion, <pre><code>float(wu.get_da(constants['z'])*wu.y2K_RJ(constants['freq'], constants['Te'])*wu.XMpc/wu.me)\n</code></pre> first gets the angular dymeter distance to convert from radians to Mpc, then multiplies by the conversion from Compton-y to K RJ, then finally multiplies by the Thompson scattering cross section divided by the mass of the elctron, which is the conversion from integrated pressure to Compton-y (see Mroczkowski 2019, eqn. 5. </p> <p>Next the various model componants are specified. In this case, we are fitting an A10 model plus a point source. <code>structures</code> indicates that we have moved on to specifying the model components, while <code>a10</code> names the first component. Under <code>a10</code>, <code>structure: a10</code> specifies that this component is a <code>class a10</code> from <code>witch.structures</code>. Note the <code>a10</code> header is the name of the component, which is only used to refer to  this particular componant, while <code>structure: a10</code> actually defines what structure it is. This is useful if you have, say, 2 A10s, in which case you could have  <pre><code>a10_1:\n  structure: 10\n  ...\na10_2:\n  structure: 10\n  ...\n</code></pre> All available structures are defined in <code>witch.structure</code>. The  documenation available at that link specifies what arguments, units, etc are expected by each type of structure. After the type of structure is defined, the <code>parameters</code> header indicates that each parameter will now be defined. Taking as an example <code>dx_1</code>:, the  <code>value</code> header indicates the inital value. The <code>to_fit</code> header can be either a list of booleans of exactly <code>n_rounds</code> length or a boolean.  If it is a list, for each round the parameter will either be fit or held constant at its last value depending on the value of the list at that index. If it is a boolean, than it will either always be fit or always be held constant. <code>True</code> indicates fit while <code>False</code> indicates held constant. Ffinally, the <code>priors</code> header is a list of two float, which define the lower and upper limits for a flat prior for that parameter. Currently only flat priors supported. After <code>dx_1</code>, each parameter is specified in turn. Note <code>dx_1</code> is just the name of the paramter, and  does not need to match the parameter of <code>a10</code>; the parameters will be fed as arguments to <code>a10</code> in the order they are specified.</p> <p>Finally, we then specify another structural component, called <code>ps_gaus</code> is defined, this time a <code>structure: gaussian</code>. Again, all the paramters of the component are specified. Note that the order of structures is unimportant; they can be specified in any order in the configuration file. <code>RXJ1347_a0.yaml</code> can be run via <code>witcher RXJ1347_a0.yaml</code>; it should produce the results stored in <code>RXJ1347_unit.zip</code>.</p>"},{"location":"#installation","title":"Installation","text":"<p>To install the <code>WITCH</code> library first clone this repository and from within it run: <pre><code>pip install .\n</code></pre> If you are going to be actively working on the <code>WITCH</code> library you probably want to include the <code>-e</code> flag.</p> <p>All the dependencies should be installed by <code>pip</code> with the one exception being <code>minkasi</code> itself (only needed for <code>fitter.py</code>). Instructions on installing <code>minkasi</code> can be found here.</p>"},{"location":"#contributing","title":"Contributing","text":"<p>All are welcome to contribute to this repository, be it code or config files. In general contributions other than minor changes should follow the branch/fork -&gt; PR -&gt; merge workflow. If you are going to contribute regularly, contact one of us to get push access to the repository.</p>"},{"location":"#style-and-standards","title":"Style and Standards","text":"<p>In general contributions should be PEP8 with commits in the conventional commits format. This library follows semantic versioning, so changes that bump the version should do so by editing <code>pyproject.toml</code>.</p> <p>In order to make following these rules easier this repository is setup to work with commitizen and pre-commit. It is recommended that you make use of these tools to save time.</p>"},{"location":"#getting-started","title":"Getting Started","text":"<ol> <li>Install both tools with <code>pip install commitizen pre-commit</code>.</li> <li><code>cd</code> into the <code>WITCH</code> repository it you aren't already in it.</li> <li>(Optional) Setup <code>commitizen</code> to automatically run when you run <code>git commit</code>. Follow instruction here.</li> <li>Make sure the <code>pre-commit</code> hook is installed by running <code>pre-commit install</code>.</li> </ol>"},{"location":"#example-workflow","title":"Example Workflow","text":"<ol> <li>Make a branch for the edits you want to make.</li> <li>Code.</li> <li>Commit your code with a conventional commit message.</li> <li><code>cz c</code> gives you a wizard that will do this for you, if you followed Step 3 above then <code>git commit</code> will also do this (but not <code>git commit -m</code>).</li> <li>Repeat step 3 and 4 until the goal if your branch has been completed.</li> <li>Put in a PR.</li> <li>Once the PR is merged the repo version and tag will update automatically.</li> </ol>"},{"location":"#adding-new-models","title":"Adding New Models","text":"<p>When adding new models to <code>WITCH</code>, be they profiles or substructure, there are some changes that need to be made to <code>core.py</code> to expose them properly.</p> <ol> <li>A variable <code>N_PAR_{MODEL}</code> needs to be defined with the number of fittable parameters in the model. Do not include parameters like the grid here.</li> <li>A parameter <code>n_{model}</code> needs to be added to the functions <code>helper</code>, <code>model</code>, and <code>model_grad</code>. Remember to update the <code>static_argnums</code> for <code>model</code> and <code>model_grad</code>. In <code>helper</code> set a default value of <code>0</code> for backwards compatibility.</li> <li>A block grabbing the parameters for the model needs to be added to <code>model</code>. This can largely be copied from the other models, just remember to swap out the relevant variables.</li> <li>A block applying model needs to be added to <code>model</code>. Pressure profiles should come first then substructure. This can largely be copied from the other models, just remember to swap out the relevant variables.</li> </ol> <p>Adding a new model also (usually) means you should bump the minor version in the version number.</p>"},{"location":"#profiling-code","title":"Profiling Code","text":"<p>The script <code>scratch/profile.py</code> uses <code>jax</code> profiling tools to benchmark the library. It outputs a trace file understandable perfetto as well as a text file containing metadata about the software and hardware used while profiling. To use non default settings use <code>python profile.py --help</code> but in most cases the default settings are fine.</p> <p>The profiling script has some additional dependencies. To install them run: <pre><code>pip install .[profile]\n</code></pre></p>"},{"location":"getting_started/","title":"Getting Started","text":"<p>This is not a comprehensive guide to all of the capabilities of <code>WITCH</code> but hopefully it should be enough to get a basic setup working. Useful things that will not be covered in this guide are:</p> <ul> <li>How to add new datasets to <code>WITCH</code></li> <li>Every single configuration file option</li> <li>Joint fitting</li> <li>Tuning HMC parameters</li> <li>Adding new substructures</li> <li>How to build your model</li> <li>How each dataset works</li> </ul> <p>those topics and more will be covered in other guides down the line.</p>"},{"location":"getting_started/#installation","title":"Installation","text":"<p>Installing <code>WITCH</code> is very easy, simply clone the repository and run <code>pip install .</code> from the root of the repository. A pypi release is on the todo list so this will get even easier down the line.</p>"},{"location":"getting_started/#environment-setup","title":"Environment Setup","text":"<p>Warning</p> <p>There is some backwards compatibility for older file organization schemes in parts of <code>WITCH</code>, they wil not be covered here and are not reccomended going forward.</p> <p>Technically you can organize your files however you like and provide <code>WITCH</code> with absolute paths, but it is quite convenient to use the expected environment variables to do this instead. This is because it facilitates sharing configuration files across multiple users and compute resources far easier.</p> <p>First you need to decide two things: where your input data will live and where the outputs will be placed. It is often useful to place the input data in a directory that is readable by your collaborators and, if possible, backed up (ie: not scratch), you can always regenerate outputs but requiring the input data is potentially non-trivial.</p> <p>Once you decide these two things set the relevant environment variables like so:</p> <pre><code>export WITCH_DATROOT=WHERE_YOU_WANT_INPUTS\nexport WITCH_OUTROOT=WHERE_YOU_WANT_OUTPUTS\n</code></pre> <p>you most likely will want to place those lines in you <code>.bashrc</code> or equivalent (or in your job scripts on a cluster).</p> <p>Next you will want to place your input files in the correct place in <code>$WITCH_DATROOT</code>, technically the exact search path within is up to the dataset implementation but the recommended default is that the files for a given dataset live in: <code>$WITCH_DATROOT/DATA_ROOT/DATASET/</code>, where <code>DATA_ROOT</code> is a path specified in the configuration file by the <code>data</code> field in the <code>paths</code> section (example later on) and <code>DATASET</code> is the name of the dataset you are working with. The data files can be placed in that directory, with the structure within the directory being dictated by the specific dataset.</p> <p><code>WITCH</code> will handle building a path within your output directory for you and will print it out for convenience as needed, but you can customize some specifics by setting this <code>outroot</code> and <code>subdir</code> fields in the <code>paths</code> section of the configuration file. With those set you outputs will be found in a path along the lines of <code>$WITCH_OUTROOT/OUTROOT/NAME/MODEL_NAME/SUBDIR</code>, where <code>NAME</code> and <code>MODEL_NAME</code> are specified elsewhere in the configuration file and will be discussed in the next section.</p>"},{"location":"getting_started/#building-a-basic-configuration-file","title":"Building a Basic Configuration File","text":"<p>Info</p> <p>A full reference to the configuration file is under construction, here we just discuss what is needed for a simple setup.</p> <p>A key feature of the <code>WITCH</code> configuration file is that any configuration file may reference a <code>base</code> configuration. Any fields populated in the <code>base</code> configuration will be known when loading the actual configuration file and any fields included in both will be overwriten by the actual configuration. This can be done any number of times, so the <code>base</code> configuration can reference its own <code>base</code> configuration if you wish.</p> <p>This is useful for placing portions of the configuration that are largely static in a file that doesn't need to be changed and then referencing it in downstream files that modify various things for testing (ie: configurations for different modeling assumptions).</p> <p>Lets first build up a typical <code>base</code> configuration file, starting with some very basic information that we can can use as defaults for the downstream configurations:</p> <pre><code>name: \"RXJ1347\" # The name of the cluster/project\nfit: True # If True fit the cluster, overridden by command line\nsub: True # If True subtract the model in the posfit stage \nn_rounds: 4 # How many rounds of fitting to try\nsim: False # Set to True of we are running a simulation\n</code></pre> <p>Next lets add in the paths section, the important fields here were disused above:</p> <pre><code>paths:\n    data: \"RXJ1347\" # Usually we will want the data in a directory\n    outroot: \"\" # The default for this is an empty string\n    subdir: \"\" # Same here\n</code></pre> <p>The next two sections allow us to define things that can be referenced by the rest of the configuration. The variables defined in the <code>constants</code> section can be accessed via the <code>constants</code> dictionary in later fields, all of the constants are passed through <code>eval</code> so some basic math is possible. The <code>imports</code> section allows us to import modules that can be used elsewhere in the configuration file. The syntax equivalent to <code>import module.a as b</code> is <code>module.a: m</code> and <code>from module import a, b</code> is <code>module: [a, b]</code>. Below is an example of these two sections:</p> <pre><code>constants:\n  Te: 5.0\n  freq: \"90e9\"\n  z: 0.451\nimports:\n  astropy.units: u\n  astropy.coordinates: [Angle]\n  witch.external.minkasi.funcs: mf\n  jitkasi.noise: jn\n</code></pre> <p>The next section that is useful to include is the coordinate grid, all of the fields in the section are passed through <code>eval</code> so you can include some math if you wish. The coordinate grid is the set of points at which the model is evaluated. This is not the same as the map (if such a thing is relevant to your dataset). The model called anywhere outside the grid will evaluate to 0, so make sure the grid covers the model where there is significant power. Smaller grids have the advantage of better performance. <code>dr</code> sets the x/y grid size and should not be smaller than half the pixel size to avoid sub-pixel interpolation errors. <code>dz</code> is the line of sight spacing and only needs to be set small enough to avoid excess uncertainty in the numerical integration. <code>x0</code> and <code>y0</code> should be set to the center of the cluster (or other feature of interest) and defines the grid center, all model space references will be made with respect to this point. An example of this section with units annotated can be seen below:</p> <pre><code>coords:\n  r_map: \"3.0*60\" # Radial size of grid in arcseconds\n  dr: \"1.0\" # Pixel size of grid in x and y in arcseconds\n  dz: 1.0 # Pixel size along the LOS, if not provided dr is used\n  x0: \"(206.8776*u.degree).to(u.radian).value\" # RA of grid origin in radians\n  y0: \"(-11.7528*u.degree).to(u.radian).value\" # Dec of grid origin in radians\n</code></pre> <p>Two other sections commonly used desired in the <code>base</code> unit are those that control the settings for the Levenberg\u2013Marquardt fit and Hamiltonian Monte Carlo. The details of these two algorithms and how to tune them will be discussed in a later guide but the settings below encompass all options for both:</p> <pre><code># Setting for the Levenberg\u2013Marquardt fitter\nfitting:\n  maxiter: 10 # Maximum fit iterations per round of fitting\n  chitol: 1e-5 # Change in chisq that we consider to be converged\n# Settings for HMC\nmcmc:\n  run: True # If this is false the chain will not be run\n  num_steps: 1000 # The number of samples in the chain\n  num_leaps: 10 # The number of iterations of the leapfrog algorithm to run at each step\n  step_size: .02 # The step size to use in the chain\n  sample_which: -2 # Which parameters to sample, -2 will sample any parameters that we have tried to fit\n</code></pre> <p>to better understand what these fields are read the documentation for <code>fit_dataset</code> and <code>run_mcmc</code></p> <p>The final section that you will usually want in the <code>base</code> config is one that defines out datasets. This can be quite complicated and will vary depending on your dataset. This topic be covered extensively in its own guide so here we simply provide an annotated example:</p> <pre><code>datasets:\n  mustang2:\n    # These fields need to be set regardless of the dataset\n    # This can rely on the imports section\n    noise: # Noise to use while fitting\n      class: \"jn.NoiseSmoothedSVD\"\n      args: \"[]\"\n      kwargs: \"{'fwhm':10}\"\n    funcs: # Functions needed to interact with your dataset\n      # All of these need to exist and be importable\n      # If you don't have them in a library add the relevant file to your $PYTHONPATH\n      # Check docs for the needed signatures\n      get_files: \"mf.get_files\"\n      load_tods: \"mf.load_tods\"\n      get_info: \"mf.get_info\"\n      make_beam: \"mf.make_beam\"\n      preproc: \"mf.preproc\"\n      postproc: \"mf.postproc\"\n      postfit: \"mf.postfit\"\n    # The rest are user specified and will depend on your dataset\n    # These should only ever be needed in the function set in \"funcs\" above\n    # Since they are only called from the specified \"funcs\" make sure the scope\n    # of things referenced here is based on the module(s) that \"funcs\" is from.\n    minkasi_noise:\n      class: \"minkasi.mapmaking.noise.NoiseSmoothedSVD\" # Noise class to use\n      args: \"[]\" # Arguments to pass to apply_noise\n      kwargs: \"{'fwhm':10}\" # kwargs to pass to apply_noise\n    # Defines the beam\n    # All are passed through eval\n    # Note that these define a double gaussian\n    beam:\n      fwhm1: \"9.735\" # FWHM in arcseconds of the first gaussian\n      amp1: 0.9808 # Amplitude of the first gaussian\n      fwhm2: \"32.627\" # FWHM in arcseconds of the second gaussian\n      amp2: 0.0192 # Amplitude of the second gaussian\n    copy_noise: False # If true then fitting noise just wraps minkasi noise, may make this automatic later\n    dograd: False # If True then use gradient priors when mapmaking\n    npass: 1 # How many passes of mapmaking to run\n</code></pre> <p>Putting all of this together we have the following <code>base</code> configuration file:</p> <pre><code>name: \"RXJ1347\" # The name of the cluster/project\nfit: True # If True fit the cluster, overridden by command line\nsub: True # If True the cluster before mapmaking, overridden by command line\nn_rounds: 4 # How many rounds of fitting to try\nsim: False # Set to True of we are running a simulation\npaths:\n    data: \"RXJ1347\" # Usually we will want the data in a directory\n    outroot: \"\" # The default for this is an empty string\n    subdir: \"\" # Same here\nconstants:\n  Te: 5.0\n  freq: \"90e9\"\n  z: 0.451\nimports:\n  astropy.units: u\n  astropy.coordinates: [Angle]\n  witch.external.minkasi.funcs: mf\n  jitkasi.noise: jn\ncoords:\n  r_map: \"3.0*60\" # Radial size of grid in arcseconds\n  dr: \"1.0\" # Pixel size of grid in x and y in arcseconds\n  dz: 1.0 # Pixel size along the LOS, if not provided dr is used\n  x0: \"(206.8776*u.degree).to(u.radian).value\" # RA of grid origin in radians\n  y0: \"(-11.7528*u.degree).to(u.radian).value\" # Dec of grid origin in radians\n# Setting for the Levenberg\u2013Marquardt fitter\nfitting:\n  maxiter: 10 # Maximum fit iterations per round of fitting\n  chitol: 1e-5 # Change in chisq that we consider to be converged\n# Settings for HMC\nmcmc:\n  run: True # If this is false the chain will not be run\n  num_steps: 1000 # The number of samples in the chain\n  num_leaps: 10 # The number of iterations of the leapfrog algorithm to run at each step\n  step_size: .02 # The step size to use in the chain\n  sample_which: -2 # Which parameters to sample, -2 will sample any parameters that we have tried to fit\ndatasets:\n  mustang2:\n    # These fields need to be set regardless of the dataset\n    # This can rely on the imports section\n    noise: # Noise to use while fitting\n      class: \"jn.NoiseSmoothedSVD\"\n      args: \"[]\"\n      kwargs: \"{'fwhm':10}\"\n    funcs: # Functions needed to interact with your dataset\n      # All of these need to exist and be importable\n      # If you don't have them in a library add the relevant file to your $PYTHONPATH\n      # Check docs for the needed signatures\n      get_files: \"mf.get_files\"\n      load_tods: \"mf.load_tods\"\n      get_info: \"mf.get_info\"\n      make_beam: \"mf.make_beam\"\n      preproc: \"mf.preproc\"\n      postproc: \"mf.postproc\"\n      postfit: \"mf.postfit\"\n    # The rest are user specified and will depend on your dataset\n    # These should only ever be needed in the function set in \"funcs\" above\n    # Since they are only called from the specified \"funcs\" make sure the scope\n    # of things referenced here is based on the module(s) that \"funcs\" is from.\n    minkasi_noise:\n      class: \"minkasi.mapmaking.noise.NoiseSmoothedSVD\" # Noise class to use\n      args: \"[]\" # Arguments to pass to apply_noise\n      kwargs: \"{'fwhm':10}\" # kwargs to pass to apply_noise\n    # Defines the beam\n    # All are passed through eval\n    # Note that these define a double gaussian\n    beam:\n      fwhm1: \"9.735\" # FWHM in arcseconds of the first gaussian\n      amp1: 0.9808 # Amplitude of the first gaussian\n      fwhm2: \"32.627\" # FWHM in arcseconds of the second gaussian\n      amp2: 0.0192 # Amplitude of the second gaussian\n    copy_noise: False # If true then fitting noise just wraps minkasi noise, may make this automatic later\n    dograd: False # If True then use gradient priors when mapmaking\n    npass: 1 # How many passes of mapmaking to run\n</code></pre> <p>This can be saved to a file somewhere, for conveniences sake lets assume the file is called <code>base.yaml</code>. Now we are ready a write a downstream configuration file.</p> <p>The most important field here is <code>base</code> since this tells <code>WITCH</code> where to find the base configuration file. You can either provide an absolute path to the file or (often more conveniently) a path relative to the directory that your downstream configuration is in. In our example case here this field will simply be:</p> <pre><code>base: base.yaml\n</code></pre> <p>Now we can overwrite anything from <code>base.yaml</code> in this configuration if we wish.</p> <p>The main section you will usually want in each of your downstream configurations is one defining the model. The general layout of the model section is as follows:</p> <pre><code>model:\n    unit_conversion: ... # A prefactor to apply to go from compton y to whatever your data is\n    structures:\n        structure1:\n            structure: ... # The type of structure this is\n            parameters:\n                par1:\n                    value: ... # The value of the parameter, if we are fitting it this is where we start\n                    to_fit: ... # Whether or not to fit the parameter, this can be a single bool or a list with one value per round. False by default.\n                    priors: ... # A two element list [low, high] of the bounds on the parameter, this is optional\n                par2:\n                    ...\n        structure2:\n            ...\n</code></pre> <p>To know what parameters a specific structure takes see this documentation, note that the names of the parameters in the configuration file do not need to match the function parameters but the order must be correct.</p> <p>Below is an example model:</p> <pre><code>model:\n  unit_conversion: \"float(wu.get_da(constants['z'])*wu.y2K_RJ(constants['freq'], constants['Te'])*wu.XMpc/wu.me)\"\n  structures:\n    a10:\n      structure: \"a10\"\n      parameters:\n        dx_1:\n          value: 0.0\n          to_fit: [True, True, False, True]\n          priors: [-9.0, 9.0]\n        dy_1:\n          value: 0.0\n          to_fit: [True, True, False, True]\n          priors: [-9.0, 9.0]\n        dz_1:\n          value: 0.0\n        theta:\n          value: 0.0\n        P0:\n          value: 8.403\n        c500:\n          value: 1.177\n        m500:\n          value: \"1.5e15\"\n          to_fit: True\n        gamma:\n          value: .3081\n        alpha:\n          value: 1.551\n        beta:\n          value: 5.4905\n        z:\n          value: 0.97\n    ps_gauss:\n      structure: \"gaussian\"\n      parameters:\n        dx_g:\n          value: 0.0\n          to_fit: [True, True, False, True]\n          priors: [-9.0, 9.0]\n        dy_g:\n          value: 0.0\n          to_fit: [True, True, False, True]\n          priors: [-9.0, 9.0]\n        sigma:\n          value: 4\n        amp_g:\n          value: 0.002\n          to_fit: [True, False, True, True]\n</code></pre> <p>A complete guide to how to think about and construct models is planned for the future but it is worth briefly discussing the core ideas of how <code>WITCH</code> models things here. The model is constructed in several stages:</p> <ul> <li>Stage -1: adds non parametric models to the grid. This is an advanced feature and not recommended for beginners.</li> <li>Stage 0: add 3d parametric models to the grid. This is typically where you would add cluster profiles (ie: A10s, isobetas, etc.).</li> <li>Stage 1: modify the 3d grid. This is where substructure like bubbles and shocks are added.</li> <li>At this point the model is integrated along the line of sight, reducing it to 2d.</li> <li>Stage 2: add 2d models to the model. This is can be used to add profiles that don't need to interact with cluster substructure.</li> <li>At this point the model is convolved with the beam.</li> <li>Stage 3: add 2d models to the model that we didn't want to beam convolved. This is really only used for adding point sources.</li> </ul> <p>So lets say you wanted to model a merging cluster pair with a shock in the merger and a AGN in one, you would do this by adding two cluster profiles at Stage 0, adding the shock at Stage 1, and then adding the AGN at Stage 3.</p>"},{"location":"getting_started/#running-witch","title":"Running <code>WITCH</code>","text":"<p>Once you have your configuration file to run <code>WITCH</code> all you need to do is call the <code>witcher</code> command like so:</p> <pre><code>witcher PATH_TO_CONFIG.yaml\n</code></pre> <p>depending on your dataset the outputs will vary but the key things to look out for is the fit parameters after each round of fitting. For example below is the output from fitting a simple gaussian:</p> <pre><code>ps_gauss:\nRound 1 out of 1\n        ps_gauss:\n                dx_g* [-9.0, 9.0] = [-0.09016553] \u00b1 [0.12899712] ([0.69897324] \u03c3)\n                dy_g* [-9.0, 9.0] = [-0.14666429] \u00b1 [0.12809413] ([1.1449728] \u03c3)\n                sigma* [1.0, 10.0] = [4.03847427] \u00b1 [0.06408161] ([63.02080388] \u03c3)\n                amp_g [0.0, 0.005] = [0.002] \u00b1 [0.] ([inf] \u03c3)\nchisq is 3578656.971706165\n</code></pre> <p>After each round of fitting the model will be saved using <code>dill</code> and can be loaded with <code>Model.load</code>, the path to each file will be printed after each round. A <code>yaml</code> file with the fit model parameters will also be saved along side the <code>dill</code> file. In the case of HMC, the full sample chain will be saved as a <code>npz</code> file in the output directory. The output directory also contains a copy of the configuration file including all the fields from the <code>base</code> configuration.</p> <p>The path to the output directory can sometimes be cumbersome as it includes the names of all fit parameters, luckily the last thing printed by <code>witcher</code> is the path with all your outputs! Any dataset specific outputs (ie: residual maps) will be in subdirectories labeled with the dataset name.</p>"},{"location":"reference/SUMMARY/","title":"SUMMARY","text":"<ul> <li>containers</li> <li>core</li> <li>dataset</li> <li>external<ul> <li>act_map<ul> <li>funcs</li> </ul> </li> <li>minkasi<ul> <li>funcs</li> <li>mapmaking</li> <li>utils</li> </ul> </li> </ul> </li> <li>fitter</li> <li>fitting</li> <li>forward_modeling</li> <li>grid</li> <li>nonparametric</li> <li>objective</li> <li>plotting</li> <li>structure</li> <li>utils</li> </ul>"},{"location":"reference/containers/","title":"containers","text":"<p>Data classes for describing models in a structured way.</p>"},{"location":"reference/containers/#witch.containers.Model","title":"<code>Model</code>  <code>dataclass</code>","text":"<p>Dataclass to describe a model. This includes some caching features that improve performance when fitting. Note that because of the caching dynamically modifying what structures compose the model may not work as intended so beware.</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>str</code> <p>The name of the model. This is used for display purposes only.</p> <code>structures</code> <code>list[Structure]</code> <p>The structures that compose the model. Will be sorted to match <code>core.ORDER</code> once initialized.</p> <code>xyz</code> <code>tuple[Array, Array, Array, float, float]</code> <p>Defines the grid used by model computation. The first three elements are a sparse 3D grid in arcseconds, with the first two elements being RA and Dec respectively and the third element being the LOS. The last two elements are the model center in Ra and Dec (also in arcseconds). The structure functions use this as the coordinate to reference <code>dx</code> and <code>dy</code> to.</p> <code>dz</code> <code>float</code> <p>The LOS integration factor. Should minimally be the pixel size in arcseconds along the LOS, but can also include additional factors for performing unit conversions.</p> <code>beam</code> <code>Array</code> <p>The beam to convolve the model with.</p> <code>n_rounds</code> <code>int</code> <p>How many rounds of fitting to perform.</p> <code>cur_round</code> <code>int, default: 0</code> <p>Which round of fitting we are currently in, rounds are 0 indexed.</p> <code>chisq</code> <code>float, default: np.inf</code> <p>The chi-squared of this model relative to some data. Used when fitting.</p> <code>original_order</code> <code>list[int]</code> <p>The original order than the structures in <code>structures</code> were inputted.</p> Source code in <code>witch/containers.py</code> <pre><code>@register_pytree_node_class\n@dataclass\nclass Model:\n    \"\"\"\n    Dataclass to describe a model.\n    This includes some caching features that improve performance when fitting.\n    Note that because of the caching dynamically modifying what structures compose\n    the model may not work as intended so beware.\n\n    Attributes\n    ----------\n    name : str\n        The name of the model.\n        This is used for display purposes only.\n    structures : list[Structure]\n        The structures that compose the model.\n        Will be sorted to match `core.ORDER` once initialized.\n    xyz : tuple[jax.Array, jax.Array, jax.Array, float, float]\n        Defines the grid used by model computation.\n        The first three elements are a sparse 3D grid in arcseconds,\n        with the first two elements being RA and Dec respectively and the third\n        element being the LOS. The last two elements are the model center in Ra and Dec\n        (also in arcseconds). The structure functions use this as the coordinate to reference\n        `dx` and `dy` to.\n    dz : float\n        The LOS integration factor.\n        Should minimally be the pixel size in arcseconds along the LOS,\n        but can also include additional factors for performing unit conversions.\n    beam : jax.Array\n        The beam to convolve the model with.\n    n_rounds : int\n        How many rounds of fitting to perform.\n    cur_round : int, default: 0\n        Which round of fitting we are currently in,\n        rounds are 0 indexed.\n    chisq : float, default: np.inf\n        The chi-squared of this model relative to some data.\n        Used when fitting.\n    original_order : list[int]\n        The original order than the structures in `structures` were inputted.\n    \"\"\"\n\n    name: str\n    structures: list[Structure]\n    xyz: tuple[jax.Array, jax.Array, jax.Array, float, float]  # arcseconds\n    dz: float  # arcseconds * unknown\n    beam: jax.Array\n    n_rounds: int\n    cur_round: int = 0\n    chisq: jax.Array = field(\n        default_factory=jnp.array(jnp.inf).copy\n    )  # scalar float array\n    original_order: list[int] = field(init=False)\n\n    def __post_init__(self):\n        # Make sure the structure is in the order that core expects\n        structure_idx = np.argsort(\n            np.array(\n                [core.ORDER.index(structure.structure) for structure in self.structures]\n            )\n        )\n        self.structures = [self.structures[i] for i in structure_idx]\n        self.original_order = list(jnp.sort(structure_idx))\n\n    def __setattr__(self, name, value):\n        if name == \"cur_round\" or name == \"xyz\":\n            self.__dict__.pop(\"model_grad\", None)\n            self.__dict__.pop(\"model\", None)\n        if name == \"n_rounds\":\n            self.__dict__.pop(\"to_fit_ever\", None)\n        return super().__setattr__(name, value)\n\n    def __repr__(self) -&gt; str:\n        rep = self.name + \":\\n\"\n        rep += f\"Round {self.cur_round + 1} out of {self.n_rounds}\\n\"\n        for i in self.original_order:\n            struct = self.structures[i]\n            rep += \"\\t\" + struct.name + \":\\n\"\n            for par in struct.parameters:\n                rep += (\n                    \"\\t\\t\"\n                    + par.name\n                    + \"*\" * par.fit[self.cur_round]\n                    + \" [\"\n                    + str(par.prior[0])\n                    + \", \"\n                    + str(par.prior[1])\n                    + \"]\"\n                    + \" = \"\n                    + str(par.val)\n                    + \" \u00b1 \"\n                    + str(par.err)\n                    + \" (\"\n                    + str(jnp.abs(par.val / par.err))\n                    + \" \u03c3)\"\n                    + \"\\n\"\n                )\n        rep += f\"chisq is {self.chisq}\"\n        return rep\n\n    @cached_property\n    def n_struct(self) -&gt; list[int]:\n        \"\"\"\n        Number of each type of structures in the model.\n        Note that this is cached.\n\n        Returns\n        -------\n        n_struct : list[int]\n            `n_struct[i]` is the number of `core.ORDER[i]`\n            structures in this model.\n        \"\"\"\n        n_struct = [0] * len(core.ORDER)\n        for structure in self.structures:\n            idx = core.ORDER.index(structure.structure)\n            n_struct[idx] += 1\n        return n_struct\n\n    @cached_property\n    def n_rbins(self) -&gt; list[int]:\n        \"\"\"\n        Number of r bins for nonparametric structures.\n        Note that this is cached.\n\n        Returns\n        -------\n        n_rbins : list[int]\n            `n_rbins[i]` is the number of rbins in this structure.\n        \"\"\"\n        n_rbins = [structure.n_rbins for structure in self.structures]\n\n        return n_rbins\n\n    @property\n    def pars(self) -&gt; jax.Array:\n        \"\"\"\n        Get the current parameter values.\n\n        Returns\n        -------\n        pars :  jax.Array\n            The parameter values in the order expected by `core.model`.\n        \"\"\"\n        pars = jnp.array([])\n        for structure in self.structures:\n            for parameter in structure.parameters:\n                pars = jnp.append(pars, parameter.val.ravel())\n        return jnp.array(pars)\n\n    @cached_property\n    def par_names(self) -&gt; list[str]:\n        \"\"\"\n        Get the names of all parameters.\n        Note that this is cached.\n\n        Returns\n        -------\n        par_names : list[str]\n            Parameter names in the same order as `pars`.\n        \"\"\"\n        par_names = []\n        for structure in self.structures:\n            for parameter in structure.parameters:\n                if len(parameter.val) &gt; 1:\n                    for i in range(len(parameter.val)):\n                        par_names += [parameter.name + \"_{}\".format(i)]\n                else:\n                    par_names += [parameter.name]\n\n        return par_names\n\n    @property\n    def errs(self) -&gt; jax.Array:\n        \"\"\"\n        Get the current parameter errors.\n\n        Returns\n        -------\n        errs : jax.Array\n            The errors in the same order as vals.\n        \"\"\"\n        errs = jnp.array([])\n        for structure in self.structures:\n            for parameter in structure.parameters:\n                errs = jnp.append(errs, parameter.err.ravel())\n        return jnp.array(errs)\n\n    @cached_property\n    def priors(self) -&gt; tuple[jax.Array, jax.Array]:\n        \"\"\"\n        Get the priors for all parameters.\n        Note that this is cached.\n\n        Returns\n        -------\n        priors : tuple[jax.Array, jax.Array]\n            Parameter priors in the same order as `pars`.\n            This is a tuple with the first element being an array\n            of lower bounds and the second being upper.\n        \"\"\"\n        lower = []\n        upper = []\n        for structure in self.structures:\n            for parameter in structure.parameters:\n                lower += [parameter.prior[0]] * len(parameter.val)\n                upper += [parameter.prior[1]] * len(parameter.val)\n        priors = (jnp.array(lower), jnp.array(upper))\n        return priors\n\n    @property\n    def to_fit(self) -&gt; tuple[bool]:  # jax.Array:\n        \"\"\"\n        Get which parameters we want to fit for the current round.\n\n        Returns\n        -------\n        to_fit : jax.Array\n            `to_fit[i]` is True if we want to fit the `i`'th parameter\n            in the current round.\n            This is in the same order as `pars`.\n        \"\"\"\n\n        to_fit = []\n        for structure in self.structures:\n            for parameter in structure.parameters:\n                to_fit += [parameter.fit[self.cur_round]] * len(parameter.val)\n                # to_fit = jnp.append(to_fit, jnp.array([parameter.fit[self.cur_round]] * len(parameter.val)).ravel())\n\n        return tuple(to_fit)  # jnp.ravel(jnp.array(to_fit))\n\n    @cached_property\n    def to_fit_ever(self) -&gt; jax.Array:\n        \"\"\"\n        Check which parameters we ever fit.\n        Note that this is cached.\n\n        Returns\n        -------\n        to_fit_ever : jax.Array\n            `to_fit[i]` is True if we ever want to fit the `i`'th parameter.\n            This is in the same order as `pars`.\n        \"\"\"\n        to_fit = jnp.array([], dtype=bool)\n        for structure in self.structures:\n            for parameter in structure.parameters:\n                to_fit = jnp.append(\n                    to_fit,\n                    jnp.array(\n                        [parameter.fit_ever] * len(parameter.val), dtype=bool\n                    ).ravel(),\n                )\n\n        return jnp.ravel(jnp.array(to_fit))\n\n    @cached_property\n    def model(self) -&gt; jax.Array:\n        \"\"\"\n        The evaluated model, see `core.model` for details.\n        Note that this is cached, but is automatically reset whenever\n        `update` is called or `cur_round` or `xyz` changes.\n\n        Returns\n        -------\n        model : jax.Array\n            The model evaluted on `xyz` with the current values of `pars`.\n        \"\"\"\n        return core.model(\n            self.xyz,\n            tuple(self.n_struct),\n            tuple(self.n_rbins),\n            self.dz,\n            self.beam,\n            *self.pars,\n        )\n\n    @cached_property\n    def model_grad(self) -&gt; tuple[jax.Array, jax.Array]:\n        \"\"\"\n        The evaluated model and its gradient, see `core.model_grad` for details.\n        Note that this is cached, but is automatically reset whenever\n        `update` is called or `cur_round` changes.\n\n        Returns\n        -------\n        model : jax.Array\n            The model evaluted on `xyz` with the current values of `pars`.\n        grad : jax.Array\n            The gradient evaluted on `xyz` with the current values of `pars`.\n            Has shape `(len(pars),) + model.shape`.\n        \"\"\"\n        argnums = tuple(np.where(self.to_fit)[0] + core.ARGNUM_SHIFT)\n        return core.model_grad(\n            self.xyz,\n            tuple(self.n_struct),\n            tuple(self.n_rbins),\n            self.dz,\n            self.beam,\n            argnums,\n            *self.pars,\n        )\n\n    def to_tod(self, dx: ArrayLike, dy: ArrayLike) -&gt; jax.Array:\n        \"\"\"\n        Project the model into a TOD.\n\n        Parameters\n        ----------\n        dx : ArrayLike\n            The RA TOD in arcseconds.\n        dy : ArrayLike\n            The Dec TOD in arcseconds.\n\n        Returns\n        -------\n        tod : jax.Array\n            The model as a TOD.\n            Same shape as dx.\n        \"\"\"\n        tod = wu.bilinear_interp(\n            dx, dy, self.xyz[0].ravel(), self.xyz[1].ravel(), self.model\n        )\n        tod = tod - jnp.mean(tod, axis=-1)[..., None]\n        return tod\n\n    def to_tod_grad(self, dx: ArrayLike, dy: ArrayLike) -&gt; tuple[jax.Array, jax.Array]:\n        \"\"\"\n        Project the model and gradient into a TOD.\n\n        Parameters\n        ----------\n        dx : ArrayLike\n            The RA TOD in arcseconds.\n        dy : ArrayLike\n            The Dec TOD in arcseconds.\n\n        Returns\n        -------\n        tod : jax.Array\n            The model as a TOD.\n            Same shape as dx.\n        grad_tod : jax.Array\n            The gradient as a TOD.\n            Has shape `(len(pars),) + dx.shape`.\n        \"\"\"\n        model, grad = self.model_grad\n        tod = wu.bilinear_interp(\n            dx, dy, self.xyz[0].ravel(), self.xyz[1].ravel(), model\n        )\n        tod = tod - jnp.mean(tod, axis=-1)[..., None]\n        grad_tod = jnp.array(\n            [\n                (\n                    wu.bilinear_interp(\n                        dx, dy, self.xyz[0].ravel(), self.xyz[1].ravel(), _grad\n                    )\n                    if _fit\n                    else jnp.zeros_like(tod)\n                )\n                for _grad, _fit in zip(grad, self.to_fit)\n            ]\n        )\n\n        return tod, grad_tod\n\n    def to_map(self, x: jax.Array, y: jax.Array) -&gt; jax.Array:\n        \"\"\"\n        Project the model into a map.\n\n        Parameters\n        ----------\n        x : jax.Array\n            The RA of the map at each pixel.\n        y : jax.Array\n            Th Dec of the map at each pixel.\n\n        Returns\n        -------\n        omap : jax.Array\n            The model projected onto a map.\n            Same shape as x.\n        \"\"\"\n        omap = wu.bilinear_interp(\n            x.ravel(), y.ravel(), self.xyz[0].ravel(), self.xyz[1].ravel(), self.model\n        ).reshape(x.shape)\n        omap = omap - jnp.mean(omap)\n        return omap\n\n    def to_map_grad(self, x: jax.Array, y: jax.Array) -&gt; tuple[jax.Array, jax.Array]:\n        \"\"\"\n        Project the model into a map.\n\n        Parameters\n        ----------\n        x : jax.Array\n            The RA of the map at each pixel.\n        y : jax.Array\n            Th Dec of the map at each pixel.\n\n        Returns\n        -------\n        omap : jax.Array\n            The model projected onto a map.\n            Same shape as x.\n        grad_map : jax.Array\n            The gradient of each parameter projected onto a map.\n            Has shape `(npar,) + x.shape`.\n        \"\"\"\n        model, grad = self.model_grad\n        omap = wu.bilinear_interp(\n            x.ravel(), y.ravel(), self.xyz[0].ravel(), self.xyz[1].ravel(), model\n        ).reshape(x.shape)\n        omap = omap - jnp.mean(omap)\n        grad_map = jnp.array(\n            [\n                (\n                    wu.bilinear_interp(\n                        x.ravel(),\n                        y.ravel(),\n                        self.xyz[0].ravel(),\n                        self.xyz[1].ravel(),\n                        _grad,\n                    ).reshape(x.shape)\n                    if _fit\n                    else jnp.zeros_like(omap)\n                )\n                for _grad, _fit in zip(grad, self.to_fit)\n            ]\n        )\n        return omap, grad_map\n\n    def update(self, vals: jax.Array, errs: jax.Array, chisq: jax.Array) -&gt; Self:\n        \"\"\"\n        Update the parameter values and errors as well as the model chi-squared.\n        This also resets the cache on `model` and `model_grad`\n        if `vals` is different than `self.pars`.\n\n        Parameters\n        ----------\n        vals : jax.Array\n            The new parameter values.\n            Should be in the same order as `pars`.\n        errs : jax.Array\n            The new parameter errors.\n            Should be in the same order as `pars`.\n        chisq : jax.Array\n            The new chi-squared.\n            Should be a scalar float array.\n\n        Returns\n        -------\n        updated : Model\n            The updated model.\n            While nominally the model will update in place, returning it\n            alows us to use this function in JITed functions.\n        \"\"\"\n        if not np.array_equal(self.pars, vals):\n            self.__dict__.pop(\"model\", None)\n            self.__dict__.pop(\"model_grad\", None)\n        n = 0\n        for struct in self.structures:\n            for par in struct.parameters:\n                for i in range(len(par.val)):\n                    par.val = par.val.at[i].set(vals[n])\n                    par.err = par.err.at[i].set(errs[n])\n                    n += 1\n        self.chisq = chisq\n\n        return self\n\n    def add_round(self, to_fit) -&gt; Self:\n        \"\"\"\n        Add an additional round to the model.\n\n        Parameters\n        ----------\n        to_fit : jax.Array\n            Boolean array denoting which parameters to fit this round.\n            Should be in the same order as `pars`.\n\n        Returns\n        -------\n        updated : Model\n            The updated model with the new round.\n            While nominally the model will update in place, returning it\n            alows us to use this function in JITed functions.\n        \"\"\"\n        self.n_rounds = self.n_rounds + 1\n        self.cur_round = self.cur_round + 1\n        n = 0\n        for struct in self.structures:\n            for par in struct.parameters:\n                par.fit = par.fit + tuple((to_fit[n].item(),))\n                n += 1\n        return self\n\n    def remove_struct(self, struct_name: str):\n        \"\"\"\n        Remove structure by name.\n\n        Parameters\n        ----------\n        struct_name : str\n            Name of struct to be removed.\n        \"\"\"\n        n = None\n        for i, structure in enumerate(self.structures):\n            if str(structure.name) == str(struct_name):\n                n = i\n        if type(n) == int:\n            self.structures.pop(n)\n        else:\n            raise ValueError(\"Error: {} not in structure names\".format(struct_name))\n\n        to_pop = [\"to_fit_ever\", \"n_struct\", \"priors\", \"par_names\"]\n        for key in self.__dict__.keys():\n            if key in to_pop:  # Pop keys if they are in dict\n                self.__dict__.pop(key)\n\n        self.__dict__.pop(\"model\", None)\n        self.__dict__.pop(\"model_grad\", None)\n        self.__post_init__()\n\n    def para_to_non_para(\n        self,\n        n_rounds: Optional[int] = None,\n        to_copy: list[str] = [\"gnfw\", \"gnfw_rs\", \"a10\", \"isobeta\", \"uniform\"],\n    ) -&gt; Self:\n        \"\"\"\n        Function which approximately converts cluster profiles into a non-parametric form. Note this is\n        only approximate and should be fit afterwords.\n\n        Parameters\n        ----------\n        n_rounds: Optional int | None, default: None\n            Number of rounds to fit for output model. If none, copy from self\n        to_copy : list[str], default: gnfw, gnfw_rs, a10, isobeta, uniform\n            List of structures, by name, to copy.\n        Returns\n        -------\n        Model : Model\n            Model with a non-parametric representation of input model\n        Raises\n        ------\n        ValueError\n            If there are no models to copy\n        \"\"\"\n        cur_model = deepcopy(\n            self\n        )  # Make a copy of model, we don't want to lose structures\n        i = 0  # Make sure we keep at least one struct\n        for structure in cur_model.structures:\n            if structure.structure not in to_copy:\n                cur_model.remove_struct(structure.name)\n            else:\n                i += 1\n        if i == 0:\n            raise ValueError(\"Error: no model structures in {}\".format(to_copy))\n        params = jnp.array(cur_model.pars)\n        params = jnp.ravel(params)\n        pressure, _ = core.model3D(\n            cur_model.xyz, tuple(cur_model.n_struct), tuple(cur_model.n_rbins), params\n        )\n        pressure = pressure[\n            ..., int(pressure.shape[2] / 2)\n        ]  # Take middle slice. Close enough is good enough here, dont care about rounding\n\n        pixsize = np.abs(cur_model.xyz[1][0][1] - cur_model.xyz[1][0][0])\n\n        rs, bin1d, var1d = wu.bin_map(pressure, pixsize)\n\n        rbins = nonparametric.get_rbins(cur_model)\n        rbins = np.append(rbins, np.array([np.amax(rs)]))\n\n        condlist = [\n            np.array((rbins[i] &lt;= rs) &amp; (rs &lt; rbins[i + 1]))\n            for i in range(len(rbins) - 2, -1, -1)\n        ]\n\n        amps, pows, c = nonparametric.profile_to_broken_power(\n            rs, bin1d, condlist, rbins\n        )\n\n        priors = (-1 * np.inf, np.inf)\n        if n_rounds is None:\n            n_rounds = self.n_rounds\n        parameters = [\n            Parameter(\n                \"rbins\",\n                tuple([False] * n_rounds),\n                jnp.atleast_1d(jnp.array(rbins[:-1], dtype=float)),  # Drop last bin\n                jnp.zeros_like(jnp.atleast_1d(jnp.array(rbins[:-1])), dtype=float),\n                jnp.array(priors, dtype=float),\n            ),\n            Parameter(\n                \"amps\",\n                tuple([True] * n_rounds),\n                jnp.atleast_1d(jnp.array(amps, dtype=float)),\n                jnp.zeros_like(jnp.atleast_1d(jnp.array(amps)), dtype=float),\n                jnp.array(priors, dtype=float),\n            ),\n            Parameter(\n                \"pows\",\n                tuple([True] * n_rounds),\n                jnp.atleast_1d(jnp.array(pows, dtype=float)),\n                jnp.zeros_like(jnp.atleast_1d(jnp.array(pows)), dtype=float),\n                jnp.array(priors, dtype=float),\n            ),\n            Parameter(\n                \"dx\",  # TODO: miscentering\n                tuple([False] * n_rounds),\n                jnp.atleast_1d(jnp.array(0, dtype=float)),\n                jnp.zeros_like(jnp.atleast_1d(jnp.array(0)), dtype=float),\n                jnp.array(priors, dtype=float),\n            ),\n            Parameter(\n                \"dy\",  # TODO: miscentering\n                tuple([False] * n_rounds),\n                jnp.atleast_1d(jnp.array(0, dtype=float)),\n                jnp.zeros_like(jnp.atleast_1d(jnp.array(0)), dtype=float),\n                jnp.array(priors, dtype=float),\n            ),\n            Parameter(\n                \"dz\",  # TODO: miscentering\n                tuple([False] * n_rounds),\n                jnp.atleast_1d(jnp.array(0, dtype=float)),\n                jnp.zeros_like(jnp.atleast_1d(jnp.array(0)), dtype=float),\n                jnp.array(priors, dtype=float),\n            ),\n            Parameter(\n                \"c\",\n                tuple([True] * n_rounds),\n                jnp.atleast_1d(jnp.array(c, dtype=float)),\n                jnp.zeros_like(jnp.atleast_1d(jnp.array(0)), dtype=float),\n                jnp.array(priors, dtype=float),\n            ),\n        ]\n\n        structures = [\n            Structure(\n                \"nonpara_power\", \"nonpara_power\", parameters, n_rbins=len(rbins) - 1\n            )\n        ]\n        for structure in self.structures:\n            if structure.name not in to_copy:\n                structures.append(structure)\n\n        return Model(\n            name=\"test\",\n            structures=structures,\n            xyz=self.xyz,\n            dz=self.dz,\n            beam=self.beam,\n            n_rounds=n_rounds,\n            cur_round=0,\n        )\n\n    def save(self, path: str):\n        \"\"\"\n        Serialize the model to a file with dill.\n\n        Parameters\n        ----------\n        path : str\n            The file to save to.\n            Does not check to see if the path is valid.\n        \"\"\"\n        with open(path, \"wb\") as f:\n            dill.dump(self, f)\n\n    @classmethod\n    def load(cls, path: str) -&gt; Self:\n        \"\"\"\n        Load the model from a file with dill.\n\n        Parameters\n        ----------\n        path : str\n            The path to the saved model.\n            Does not check to see if the path is valid.\n\n        Returns\n        -------\n        model : Model\n            The loaded model.\n        \"\"\"\n        with open(path, \"rb\") as f:\n            return dill.load(f)\n\n    @classmethod\n    def from_cfg(cls, cfg: dict, beam: Optional[jax.Array] = None) -&gt; Self:\n        \"\"\"\n        Create an instance of model from a witcher config.\n\n        Parameters\n        ----------\n        cfg : dict\n            The config loaded into a dict.\n        beam : Optional[Array], default: None\n\n        Returns\n        -------\n        model : Model\n            The model described by the config.\n        \"\"\"\n        # Do imports\n        for module, name in cfg.get(\"imports\", {}).items():\n            mod = import_module(module)\n            if isinstance(name, str):\n                locals()[name] = mod\n            elif isinstance(name, list):\n                for n in name:\n                    locals()[n] = getattr(mod, n)\n            else:\n                raise TypeError(\"Expect import name to be a string or a list\")\n\n        # Load constants\n        constants = {\n            name: eval(str(const)) for name, const in cfg.get(\"constants\", {}).items()\n        }  # pyright: ignore [reportUnusedVariable]\n\n        # Get jax device\n        dev_id = cfg.get(\"jax_device\", 0)\n        device = jax.devices()[dev_id]\n\n        # Setup coordindate stuff\n        r_map = eval(str(cfg[\"coords\"][\"r_map\"]))\n        dr = eval(str(cfg[\"coords\"][\"dr\"]))\n        dz = eval(str(cfg[\"coords\"].get(\"dz\", dr)))\n        x0 = eval(str(cfg[\"coords\"][\"x0\"]))\n        y0 = eval(str(cfg[\"coords\"][\"y0\"]))\n\n        xyz_host = wg.make_grid(\n            r_map, dr, dr, dz, x0 * wg.rad_to_arcsec, y0 * wg.rad_to_arcsec\n        )\n        xyz = jax.device_put(xyz_host, device)\n        xyz[0].block_until_ready()\n        xyz[1].block_until_ready()\n        xyz[2].block_until_ready()\n\n        # Make beam\n        if beam is None:\n            beam = jnp.ones((1, 1))\n        beam = jax.device_put(beam, device)\n        if beam is None:\n            raise ValueError(\"Beam somehow still None!\")\n\n        n_rounds = cfg.get(\"n_rounds\", 1)\n        dz = dz * eval(str(cfg[\"model\"][\"unit_conversion\"]))\n\n        structures = []\n        for name, structure in cfg[\"model\"][\"structures\"].items():\n            n_rbins = structure.get(\"n_rbins\", 0)\n            parameters = []\n            for par_name, param in structure[\"parameters\"].items():\n                val = eval(str(param[\"value\"]))\n                fit = param.get(\"to_fit\", [False] * n_rounds)\n                if isinstance(fit, bool):\n                    fit = [fit] * n_rounds\n                if len(fit) != n_rounds:\n                    raise ValueError(\n                        f\"to_fit has {len(fit)} entries but we only have {n_rounds} rounds\"\n                    )\n                priors = param.get(\"priors\", None)\n                if priors is not None:\n                    priors = eval(str(priors))\n                else:\n                    priors = (-1 * np.inf, np.inf)\n                parameters.append(\n                    Parameter(\n                        par_name,\n                        tuple(fit),\n                        jnp.atleast_1d(jnp.array(val, dtype=float)),\n                        jnp.zeros_like(jnp.atleast_1d(jnp.array(val)), dtype=float),\n                        jnp.array(priors, dtype=float),\n                    )\n                )\n            structures.append(\n                Structure(name, structure[\"structure\"], parameters, n_rbins=n_rbins)\n            )\n        name = cfg[\"model\"].get(\n            \"name\", \"-\".join([structure.name for structure in structures])\n        )\n\n        return cls(name, structures, xyz, dz, beam, n_rounds)\n\n    # Functions for making this a pytree\n    # Don't call this on your own\n    def tree_flatten(self) -&gt; tuple[tuple, tuple]:\n        children = (tuple(self.structures), self.xyz, self.dz, self.beam, self.chisq)\n        aux_data = (\n            self.name,\n            self.n_rounds,\n            self.cur_round,\n        )\n\n        return (children, aux_data)\n\n    @classmethod\n    def tree_unflatten(cls, aux_data, children) -&gt; Self:\n        name, n_rounds, cur_round = aux_data\n        structures, xyz, dz, beam, chisq = children\n\n        return cls(name, list(structures), xyz, dz, beam, n_rounds, cur_round, chisq)\n</code></pre>"},{"location":"reference/containers/#witch.containers.Model.errs","title":"<code>errs</code>  <code>property</code>","text":"<p>Get the current parameter errors.</p> <p>Returns:</p> Name Type Description <code>errs</code> <code>Array</code> <p>The errors in the same order as vals.</p>"},{"location":"reference/containers/#witch.containers.Model.model","title":"<code>model</code>  <code>cached</code> <code>property</code>","text":"<p>The evaluated model, see <code>core.model</code> for details. Note that this is cached, but is automatically reset whenever <code>update</code> is called or <code>cur_round</code> or <code>xyz</code> changes.</p> <p>Returns:</p> Name Type Description <code>model</code> <code>Array</code> <p>The model evaluted on <code>xyz</code> with the current values of <code>pars</code>.</p>"},{"location":"reference/containers/#witch.containers.Model.model_grad","title":"<code>model_grad</code>  <code>cached</code> <code>property</code>","text":"<p>The evaluated model and its gradient, see <code>core.model_grad</code> for details. Note that this is cached, but is automatically reset whenever <code>update</code> is called or <code>cur_round</code> changes.</p> <p>Returns:</p> Name Type Description <code>model</code> <code>Array</code> <p>The model evaluted on <code>xyz</code> with the current values of <code>pars</code>.</p> <code>grad</code> <code>Array</code> <p>The gradient evaluted on <code>xyz</code> with the current values of <code>pars</code>. Has shape <code>(len(pars),) + model.shape</code>.</p>"},{"location":"reference/containers/#witch.containers.Model.n_rbins","title":"<code>n_rbins</code>  <code>cached</code> <code>property</code>","text":"<p>Number of r bins for nonparametric structures. Note that this is cached.</p> <p>Returns:</p> Name Type Description <code>n_rbins</code> <code>list[int]</code> <p><code>n_rbins[i]</code> is the number of rbins in this structure.</p>"},{"location":"reference/containers/#witch.containers.Model.n_struct","title":"<code>n_struct</code>  <code>cached</code> <code>property</code>","text":"<p>Number of each type of structures in the model. Note that this is cached.</p> <p>Returns:</p> Name Type Description <code>n_struct</code> <code>list[int]</code> <p><code>n_struct[i]</code> is the number of <code>core.ORDER[i]</code> structures in this model.</p>"},{"location":"reference/containers/#witch.containers.Model.par_names","title":"<code>par_names</code>  <code>cached</code> <code>property</code>","text":"<p>Get the names of all parameters. Note that this is cached.</p> <p>Returns:</p> Name Type Description <code>par_names</code> <code>list[str]</code> <p>Parameter names in the same order as <code>pars</code>.</p>"},{"location":"reference/containers/#witch.containers.Model.pars","title":"<code>pars</code>  <code>property</code>","text":"<p>Get the current parameter values.</p> <p>Returns:</p> Name Type Description <code>pars</code> <code>Array</code> <p>The parameter values in the order expected by <code>core.model</code>.</p>"},{"location":"reference/containers/#witch.containers.Model.priors","title":"<code>priors</code>  <code>cached</code> <code>property</code>","text":"<p>Get the priors for all parameters. Note that this is cached.</p> <p>Returns:</p> Name Type Description <code>priors</code> <code>tuple[Array, Array]</code> <p>Parameter priors in the same order as <code>pars</code>. This is a tuple with the first element being an array of lower bounds and the second being upper.</p>"},{"location":"reference/containers/#witch.containers.Model.to_fit","title":"<code>to_fit</code>  <code>property</code>","text":"<p>Get which parameters we want to fit for the current round.</p> <p>Returns:</p> Name Type Description <code>to_fit</code> <code>Array</code> <p><code>to_fit[i]</code> is True if we want to fit the <code>i</code>'th parameter in the current round. This is in the same order as <code>pars</code>.</p>"},{"location":"reference/containers/#witch.containers.Model.to_fit_ever","title":"<code>to_fit_ever</code>  <code>cached</code> <code>property</code>","text":"<p>Check which parameters we ever fit. Note that this is cached.</p> <p>Returns:</p> Name Type Description <code>to_fit_ever</code> <code>Array</code> <p><code>to_fit[i]</code> is True if we ever want to fit the <code>i</code>'th parameter. This is in the same order as <code>pars</code>.</p>"},{"location":"reference/containers/#witch.containers.Model.add_round","title":"<code>add_round(to_fit)</code>","text":"<p>Add an additional round to the model.</p> <p>Parameters:</p> Name Type Description Default <code>to_fit</code> <code>Array</code> <p>Boolean array denoting which parameters to fit this round. Should be in the same order as <code>pars</code>.</p> required <p>Returns:</p> Name Type Description <code>updated</code> <code>Model</code> <p>The updated model with the new round. While nominally the model will update in place, returning it alows us to use this function in JITed functions.</p> Source code in <code>witch/containers.py</code> <pre><code>def add_round(self, to_fit) -&gt; Self:\n    \"\"\"\n    Add an additional round to the model.\n\n    Parameters\n    ----------\n    to_fit : jax.Array\n        Boolean array denoting which parameters to fit this round.\n        Should be in the same order as `pars`.\n\n    Returns\n    -------\n    updated : Model\n        The updated model with the new round.\n        While nominally the model will update in place, returning it\n        alows us to use this function in JITed functions.\n    \"\"\"\n    self.n_rounds = self.n_rounds + 1\n    self.cur_round = self.cur_round + 1\n    n = 0\n    for struct in self.structures:\n        for par in struct.parameters:\n            par.fit = par.fit + tuple((to_fit[n].item(),))\n            n += 1\n    return self\n</code></pre>"},{"location":"reference/containers/#witch.containers.Model.from_cfg","title":"<code>from_cfg(cfg, beam=None)</code>  <code>classmethod</code>","text":"<p>Create an instance of model from a witcher config.</p> <p>Parameters:</p> Name Type Description Default <code>cfg</code> <code>dict</code> <p>The config loaded into a dict.</p> required <code>beam</code> <code>Optional[Array]</code> <code>None</code> <p>Returns:</p> Name Type Description <code>model</code> <code>Model</code> <p>The model described by the config.</p> Source code in <code>witch/containers.py</code> <pre><code>@classmethod\ndef from_cfg(cls, cfg: dict, beam: Optional[jax.Array] = None) -&gt; Self:\n    \"\"\"\n    Create an instance of model from a witcher config.\n\n    Parameters\n    ----------\n    cfg : dict\n        The config loaded into a dict.\n    beam : Optional[Array], default: None\n\n    Returns\n    -------\n    model : Model\n        The model described by the config.\n    \"\"\"\n    # Do imports\n    for module, name in cfg.get(\"imports\", {}).items():\n        mod = import_module(module)\n        if isinstance(name, str):\n            locals()[name] = mod\n        elif isinstance(name, list):\n            for n in name:\n                locals()[n] = getattr(mod, n)\n        else:\n            raise TypeError(\"Expect import name to be a string or a list\")\n\n    # Load constants\n    constants = {\n        name: eval(str(const)) for name, const in cfg.get(\"constants\", {}).items()\n    }  # pyright: ignore [reportUnusedVariable]\n\n    # Get jax device\n    dev_id = cfg.get(\"jax_device\", 0)\n    device = jax.devices()[dev_id]\n\n    # Setup coordindate stuff\n    r_map = eval(str(cfg[\"coords\"][\"r_map\"]))\n    dr = eval(str(cfg[\"coords\"][\"dr\"]))\n    dz = eval(str(cfg[\"coords\"].get(\"dz\", dr)))\n    x0 = eval(str(cfg[\"coords\"][\"x0\"]))\n    y0 = eval(str(cfg[\"coords\"][\"y0\"]))\n\n    xyz_host = wg.make_grid(\n        r_map, dr, dr, dz, x0 * wg.rad_to_arcsec, y0 * wg.rad_to_arcsec\n    )\n    xyz = jax.device_put(xyz_host, device)\n    xyz[0].block_until_ready()\n    xyz[1].block_until_ready()\n    xyz[2].block_until_ready()\n\n    # Make beam\n    if beam is None:\n        beam = jnp.ones((1, 1))\n    beam = jax.device_put(beam, device)\n    if beam is None:\n        raise ValueError(\"Beam somehow still None!\")\n\n    n_rounds = cfg.get(\"n_rounds\", 1)\n    dz = dz * eval(str(cfg[\"model\"][\"unit_conversion\"]))\n\n    structures = []\n    for name, structure in cfg[\"model\"][\"structures\"].items():\n        n_rbins = structure.get(\"n_rbins\", 0)\n        parameters = []\n        for par_name, param in structure[\"parameters\"].items():\n            val = eval(str(param[\"value\"]))\n            fit = param.get(\"to_fit\", [False] * n_rounds)\n            if isinstance(fit, bool):\n                fit = [fit] * n_rounds\n            if len(fit) != n_rounds:\n                raise ValueError(\n                    f\"to_fit has {len(fit)} entries but we only have {n_rounds} rounds\"\n                )\n            priors = param.get(\"priors\", None)\n            if priors is not None:\n                priors = eval(str(priors))\n            else:\n                priors = (-1 * np.inf, np.inf)\n            parameters.append(\n                Parameter(\n                    par_name,\n                    tuple(fit),\n                    jnp.atleast_1d(jnp.array(val, dtype=float)),\n                    jnp.zeros_like(jnp.atleast_1d(jnp.array(val)), dtype=float),\n                    jnp.array(priors, dtype=float),\n                )\n            )\n        structures.append(\n            Structure(name, structure[\"structure\"], parameters, n_rbins=n_rbins)\n        )\n    name = cfg[\"model\"].get(\n        \"name\", \"-\".join([structure.name for structure in structures])\n    )\n\n    return cls(name, structures, xyz, dz, beam, n_rounds)\n</code></pre>"},{"location":"reference/containers/#witch.containers.Model.load","title":"<code>load(path)</code>  <code>classmethod</code>","text":"<p>Load the model from a file with dill.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>The path to the saved model. Does not check to see if the path is valid.</p> required <p>Returns:</p> Name Type Description <code>model</code> <code>Model</code> <p>The loaded model.</p> Source code in <code>witch/containers.py</code> <pre><code>@classmethod\ndef load(cls, path: str) -&gt; Self:\n    \"\"\"\n    Load the model from a file with dill.\n\n    Parameters\n    ----------\n    path : str\n        The path to the saved model.\n        Does not check to see if the path is valid.\n\n    Returns\n    -------\n    model : Model\n        The loaded model.\n    \"\"\"\n    with open(path, \"rb\") as f:\n        return dill.load(f)\n</code></pre>"},{"location":"reference/containers/#witch.containers.Model.para_to_non_para","title":"<code>para_to_non_para(n_rounds=None, to_copy=['gnfw', 'gnfw_rs', 'a10', 'isobeta', 'uniform'])</code>","text":"<p>Function which approximately converts cluster profiles into a non-parametric form. Note this is only approximate and should be fit afterwords.</p> <p>Parameters:</p> Name Type Description Default <code>n_rounds</code> <code>Optional[int]</code> <p>Number of rounds to fit for output model. If none, copy from self</p> <code>None</code> <code>to_copy</code> <code>list[str]</code> <p>List of structures, by name, to copy.</p> <code>gnfw, gnfw_rs, a10, isobeta, uniform</code> <p>Returns:</p> Name Type Description <code>Model</code> <code>Model</code> <p>Model with a non-parametric representation of input model</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If there are no models to copy</p> Source code in <code>witch/containers.py</code> <pre><code>def para_to_non_para(\n    self,\n    n_rounds: Optional[int] = None,\n    to_copy: list[str] = [\"gnfw\", \"gnfw_rs\", \"a10\", \"isobeta\", \"uniform\"],\n) -&gt; Self:\n    \"\"\"\n    Function which approximately converts cluster profiles into a non-parametric form. Note this is\n    only approximate and should be fit afterwords.\n\n    Parameters\n    ----------\n    n_rounds: Optional int | None, default: None\n        Number of rounds to fit for output model. If none, copy from self\n    to_copy : list[str], default: gnfw, gnfw_rs, a10, isobeta, uniform\n        List of structures, by name, to copy.\n    Returns\n    -------\n    Model : Model\n        Model with a non-parametric representation of input model\n    Raises\n    ------\n    ValueError\n        If there are no models to copy\n    \"\"\"\n    cur_model = deepcopy(\n        self\n    )  # Make a copy of model, we don't want to lose structures\n    i = 0  # Make sure we keep at least one struct\n    for structure in cur_model.structures:\n        if structure.structure not in to_copy:\n            cur_model.remove_struct(structure.name)\n        else:\n            i += 1\n    if i == 0:\n        raise ValueError(\"Error: no model structures in {}\".format(to_copy))\n    params = jnp.array(cur_model.pars)\n    params = jnp.ravel(params)\n    pressure, _ = core.model3D(\n        cur_model.xyz, tuple(cur_model.n_struct), tuple(cur_model.n_rbins), params\n    )\n    pressure = pressure[\n        ..., int(pressure.shape[2] / 2)\n    ]  # Take middle slice. Close enough is good enough here, dont care about rounding\n\n    pixsize = np.abs(cur_model.xyz[1][0][1] - cur_model.xyz[1][0][0])\n\n    rs, bin1d, var1d = wu.bin_map(pressure, pixsize)\n\n    rbins = nonparametric.get_rbins(cur_model)\n    rbins = np.append(rbins, np.array([np.amax(rs)]))\n\n    condlist = [\n        np.array((rbins[i] &lt;= rs) &amp; (rs &lt; rbins[i + 1]))\n        for i in range(len(rbins) - 2, -1, -1)\n    ]\n\n    amps, pows, c = nonparametric.profile_to_broken_power(\n        rs, bin1d, condlist, rbins\n    )\n\n    priors = (-1 * np.inf, np.inf)\n    if n_rounds is None:\n        n_rounds = self.n_rounds\n    parameters = [\n        Parameter(\n            \"rbins\",\n            tuple([False] * n_rounds),\n            jnp.atleast_1d(jnp.array(rbins[:-1], dtype=float)),  # Drop last bin\n            jnp.zeros_like(jnp.atleast_1d(jnp.array(rbins[:-1])), dtype=float),\n            jnp.array(priors, dtype=float),\n        ),\n        Parameter(\n            \"amps\",\n            tuple([True] * n_rounds),\n            jnp.atleast_1d(jnp.array(amps, dtype=float)),\n            jnp.zeros_like(jnp.atleast_1d(jnp.array(amps)), dtype=float),\n            jnp.array(priors, dtype=float),\n        ),\n        Parameter(\n            \"pows\",\n            tuple([True] * n_rounds),\n            jnp.atleast_1d(jnp.array(pows, dtype=float)),\n            jnp.zeros_like(jnp.atleast_1d(jnp.array(pows)), dtype=float),\n            jnp.array(priors, dtype=float),\n        ),\n        Parameter(\n            \"dx\",  # TODO: miscentering\n            tuple([False] * n_rounds),\n            jnp.atleast_1d(jnp.array(0, dtype=float)),\n            jnp.zeros_like(jnp.atleast_1d(jnp.array(0)), dtype=float),\n            jnp.array(priors, dtype=float),\n        ),\n        Parameter(\n            \"dy\",  # TODO: miscentering\n            tuple([False] * n_rounds),\n            jnp.atleast_1d(jnp.array(0, dtype=float)),\n            jnp.zeros_like(jnp.atleast_1d(jnp.array(0)), dtype=float),\n            jnp.array(priors, dtype=float),\n        ),\n        Parameter(\n            \"dz\",  # TODO: miscentering\n            tuple([False] * n_rounds),\n            jnp.atleast_1d(jnp.array(0, dtype=float)),\n            jnp.zeros_like(jnp.atleast_1d(jnp.array(0)), dtype=float),\n            jnp.array(priors, dtype=float),\n        ),\n        Parameter(\n            \"c\",\n            tuple([True] * n_rounds),\n            jnp.atleast_1d(jnp.array(c, dtype=float)),\n            jnp.zeros_like(jnp.atleast_1d(jnp.array(0)), dtype=float),\n            jnp.array(priors, dtype=float),\n        ),\n    ]\n\n    structures = [\n        Structure(\n            \"nonpara_power\", \"nonpara_power\", parameters, n_rbins=len(rbins) - 1\n        )\n    ]\n    for structure in self.structures:\n        if structure.name not in to_copy:\n            structures.append(structure)\n\n    return Model(\n        name=\"test\",\n        structures=structures,\n        xyz=self.xyz,\n        dz=self.dz,\n        beam=self.beam,\n        n_rounds=n_rounds,\n        cur_round=0,\n    )\n</code></pre>"},{"location":"reference/containers/#witch.containers.Model.remove_struct","title":"<code>remove_struct(struct_name)</code>","text":"<p>Remove structure by name.</p> <p>Parameters:</p> Name Type Description Default <code>struct_name</code> <code>str</code> <p>Name of struct to be removed.</p> required Source code in <code>witch/containers.py</code> <pre><code>def remove_struct(self, struct_name: str):\n    \"\"\"\n    Remove structure by name.\n\n    Parameters\n    ----------\n    struct_name : str\n        Name of struct to be removed.\n    \"\"\"\n    n = None\n    for i, structure in enumerate(self.structures):\n        if str(structure.name) == str(struct_name):\n            n = i\n    if type(n) == int:\n        self.structures.pop(n)\n    else:\n        raise ValueError(\"Error: {} not in structure names\".format(struct_name))\n\n    to_pop = [\"to_fit_ever\", \"n_struct\", \"priors\", \"par_names\"]\n    for key in self.__dict__.keys():\n        if key in to_pop:  # Pop keys if they are in dict\n            self.__dict__.pop(key)\n\n    self.__dict__.pop(\"model\", None)\n    self.__dict__.pop(\"model_grad\", None)\n    self.__post_init__()\n</code></pre>"},{"location":"reference/containers/#witch.containers.Model.save","title":"<code>save(path)</code>","text":"<p>Serialize the model to a file with dill.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>The file to save to. Does not check to see if the path is valid.</p> required Source code in <code>witch/containers.py</code> <pre><code>def save(self, path: str):\n    \"\"\"\n    Serialize the model to a file with dill.\n\n    Parameters\n    ----------\n    path : str\n        The file to save to.\n        Does not check to see if the path is valid.\n    \"\"\"\n    with open(path, \"wb\") as f:\n        dill.dump(self, f)\n</code></pre>"},{"location":"reference/containers/#witch.containers.Model.to_map","title":"<code>to_map(x, y)</code>","text":"<p>Project the model into a map.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>Array</code> <p>The RA of the map at each pixel.</p> required <code>y</code> <code>Array</code> <p>Th Dec of the map at each pixel.</p> required <p>Returns:</p> Name Type Description <code>omap</code> <code>Array</code> <p>The model projected onto a map. Same shape as x.</p> Source code in <code>witch/containers.py</code> <pre><code>def to_map(self, x: jax.Array, y: jax.Array) -&gt; jax.Array:\n    \"\"\"\n    Project the model into a map.\n\n    Parameters\n    ----------\n    x : jax.Array\n        The RA of the map at each pixel.\n    y : jax.Array\n        Th Dec of the map at each pixel.\n\n    Returns\n    -------\n    omap : jax.Array\n        The model projected onto a map.\n        Same shape as x.\n    \"\"\"\n    omap = wu.bilinear_interp(\n        x.ravel(), y.ravel(), self.xyz[0].ravel(), self.xyz[1].ravel(), self.model\n    ).reshape(x.shape)\n    omap = omap - jnp.mean(omap)\n    return omap\n</code></pre>"},{"location":"reference/containers/#witch.containers.Model.to_map_grad","title":"<code>to_map_grad(x, y)</code>","text":"<p>Project the model into a map.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>Array</code> <p>The RA of the map at each pixel.</p> required <code>y</code> <code>Array</code> <p>Th Dec of the map at each pixel.</p> required <p>Returns:</p> Name Type Description <code>omap</code> <code>Array</code> <p>The model projected onto a map. Same shape as x.</p> <code>grad_map</code> <code>Array</code> <p>The gradient of each parameter projected onto a map. Has shape <code>(npar,) + x.shape</code>.</p> Source code in <code>witch/containers.py</code> <pre><code>def to_map_grad(self, x: jax.Array, y: jax.Array) -&gt; tuple[jax.Array, jax.Array]:\n    \"\"\"\n    Project the model into a map.\n\n    Parameters\n    ----------\n    x : jax.Array\n        The RA of the map at each pixel.\n    y : jax.Array\n        Th Dec of the map at each pixel.\n\n    Returns\n    -------\n    omap : jax.Array\n        The model projected onto a map.\n        Same shape as x.\n    grad_map : jax.Array\n        The gradient of each parameter projected onto a map.\n        Has shape `(npar,) + x.shape`.\n    \"\"\"\n    model, grad = self.model_grad\n    omap = wu.bilinear_interp(\n        x.ravel(), y.ravel(), self.xyz[0].ravel(), self.xyz[1].ravel(), model\n    ).reshape(x.shape)\n    omap = omap - jnp.mean(omap)\n    grad_map = jnp.array(\n        [\n            (\n                wu.bilinear_interp(\n                    x.ravel(),\n                    y.ravel(),\n                    self.xyz[0].ravel(),\n                    self.xyz[1].ravel(),\n                    _grad,\n                ).reshape(x.shape)\n                if _fit\n                else jnp.zeros_like(omap)\n            )\n            for _grad, _fit in zip(grad, self.to_fit)\n        ]\n    )\n    return omap, grad_map\n</code></pre>"},{"location":"reference/containers/#witch.containers.Model.to_tod","title":"<code>to_tod(dx, dy)</code>","text":"<p>Project the model into a TOD.</p> <p>Parameters:</p> Name Type Description Default <code>dx</code> <code>ArrayLike</code> <p>The RA TOD in arcseconds.</p> required <code>dy</code> <code>ArrayLike</code> <p>The Dec TOD in arcseconds.</p> required <p>Returns:</p> Name Type Description <code>tod</code> <code>Array</code> <p>The model as a TOD. Same shape as dx.</p> Source code in <code>witch/containers.py</code> <pre><code>def to_tod(self, dx: ArrayLike, dy: ArrayLike) -&gt; jax.Array:\n    \"\"\"\n    Project the model into a TOD.\n\n    Parameters\n    ----------\n    dx : ArrayLike\n        The RA TOD in arcseconds.\n    dy : ArrayLike\n        The Dec TOD in arcseconds.\n\n    Returns\n    -------\n    tod : jax.Array\n        The model as a TOD.\n        Same shape as dx.\n    \"\"\"\n    tod = wu.bilinear_interp(\n        dx, dy, self.xyz[0].ravel(), self.xyz[1].ravel(), self.model\n    )\n    tod = tod - jnp.mean(tod, axis=-1)[..., None]\n    return tod\n</code></pre>"},{"location":"reference/containers/#witch.containers.Model.to_tod_grad","title":"<code>to_tod_grad(dx, dy)</code>","text":"<p>Project the model and gradient into a TOD.</p> <p>Parameters:</p> Name Type Description Default <code>dx</code> <code>ArrayLike</code> <p>The RA TOD in arcseconds.</p> required <code>dy</code> <code>ArrayLike</code> <p>The Dec TOD in arcseconds.</p> required <p>Returns:</p> Name Type Description <code>tod</code> <code>Array</code> <p>The model as a TOD. Same shape as dx.</p> <code>grad_tod</code> <code>Array</code> <p>The gradient as a TOD. Has shape <code>(len(pars),) + dx.shape</code>.</p> Source code in <code>witch/containers.py</code> <pre><code>def to_tod_grad(self, dx: ArrayLike, dy: ArrayLike) -&gt; tuple[jax.Array, jax.Array]:\n    \"\"\"\n    Project the model and gradient into a TOD.\n\n    Parameters\n    ----------\n    dx : ArrayLike\n        The RA TOD in arcseconds.\n    dy : ArrayLike\n        The Dec TOD in arcseconds.\n\n    Returns\n    -------\n    tod : jax.Array\n        The model as a TOD.\n        Same shape as dx.\n    grad_tod : jax.Array\n        The gradient as a TOD.\n        Has shape `(len(pars),) + dx.shape`.\n    \"\"\"\n    model, grad = self.model_grad\n    tod = wu.bilinear_interp(\n        dx, dy, self.xyz[0].ravel(), self.xyz[1].ravel(), model\n    )\n    tod = tod - jnp.mean(tod, axis=-1)[..., None]\n    grad_tod = jnp.array(\n        [\n            (\n                wu.bilinear_interp(\n                    dx, dy, self.xyz[0].ravel(), self.xyz[1].ravel(), _grad\n                )\n                if _fit\n                else jnp.zeros_like(tod)\n            )\n            for _grad, _fit in zip(grad, self.to_fit)\n        ]\n    )\n\n    return tod, grad_tod\n</code></pre>"},{"location":"reference/containers/#witch.containers.Model.update","title":"<code>update(vals, errs, chisq)</code>","text":"<p>Update the parameter values and errors as well as the model chi-squared. This also resets the cache on <code>model</code> and <code>model_grad</code> if <code>vals</code> is different than <code>self.pars</code>.</p> <p>Parameters:</p> Name Type Description Default <code>vals</code> <code>Array</code> <p>The new parameter values. Should be in the same order as <code>pars</code>.</p> required <code>errs</code> <code>Array</code> <p>The new parameter errors. Should be in the same order as <code>pars</code>.</p> required <code>chisq</code> <code>Array</code> <p>The new chi-squared. Should be a scalar float array.</p> required <p>Returns:</p> Name Type Description <code>updated</code> <code>Model</code> <p>The updated model. While nominally the model will update in place, returning it alows us to use this function in JITed functions.</p> Source code in <code>witch/containers.py</code> <pre><code>def update(self, vals: jax.Array, errs: jax.Array, chisq: jax.Array) -&gt; Self:\n    \"\"\"\n    Update the parameter values and errors as well as the model chi-squared.\n    This also resets the cache on `model` and `model_grad`\n    if `vals` is different than `self.pars`.\n\n    Parameters\n    ----------\n    vals : jax.Array\n        The new parameter values.\n        Should be in the same order as `pars`.\n    errs : jax.Array\n        The new parameter errors.\n        Should be in the same order as `pars`.\n    chisq : jax.Array\n        The new chi-squared.\n        Should be a scalar float array.\n\n    Returns\n    -------\n    updated : Model\n        The updated model.\n        While nominally the model will update in place, returning it\n        alows us to use this function in JITed functions.\n    \"\"\"\n    if not np.array_equal(self.pars, vals):\n        self.__dict__.pop(\"model\", None)\n        self.__dict__.pop(\"model_grad\", None)\n    n = 0\n    for struct in self.structures:\n        for par in struct.parameters:\n            for i in range(len(par.val)):\n                par.val = par.val.at[i].set(vals[n])\n                par.err = par.err.at[i].set(errs[n])\n                n += 1\n    self.chisq = chisq\n\n    return self\n</code></pre>"},{"location":"reference/containers/#witch.containers.Model_xfer","title":"<code>Model_xfer</code>  <code>dataclass</code>","text":"<p>               Bases: <code>Model</code></p> Source code in <code>witch/containers.py</code> <pre><code>@dataclass\nclass Model_xfer(Model):\n\n    ks: jax.Array = field(default_factory=jnp.array([0]).copy)  # scalar float array\n    xfer_vals: jax.Array = field(\n        default_factory=jnp.array([1]).copy\n    )  # scalar float array\n\n    def __post_init__(self):\n        pass\n\n    @classmethod\n    def from_parent(cls, parent, xfer_str) -&gt; Self:\n        xfer = load_xfer(xfer_str)\n\n        pixsize = np.abs(parent.xyz[1][0][1] - parent.xyz[1][0][0])\n        ks = xfer[0, 0:] * pixsize  # This picks up an extra dim?\n        xfer_vals = xfer[1, 0:]\n\n        my_dict = {}\n        for key in parent.__dataclass_fields__.keys():\n            if parent.__dataclass_fields__[key].init:\n                my_dict[key] = deepcopy(parent.__dict__[key])\n\n        return cls(**my_dict, ks=ks.ravel(), xfer_vals=xfer_vals)\n\n    @cached_property\n    def model(self) -&gt; jax.Array:\n        cur_map = core.model(\n            self.xyz,\n            tuple(self.n_struct),\n            tuple(self.n_rbins),\n            self.dz,\n            self.beam,\n            *self.pars,\n        )\n        # Code from JMP, whoever that is, by way of Charles\n        farr = np.fft.fft2(cur_map)\n        nx, ny = cur_map.shape\n        kx = np.outer(np.fft.fftfreq(nx), np.zeros(ny).T + 1.0)\n        ky = np.outer(np.zeros(nx).T + 1.0, np.fft.fftfreq(ny))\n        k = np.sqrt(kx * kx + ky * ky)\n\n        filt = self.table_filter_2d(k)\n        farr *= filt\n\n        return np.real(np.fft.ifft2(farr))\n\n    def table_filter_2d(self, k) -&gt; jax.Array:\n        f = interpolate.interp1d(self.ks, self.xfer_vals)\n        kbin_min = self.ks.min()\n        kbin_max = self.ks.max()\n\n        filt = k * 0.0\n        filt[(k &gt;= kbin_min) &amp; (k &lt;= kbin_max)] = f(\n            k[(k &gt;= kbin_min) &amp; (k &lt;= kbin_max)]\n        )\n        filt[(k &lt; kbin_min)] = self.xfer_vals[self.ks == kbin_min]\n        filt[(k &gt; kbin_max)] = self.xfer_vals[self.ks == kbin_max]\n\n        return filt\n\n    @cached_property\n    def model_grad(self) -&gt; None:\n        \"\"\"\n        The evaluated model and its gradient, see `core.model_grad` for details.\n        Note that this is cached, but is automatically reset whenever\n        `update` is called or `cur_round` changes. Currently computing\n        grad for models with transfer function is not supported.\n\n        Returns\n        -------\n        None\n        \"\"\"\n\n        raise TypeError(\n            \"Error; Grad cannot currently be computed on Models with transfer function\"\n        )\n        return None  # Shouldnt get here\n\n    def to_tod_grad(self, dx: ArrayLike, dy: ArrayLike) -&gt; None:\n        \"\"\"\n        Project the model and gradient into a TOD. Currently computing\n        grad for models with transfer function is not supported.\n\n        Returns\n        -------\n        None\n        \"\"\"\n        raise TypeError(\n            \"Error; Grad cannot currently be computed on Models with transfer function\"\n        )\n        return None  # Shouldnt get here\n</code></pre>"},{"location":"reference/containers/#witch.containers.Model_xfer.model_grad","title":"<code>model_grad</code>  <code>cached</code> <code>property</code>","text":"<p>The evaluated model and its gradient, see <code>core.model_grad</code> for details. Note that this is cached, but is automatically reset whenever <code>update</code> is called or <code>cur_round</code> changes. Currently computing grad for models with transfer function is not supported.</p> <p>Returns:</p> Type Description <code>None</code>"},{"location":"reference/containers/#witch.containers.Model_xfer.to_tod_grad","title":"<code>to_tod_grad(dx, dy)</code>","text":"<p>Project the model and gradient into a TOD. Currently computing grad for models with transfer function is not supported.</p> <p>Returns:</p> Type Description <code>None</code> Source code in <code>witch/containers.py</code> <pre><code>def to_tod_grad(self, dx: ArrayLike, dy: ArrayLike) -&gt; None:\n    \"\"\"\n    Project the model and gradient into a TOD. Currently computing\n    grad for models with transfer function is not supported.\n\n    Returns\n    -------\n    None\n    \"\"\"\n    raise TypeError(\n        \"Error; Grad cannot currently be computed on Models with transfer function\"\n    )\n    return None  # Shouldnt get here\n</code></pre>"},{"location":"reference/containers/#witch.containers.Parameter","title":"<code>Parameter</code>  <code>dataclass</code>","text":"<p>Dataclass to represent a single parameter of a model.</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>str</code> <p>The name of the parameter. This is used only for display purposes.</p> <code>fit</code> <code>Array</code> <p>Should be array with length <code>Model.n_rounds</code>. <code>fit[i]</code> is True if we want to fit this parameter in the <code>i</code>'th round.</p> <code>val</code> <code>float</code> <p>The value of the parameter.</p> <code>err</code> <code>float</code> <p>The error on the parameter value.</p> <code>prior</code> <code>tuple[float, float]</code> <p>The prior on this parameter. Should be the tuple <code>(lower_bound, upper_bound)</code>.</p> Source code in <code>witch/containers.py</code> <pre><code>@register_pytree_node_class\n@dataclass\nclass Parameter:\n    \"\"\"\n    Dataclass to represent a single parameter of a model.\n\n    Attributes\n    ----------\n    name : str\n        The name of the parameter.\n        This is used only for display purposes.\n    fit : jax.Array\n        Should be array with length `Model.n_rounds`.\n        `fit[i]` is True if we want to fit this parameter in the `i`'th round.\n    val : float\n        The value of the parameter.\n    err : float\n        The error on the parameter value.\n    prior : tuple[float, float]\n        The prior on this parameter.\n        Should be the tuple `(lower_bound, upper_bound)`.\n    \"\"\"\n\n    name: str\n    fit: tuple[bool]  # 1d bool array\n    val: jax.Array  # Scalar float array\n    err: jax.Array  # Scalar float array\n    prior: jax.Array  # 2 element float array\n\n    @property\n    def fit_ever(self) -&gt; bool:  # jax.Array:\n        \"\"\"\n        Check if this parameter is set to ever be fit.\n\n        Returns\n        -------\n        fit_ever : jax.Array\n            Single element jax boolean array.\n            True if this parameter is ever fit.\n        \"\"\"\n        return np.any(self.fit).item()\n\n    # Functions for making this a pytree\n    # Don't call this on your own\n    def tree_flatten(self) -&gt; tuple[tuple, tuple]:\n        children = (self.val, self.err, self.prior)\n        aux_data = (self.name, self.fit)\n\n        return (children, aux_data)\n\n    @classmethod\n    def tree_unflatten(cls, aux_data, children) -&gt; Self:\n        name, fit = aux_data\n        return cls(name, fit, *children)\n</code></pre>"},{"location":"reference/containers/#witch.containers.Parameter.fit_ever","title":"<code>fit_ever</code>  <code>property</code>","text":"<p>Check if this parameter is set to ever be fit.</p> <p>Returns:</p> Name Type Description <code>fit_ever</code> <code>Array</code> <p>Single element jax boolean array. True if this parameter is ever fit.</p>"},{"location":"reference/containers/#witch.containers.Structure","title":"<code>Structure</code>  <code>dataclass</code>","text":"<p>Dataclass to represent a structure within the model.</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>str</code> <p>The name of the structure. This is used only for display purposes.</p> <code>structure</code> <code>str</code> <p>The type of structure that this is an instance of. Should be a string that appears in <code>core.ORDER</code></p> <code>parameters</code> <code>list[Parameter]</code> <p>The model parameters for this structure.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If <code>structure</code> is not a valid structure. If we have the wrong number of parameters.</p> Source code in <code>witch/containers.py</code> <pre><code>@register_pytree_node_class\n@dataclass\nclass Structure:\n    \"\"\"\n    Dataclass to represent a structure within the model.\n\n    Attributes\n    ----------\n    name : str\n        The name of the structure.\n        This is used only for display purposes.\n    structure : str\n        The type of structure that this is an instance of.\n        Should be a string that appears in `core.ORDER`\n    parameters : list[Parameter]\n        The model parameters for this structure.\n\n    Raises\n    ------\n    ValueError\n        If `structure` is not a valid structure.\n        If we have the wrong number of parameters.\n    \"\"\"\n\n    name: str\n    structure: str\n    parameters: list[Parameter]\n    n_rbins: int = 0\n\n    def __post_init__(self):\n        self.structure = self.structure.lower()\n        # Check that this is a valid structure\n        if self.structure not in STRUCT_N_PAR.keys():\n            raise ValueError(f\"{self.name} has invalid structure: {self.structure}\")\n        # Check that we have the correct number of params\n        if len(self.parameters) != STRUCT_N_PAR[self.structure]:\n            raise ValueError(\n                f\"{self.name} has incorrect number of parameters, expected {STRUCT_N_PAR[self.structure]} for {self.structure} but was given {len(self.parameters)}\"\n            )\n\n    # Functions for making this a pytree\n    # Don't call this on your own\n    def tree_flatten(self) -&gt; tuple[tuple, tuple]:\n        children = tuple(self.parameters)\n        aux_data = (self.name, self.structure, self.n_rbins)\n\n        return (children, aux_data)\n\n    @classmethod\n    def tree_unflatten(cls, aux_data, children) -&gt; Self:\n        name, structure, n_rbins = aux_data\n        parameters = children\n\n        return cls(name, structure, list(parameters), n_rbins)\n</code></pre>"},{"location":"reference/core/","title":"core","text":"<p>Core module for generating models and their gradients.</p>"},{"location":"reference/core/#witch.core.model","title":"<code>model = jax.jit(model, static_argnums=model_static)</code>  <code>module-attribute</code>","text":"<p>Generically create models with substructure.</p> <p>Parameters:</p> Name Type Description Default <code>xyz</code> <code>tuple[Array, Array, Array, float, float]</code> <p>Grid to compute model on. See <code>containers.Model.xyz</code> for details.</p> required <code>n_structs</code> <code>tuple[int, ...]</code> <p>Number of each structure to use. Should be in the same order as <code>order</code>.</p> required <code>n_rbins</code> <code>tuple[int]</code> <p>Number of rbins for each non-parametric model</p> required <code>dz</code> <code>float</code> <p>Factor to scale by while integrating. Should at least include the pixel size along the LOS.</p> required <code>beam</code> <code>Array</code> <p>Beam to convolve by, should be a 2d array.</p> required <code>*pars</code> <code>Unpack[tuple[float, ...]]</code> <p>1D container of model parameters.</p> required <p>Returns:</p> Name Type Description <code>model</code> <code>Array</code> <p>The model with the specified substructure evaluated on the grid.</p>"},{"location":"reference/core/#witch.core.model_grad","title":"<code>model_grad = jax.jit(model_grad, static_argnums=model_grad_static)</code>  <code>module-attribute</code>","text":"<p>A wrapper around model that also returns the gradients of the model. Only the additional arguments are described here, see <code>model</code> for the others. Note that the additional arguments are passed before the *params argument.</p> <p>Parameters:</p> Name Type Description Default <code>argnums</code> <code>tuple[int, ...]</code> <p>The indices of the arguments to evaluate the gradient at.</p> required <p>Returns:</p> Name Type Description <code>model</code> <code>Array</code> <p>The model with the specified substructure evaluated on the grid.</p> <code>grad</code> <code>Array</code> <p>The gradient of the model with respect to the model parameters. Has shape <code>(len(pars),) + model.shape)</code>.</p>"},{"location":"reference/core/#witch.core.model3D","title":"<code>model3D(xyz, n_structs, n_rbins, params)</code>","text":"<p>Generate a 3D profile from params on xyz.</p> <p>Parameters:</p> Name Type Description Default <code>xyz</code> <code>tuple[Array, Array, Array, float, float]</code> <p>Grid to compute model on. See <code>containers.Model.xyz</code> for details.</p> required <code>n_structs</code> <code>tuple[int, ...]</code> <p>Number of each structure to use. Should be in the same order as <code>order</code>.</p> required <code>n_rbins</code> <code>tuple[int]</code> <p>Number of rbins for each non-parametric model</p> required <code>params</code> <code>tuple[float, ...]</code> <p>1D container of model parameters.</p> required <p>Returns:</p> Name Type Description <code>pressure</code> <code>Array</code> <p>The 3D model with the specified substructure evaluated on the grid.</p> <code>start</code> <code>int</code> <p>Current Total npar.</p> Source code in <code>witch/core.py</code> <pre><code>def model3D(\n    xyz: tuple[jax.Array, jax.Array, jax.Array, float, float],\n    n_structs: tuple[int, ...],\n    n_rbins: tuple[int],\n    params: tuple[float, ...],  # TODO: not sure this is a tuple\n) -&gt; jax.Array:\n    \"\"\"\n    Generate a 3D profile from params on xyz.\n\n    Parameters\n    ----------\n    xyz : tuple[jax.Array, jax.Array, jax.Array, float, float]\n        Grid to compute model on.\n        See `containers.Model.xyz` for details.\n    n_structs : tuple[int, ...]\n        Number of each structure to use.\n        Should be in the same order as `order`.\n    n_rbins : tuple[int]\n        Number of rbins for each non-parametric model\n    params : tuple[float,...]\n        1D container of model parameters.\n\n    Returns\n    -------\n    pressure : jax.Array\n        The 3D model with the specified substructure evaluated on the grid.\n    start : int\n        Current Total npar.\n    \"\"\"\n    pressure = jnp.zeros((xyz[0].shape[0], xyz[1].shape[1], xyz[2].shape[2]))\n    start = 0\n\n    for i, (n_struct, struct) in enumerate(zip(n_structs, ORDER)):\n        if STRUCT_STAGE[struct] != -1:\n            continue\n        if not n_struct:\n            continue\n        delta = n_struct * (\n            n_rbins[i] * STRUCT_N_NONPARA[struct]\n            + STRUCT_N_PAR[struct]\n            - STRUCT_N_NONPARA[struct]\n        )\n        struct_pars = params[start : start + delta].reshape(\n            (n_struct, int(delta / n_struct))\n        )\n        start += delta\n        for j in range(n_struct):\n            cur_struct_pars = struct_pars[j]\n            nonpara_struct_pars = cur_struct_pars[\n                : n_rbins[i] * STRUCT_N_NONPARA[struct]\n            ].reshape((STRUCT_N_NONPARA[struct], n_rbins[i]))\n            cur_struct_pars = cur_struct_pars[n_rbins[i] * STRUCT_N_NONPARA[struct] :]\n            # pressure = jnp.add(pressure, STRUCT_FUNCS[struct](*nonpara_struct_pars, *struct_pars, xyz))\n            cur_pars = [\n                nonpara_struct_pars[k] for k in range(STRUCT_N_NONPARA[struct])\n            ] + [\n                cur_struct_pars[k]\n                for k in range(STRUCT_N_PAR[struct] - STRUCT_N_NONPARA[struct])\n            ]\n            # pressure = jnp.add(pressure, STRUCT_FUNCS[struct](*nonpara_struct_pars, *struct_pars, xyz))\n            pressure = jnp.add(pressure, STRUCT_FUNCS[struct](*cur_pars, xyz))\n\n    # Stage 0, add to the 3d grid\n    for n_struct, struct in zip(n_structs, ORDER):\n        if STRUCT_STAGE[struct] != 0:\n            continue\n        if not n_struct:\n            continue\n        delta = n_struct * STRUCT_N_PAR[struct]\n        struct_pars = params[start : start + delta].reshape(\n            (n_struct, STRUCT_N_PAR[struct])\n        )\n        start += delta\n        for i in range(n_struct):\n            pressure = jnp.add(pressure, STRUCT_FUNCS[struct](*struct_pars[i], xyz))\n\n    # Stage 1, modify the 3d grid\n    for n_struct, struct in zip(n_structs, ORDER):\n        if STRUCT_STAGE[struct] != 1:\n            continue\n        if not n_struct:\n            continue\n        delta = n_struct * STRUCT_N_PAR[struct]\n        struct_pars = params[start : start + delta].reshape(\n            (n_struct, STRUCT_N_PAR[struct])\n        )\n        start += delta\n        for i in range(n_struct):\n            pressure = STRUCT_FUNCS[struct](pressure, xyz, *struct_pars[i])\n\n    return pressure, start\n</code></pre>"},{"location":"reference/core/#witch.core.stage2_model","title":"<code>stage2_model(xyz, n_structs, dz, beam, *pars)</code>","text":"<p>Only returns the second stage of the model. Used for visualizing shocks, etc. that can otherwise be hard to see in a model plot</p> <p>Parameters:</p> Name Type Description Default <code>xyz</code> <code>tuple[Array, Array, Array, float, float]</code> <p>Grid to compute model on. See <code>containers.Model.xyz</code> for details.</p> required <code>n_structs</code> <code>tuple[int, ...]</code> <p>Number of each structure to use. Should be in the same order as <code>order</code>.</p> required <code>dz</code> <code>float</code> <p>Factor to scale by while integrating. Should at least include the pixel size along the LOS.</p> required <code>beam</code> <code>Array</code> <p>Beam to convolve by, should be a 2d array.</p> required <code>*pars</code> <code>Unpack[tuple[float, ...]]</code> <p>1D container of model parameters.</p> <code>()</code> <p>Returns:</p> Name Type Description <code>model</code> <code>Array</code> <p>The model with the specified substructure evaluated on the grid. No stage 3 structures are included.</p> Source code in <code>witch/core.py</code> <pre><code>def stage2_model(\n    xyz: tuple[jax.Array, jax.Array, jax.Array, float, float],\n    n_structs: tuple[int, ...],\n    dz: float,\n    beam: jax.Array,\n    *pars: Unpack[tuple[float, ...]],\n):\n    \"\"\"\n    Only returns the second stage of the model. Used for visualizing shocks, etc.\n    that can otherwise be hard to see in a model plot\n\n    Parameters\n    ----------\n    xyz : tuple[jax.Array, jax.Array, jax.Array, float, float]\n        Grid to compute model on.\n        See `containers.Model.xyz` for details.\n    n_structs : tuple[int, ...]\n        Number of each structure to use.\n        Should be in the same order as `order`.\n    dz : float\n        Factor to scale by while integrating.\n        Should at least include the pixel size along the LOS.\n    beam : jax.Array\n        Beam to convolve by, should be a 2d array.\n    *pars : Unpack[tuple[float,...]]\n        1D container of model parameters.\n\n    Returns\n    -------\n    model : jax.Array\n        The model with the specified substructure evaluated on the grid.\n        No stage 3 structures are included.\n    \"\"\"\n    params = jnp.array(pars)\n    params = jnp.ravel(params)  # Fixes strange bug with params having dim (1,n)\n\n    pressure = jnp.ones((xyz[0].shape[0], xyz[1].shape[1], xyz[2].shape[2]))\n    start = 0\n\n    # Stage 0, track delta but don't add anything\n    for n_struct, struct in zip(n_structs, ORDER):\n        if STRUCT_STAGE[struct] != 0:\n            continue\n        if not n_struct:\n            continue\n        delta = n_struct * STRUCT_N_PAR[struct]\n        struct_pars = params[start : start + delta].reshape(\n            (n_struct, STRUCT_N_PAR[struct])\n        )\n        start += delta\n\n    # Stage 1, modify the 3d grid\n    for n_struct, struct in zip(n_structs, ORDER):\n        if STRUCT_STAGE[struct] != 1:\n            continue\n        if not n_struct:\n            continue\n\n        delta = n_struct * STRUCT_N_PAR[struct]\n        struct_pars = params[start : start + delta].reshape(\n            (n_struct, STRUCT_N_PAR[struct])\n        )\n\n        start += delta\n        for i in range(n_struct):\n            pressure = STRUCT_FUNCS[struct](pressure, xyz, *struct_pars[i])\n\n    # Integrate along line of site\n    ip = trapz(pressure, dx=dz, axis=-1)\n\n    bound0, bound1 = int((ip.shape[0] - beam.shape[0]) / 2), int(\n        (ip.shape[1] - beam.shape[1]) / 2\n    )\n    beam = jnp.pad(\n        beam,\n        (\n            (bound0, ip.shape[0] - beam.shape[0] - bound0),\n            (bound1, ip.shape[1] - beam.shape[1] - bound1),\n        ),\n    )\n\n    ip = fft_conv(ip, beam)\n\n    return ip\n</code></pre>"},{"location":"reference/dataset/","title":"dataset","text":"<p>Module for dataset container and protocols for defining the spec of the required functions for all datasets.</p>"},{"location":"reference/dataset/#witch.dataset.DataSet","title":"<code>DataSet</code>  <code>dataclass</code>","text":"<p>Class for storing a dataset.</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>str</code> <p>The name of the dataset.</p> <code>get_files</code> <code>GetFiles</code> <p>The function to get the file list for this dataset.</p> <code>load</code> <code>Load</code> <p>The function to load data for this dataset.</p> <code>get_info</code> <code>GetInfo</code> <p>The function to get the info dict for this dataset.</p> <code>make_beam</code> <code>MakeBeam</code> <p>The function to make the beam for this dataset.</p> <code>preproc</code> <code>PreProc</code> <p>The function to run preprocessing for this dataset.</p> <code>postproc</code> <code>PostProc</code> <p>The function to run postprocessing for this dataset.</p> <code>postfit</code> <code>PostFit</code> <p>The function to run after fitting this dataset.</p> <code>info</code> <code>dict</code> <p>The info dict for this dataset. This field is not part of the initialization function.</p> <code>datavec</code> <code>DataVec</code> <p>The data vector for this data. This will be a <code>jitkasi</code> container class. This field is not part of the initialization function.</p> Source code in <code>witch/dataset.py</code> <pre><code>@register_pytree_node_class\n@dataclass\nclass DataSet:\n    \"\"\"\n    Class for storing a dataset.\n\n    Attributes\n    ----------\n    name : str\n        The name of the dataset.\n    get_files : GetFiles\n        The function to get the file list for this dataset.\n    load : Load\n        The function to load data for this dataset.\n    get_info : GetInfo\n        The function to get the info dict for this dataset.\n    make_beam : MakeBeam\n        The function to make the beam for this dataset.\n    preproc : PreProc\n        The function to run preprocessing for this dataset.\n    postproc : PostProc\n        The function to run postprocessing for this dataset.\n    postfit : PostFit\n        The function to run after fitting this dataset.\n    info : dict\n        The info dict for this dataset.\n        This field is not part of the initialization function.\n    datavec : DataVec\n        The data vector for this data.\n        This will be a `jitkasi` container class.\n        This field is not part of the initialization function.\n    \"\"\"\n\n    name: str\n    get_files: GetFiles\n    load: Load\n    get_info: GetInfo\n    make_beam: MakeBeam\n    preproc: PreProc\n    postproc: PostProc\n    postfit: PostFit\n    info: dict = field(init=False)\n    datavec: DataVec = field(init=False)\n\n    def __post_init__(self: Self):\n        assert isinstance(self.get_files, GetFiles)\n        assert isinstance(self.load, Load)\n        assert isinstance(self.get_info, GetInfo)\n        assert isinstance(self.make_beam, MakeBeam)\n        assert isinstance(self.preproc, PreProc)\n        assert isinstance(self.postproc, PostProc)\n        assert isinstance(self.postfit, PostFit)\n\n    def __setattr__(self, name, value):\n        if name == \"info\":\n            if \"mode\" not in value:\n                raise ValueError(\"Cannot set dataset info without a 'mode' field\")\n            if value[\"mode\"] not in [\"tod\", \"map\"]:\n                raise ValueError(\"Dataset info contained invalid mode\")\n            if \"objective\" not in value:\n                raise ValueError(\"Cannot set dataset info without an 'objective' field\")\n            if not isinstance(value[\"objective\"], ObjectiveFunc):\n                raise ValueError(\"Dataset info contained invalid objective function\")\n        return super().__setattr__(name, value)\n\n    @property\n    def mode(self: Self) -&gt; str:\n        \"\"\"\n        Get the mode for this dataset.\n        Will be `tod` or `map`.\n\n        Returns\n        -------\n        mode : str\n            The dataset mode.\n        \"\"\"\n        return self.info[\"mode\"]\n\n    @property\n    def objective(self: Self) -&gt; ObjectiveFunc:\n        \"\"\"\n        Get the objective function for this dataset.\n\n        Returns\n        -------\n        objective : ObjectiveFunc\n            The objective function.\n        \"\"\"\n        return self.info[\"objective\"]\n\n    @property\n    def noise_class(self: Self) -&gt; NoiseModel:\n        \"\"\"\n        Get the noise class for this dataset.\n\n        Returns\n        -------\n        noise_class : NoiseModel\n            The class of the noise model that will be used for this dataset.\n            This field is not part of the initialization function.\n        \"\"\"\n        return self.info[\"noise_class\"]\n\n    @property\n    def noise_args(self: Self) -&gt; tuple:\n        \"\"\"\n        Get the noise arguments for this dataset.\n\n        Returns\n        -------\n        noise_args : tuple\n            Positional arguments to be used by the noise model.\n            This field is not part of the initialization function.\n        \"\"\"\n        return self.info[\"noise_args\"]\n\n    @property\n    def noise_kwargs(self: Self) -&gt; tuple:\n        \"\"\"\n        Get the noise keyword arguments for this dataset.\n\n        Returns\n        -------\n        noise_kwargs : dict\n            Keyword arguments to be used by the noise model.\n            This field is not part of the initialization function.\n        \"\"\"\n        return self.info[\"noise_kwargs\"]\n\n    def check_completeness(self: Self):\n        \"\"\"\n        Check if all fields are actually populated and raise an error if not.\n\n        Raises\n        ------\n        ValueError\n            If the dataset is missing some fields.\n            If `self.info` is missing some required info.\n            If `self.mode` is not a valid mode.\n            If `self.objective` is not a valid objective function.\n        \"\"\"\n        missing = [\n            fname\n            for fname in self.__dataclass_fields__.keys()\n            if fname not in self.__dict__\n        ]\n        if len(missing) &gt; 0:\n            raise ValueError(f\"Datset is missing the following fields: {missing}\")\n\n        required_info = np.array(\n            [\"mode\", \"objective\", \"noise_class\", \"noise_args\", \"noise_kwargs\"]\n        )\n        contained_info = list(self.info.keys())\n        missing_info = required_info[~np.isin(required_info, contained_info)]\n        if len(missing_info) &gt; 0:\n            raise ValueError(\n                f\"(Dataset info is missing the following fields: {missing_info}\"\n            )\n\n        if self.info[\"mode\"] not in [\"tod\", \"map\"]:\n            raise ValueError(\"Dataset info contained invalid mode\")\n        if not isinstance(self.info[\"objective\"], ObjectiveFunc):\n            raise ValueError(\"Dataset info contained invalid objective function\")\n\n    # Functions for making this a pytree\n    # Don't call this on your own\n    def tree_flatten(self) -&gt; tuple[tuple, tuple]:\n        if \"datavec\" in self.__dict__:\n            children = (self.datavec,)\n        else:\n            children = (None,)\n        aux_data = (\n            self.name,\n            self.get_files,\n            self.load,\n            self.get_info,\n            self.make_beam,\n            self.preproc,\n            self.postproc,\n            self.postfit,\n        )\n        if \"info\" in self.__dict__:\n            aux_data += (self.info,)\n        else:\n            aux_data += (None,)\n\n        return (children, aux_data)\n\n    @classmethod\n    def tree_unflatten(cls, aux_data, children) -&gt; Self:\n        (datavec,) = children\n        name = aux_data[0]\n        funcs = aux_data[1:8]\n        info = aux_data[8]\n        dataset = cls(name, *funcs)\n        if datavec is not None:\n            dataset.datavec = datavec\n        if info is not None:\n            dataset.info = info\n        return dataset\n</code></pre>"},{"location":"reference/dataset/#witch.dataset.DataSet.mode","title":"<code>mode</code>  <code>property</code>","text":"<p>Get the mode for this dataset. Will be <code>tod</code> or <code>map</code>.</p> <p>Returns:</p> Name Type Description <code>mode</code> <code>str</code> <p>The dataset mode.</p>"},{"location":"reference/dataset/#witch.dataset.DataSet.noise_args","title":"<code>noise_args</code>  <code>property</code>","text":"<p>Get the noise arguments for this dataset.</p> <p>Returns:</p> Name Type Description <code>noise_args</code> <code>tuple</code> <p>Positional arguments to be used by the noise model. This field is not part of the initialization function.</p>"},{"location":"reference/dataset/#witch.dataset.DataSet.noise_class","title":"<code>noise_class</code>  <code>property</code>","text":"<p>Get the noise class for this dataset.</p> <p>Returns:</p> Name Type Description <code>noise_class</code> <code>NoiseModel</code> <p>The class of the noise model that will be used for this dataset. This field is not part of the initialization function.</p>"},{"location":"reference/dataset/#witch.dataset.DataSet.noise_kwargs","title":"<code>noise_kwargs</code>  <code>property</code>","text":"<p>Get the noise keyword arguments for this dataset.</p> <p>Returns:</p> Name Type Description <code>noise_kwargs</code> <code>dict</code> <p>Keyword arguments to be used by the noise model. This field is not part of the initialization function.</p>"},{"location":"reference/dataset/#witch.dataset.DataSet.objective","title":"<code>objective</code>  <code>property</code>","text":"<p>Get the objective function for this dataset.</p> <p>Returns:</p> Name Type Description <code>objective</code> <code>ObjectiveFunc</code> <p>The objective function.</p>"},{"location":"reference/dataset/#witch.dataset.DataSet.check_completeness","title":"<code>check_completeness()</code>","text":"<p>Check if all fields are actually populated and raise an error if not.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the dataset is missing some fields. If <code>self.info</code> is missing some required info. If <code>self.mode</code> is not a valid mode. If <code>self.objective</code> is not a valid objective function.</p> Source code in <code>witch/dataset.py</code> <pre><code>def check_completeness(self: Self):\n    \"\"\"\n    Check if all fields are actually populated and raise an error if not.\n\n    Raises\n    ------\n    ValueError\n        If the dataset is missing some fields.\n        If `self.info` is missing some required info.\n        If `self.mode` is not a valid mode.\n        If `self.objective` is not a valid objective function.\n    \"\"\"\n    missing = [\n        fname\n        for fname in self.__dataclass_fields__.keys()\n        if fname not in self.__dict__\n    ]\n    if len(missing) &gt; 0:\n        raise ValueError(f\"Datset is missing the following fields: {missing}\")\n\n    required_info = np.array(\n        [\"mode\", \"objective\", \"noise_class\", \"noise_args\", \"noise_kwargs\"]\n    )\n    contained_info = list(self.info.keys())\n    missing_info = required_info[~np.isin(required_info, contained_info)]\n    if len(missing_info) &gt; 0:\n        raise ValueError(\n            f\"(Dataset info is missing the following fields: {missing_info}\"\n        )\n\n    if self.info[\"mode\"] not in [\"tod\", \"map\"]:\n        raise ValueError(\"Dataset info contained invalid mode\")\n    if not isinstance(self.info[\"objective\"], ObjectiveFunc):\n        raise ValueError(\"Dataset info contained invalid objective function\")\n</code></pre>"},{"location":"reference/dataset/#witch.dataset.GetFiles","title":"<code>GetFiles</code>","text":"<p>               Bases: <code>Protocol</code></p> <p>Function that returns a list of files to be loaded for this dataset. Technically these do not have the be filepaths, just a list where each entry is the information needed to load the data. See docstring of <code>__call__</code> for details on the parameters and returns.</p> Source code in <code>witch/dataset.py</code> <pre><code>@runtime_checkable\nclass GetFiles(Protocol):\n    \"\"\"\n    Function that returns a list of files to be loaded for this dataset.\n    Technically these do not have the be filepaths, just a list where each\n    entry is the information needed to load the data.\n    See docstring of `__call__` for details on the parameters and returns.\n    \"\"\"\n\n    def __call__(self: Self, dset_name: str, cfg: dict) -&gt; list:\n        \"\"\"\n        Parameters\n        ----------\n        dset_name : str\n            The name of the dataset to get file list for.\n        cfg : dict\n            The loaded `witcher` config.\n\n        Returns\n        -------\n        file_list : list\n            A list where each entry contains the information needed to load a\n            discrete piece of data (ie: a TOD or map) for this dataset.\n            The format of the entries are up to the dataset but the number of\n            entries must match the number of things loaded for MPI planning\n            purposes.\n        \"\"\"\n        ...\n</code></pre>"},{"location":"reference/dataset/#witch.dataset.GetFiles.__call__","title":"<code>__call__(dset_name, cfg)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>dset_name</code> <code>str</code> <p>The name of the dataset to get file list for.</p> required <code>cfg</code> <code>dict</code> <p>The loaded <code>witcher</code> config.</p> required <p>Returns:</p> Name Type Description <code>file_list</code> <code>list</code> <p>A list where each entry contains the information needed to load a discrete piece of data (ie: a TOD or map) for this dataset. The format of the entries are up to the dataset but the number of entries must match the number of things loaded for MPI planning purposes.</p> Source code in <code>witch/dataset.py</code> <pre><code>def __call__(self: Self, dset_name: str, cfg: dict) -&gt; list:\n    \"\"\"\n    Parameters\n    ----------\n    dset_name : str\n        The name of the dataset to get file list for.\n    cfg : dict\n        The loaded `witcher` config.\n\n    Returns\n    -------\n    file_list : list\n        A list where each entry contains the information needed to load a\n        discrete piece of data (ie: a TOD or map) for this dataset.\n        The format of the entries are up to the dataset but the number of\n        entries must match the number of things loaded for MPI planning\n        purposes.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/dataset/#witch.dataset.GetInfo","title":"<code>GetInfo</code>","text":"<p>               Bases: <code>Protocol</code></p> <p>Function that gets information that will be used by other functions for this dataset. At the minimum this should contain:</p> <ul> <li><code>mode</code>: a string that is either <code>tod</code> or <code>map</code> that detemines how the dataset is treated.</li> <li><code>objective</code>: a function pointer to an objective function. See <code>witch.objective.ObjectiveFunc</code> for details.</li> </ul> <p>See docstring of <code>__call__</code> for details on the parameters and returns.</p> Source code in <code>witch/dataset.py</code> <pre><code>@runtime_checkable\nclass GetInfo(Protocol):\n    \"\"\"\n    Function that gets information that will be used by other functions for this dataset.\n    At the minimum this should contain:\n\n    * `mode`: a string that is either `tod` or `map` that detemines how the dataset is treated.\n    * `objective`: a function pointer to an objective function. See `witch.objective.ObjectiveFunc` for details.\n\n    See docstring of `__call__` for details on the parameters and returns.\n    \"\"\"\n\n    def __call__(self: Self, dset_name: str, cfg: dict, datavec: DataVec) -&gt; dict:\n        \"\"\"\n        Parameters\n        ----------\n        dset_name : str\n            The name of the dataset to get file list for.\n        cfg : dict\n            The loaded `witcher` config.\n        datavec : DataVec\n            The `jitkasi` container for the data.\n            This is going to be `TODVec` for TODs\n            and `SolutionSet` for maps.\n\n\n        Returns\n        -------\n        info : dict\n            Dictionairy containing information.\n            Must at least contain `mode` and `objective`.\n        \"\"\"\n        ...\n</code></pre>"},{"location":"reference/dataset/#witch.dataset.GetInfo.__call__","title":"<code>__call__(dset_name, cfg, datavec)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>dset_name</code> <code>str</code> <p>The name of the dataset to get file list for.</p> required <code>cfg</code> <code>dict</code> <p>The loaded <code>witcher</code> config.</p> required <code>datavec</code> <code>DataVec</code> <p>The <code>jitkasi</code> container for the data. This is going to be <code>TODVec</code> for TODs and <code>SolutionSet</code> for maps.</p> required <p>Returns:</p> Name Type Description <code>info</code> <code>dict</code> <p>Dictionairy containing information. Must at least contain <code>mode</code> and <code>objective</code>.</p> Source code in <code>witch/dataset.py</code> <pre><code>def __call__(self: Self, dset_name: str, cfg: dict, datavec: DataVec) -&gt; dict:\n    \"\"\"\n    Parameters\n    ----------\n    dset_name : str\n        The name of the dataset to get file list for.\n    cfg : dict\n        The loaded `witcher` config.\n    datavec : DataVec\n        The `jitkasi` container for the data.\n        This is going to be `TODVec` for TODs\n        and `SolutionSet` for maps.\n\n\n    Returns\n    -------\n    info : dict\n        Dictionairy containing information.\n        Must at least contain `mode` and `objective`.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/dataset/#witch.dataset.Load","title":"<code>Load</code>","text":"<p>               Bases: <code>Protocol</code></p> <p>Function that loads data into a <code>jitkasi</code> container. See docstring of <code>__call__</code> for details on the parameters and returns.</p> Source code in <code>witch/dataset.py</code> <pre><code>@runtime_checkable\nclass Load(Protocol):\n    \"\"\"\n    Function that loads data into a `jitkasi` container.\n    See docstring of `__call__` for details on the parameters and returns.\n    \"\"\"\n\n    def __call__(\n        self: Self, dset_name: str, cfg: dict, fnames: list, comm: MPI.Intracomm\n    ) -&gt; DataVec:\n        \"\"\"\n        Parameters\n        ----------\n        dset_name : str\n            The name of the dataset to get file list for.\n        cfg : dict\n            The loaded `witcher` config.\n        fnames : list\n            Some subset of the output of `GetFiles`.\n        comm : MPI.Intracomm\n            The MPI communicator to pass to the `jitkasi` container.\n\n        Returns\n        -------\n        datavec : DataVec\n            The `jitkasi` container for the data.\n            This is going to be `TODVec` for TODs\n            and `SolutionSet` for maps.\n        \"\"\"\n        ...\n</code></pre>"},{"location":"reference/dataset/#witch.dataset.Load.__call__","title":"<code>__call__(dset_name, cfg, fnames, comm)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>dset_name</code> <code>str</code> <p>The name of the dataset to get file list for.</p> required <code>cfg</code> <code>dict</code> <p>The loaded <code>witcher</code> config.</p> required <code>fnames</code> <code>list</code> <p>Some subset of the output of <code>GetFiles</code>.</p> required <code>comm</code> <code>Intracomm</code> <p>The MPI communicator to pass to the <code>jitkasi</code> container.</p> required <p>Returns:</p> Name Type Description <code>datavec</code> <code>DataVec</code> <p>The <code>jitkasi</code> container for the data. This is going to be <code>TODVec</code> for TODs and <code>SolutionSet</code> for maps.</p> Source code in <code>witch/dataset.py</code> <pre><code>def __call__(\n    self: Self, dset_name: str, cfg: dict, fnames: list, comm: MPI.Intracomm\n) -&gt; DataVec:\n    \"\"\"\n    Parameters\n    ----------\n    dset_name : str\n        The name of the dataset to get file list for.\n    cfg : dict\n        The loaded `witcher` config.\n    fnames : list\n        Some subset of the output of `GetFiles`.\n    comm : MPI.Intracomm\n        The MPI communicator to pass to the `jitkasi` container.\n\n    Returns\n    -------\n    datavec : DataVec\n        The `jitkasi` container for the data.\n        This is going to be `TODVec` for TODs\n        and `SolutionSet` for maps.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/dataset/#witch.dataset.MakeBeam","title":"<code>MakeBeam</code>","text":"<p>               Bases: <code>Protocol</code></p> <p>Function that makes the beam array. If you don't need a beam just write a dummy function to return <code>jnp.array([[1]])</code>. See docstring of <code>__call__</code> for details on the parameters and returns.</p> Source code in <code>witch/dataset.py</code> <pre><code>@runtime_checkable\nclass MakeBeam(Protocol):\n    \"\"\"\n    Function that makes the beam array.\n    If you don't need a beam just write a dummy function to return `jnp.array([[1]])`.\n    See docstring of `__call__` for details on the parameters and returns.\n    \"\"\"\n\n    def __call__(self: Self, dset_name: str, cfg: dict, info: dict) -&gt; Array:\n        \"\"\"\n        Parameters\n        ----------\n        dset_name : str\n            The name of the dataset to get file list for.\n        cfg : dict\n            The loaded `witcher` config.\n        info : dict\n            Dictionairy containing dataset information.\n\n        Returns\n        -------\n        beam : Array\n            The beam to be convolved with the model.\n            Should be a 2D array.\n        \"\"\"\n        ...\n</code></pre>"},{"location":"reference/dataset/#witch.dataset.MakeBeam.__call__","title":"<code>__call__(dset_name, cfg, info)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>dset_name</code> <code>str</code> <p>The name of the dataset to get file list for.</p> required <code>cfg</code> <code>dict</code> <p>The loaded <code>witcher</code> config.</p> required <code>info</code> <code>dict</code> <p>Dictionairy containing dataset information.</p> required <p>Returns:</p> Name Type Description <code>beam</code> <code>Array</code> <p>The beam to be convolved with the model. Should be a 2D array.</p> Source code in <code>witch/dataset.py</code> <pre><code>def __call__(self: Self, dset_name: str, cfg: dict, info: dict) -&gt; Array:\n    \"\"\"\n    Parameters\n    ----------\n    dset_name : str\n        The name of the dataset to get file list for.\n    cfg : dict\n        The loaded `witcher` config.\n    info : dict\n        Dictionairy containing dataset information.\n\n    Returns\n    -------\n    beam : Array\n        The beam to be convolved with the model.\n        Should be a 2D array.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/dataset/#witch.dataset.PostFit","title":"<code>PostFit</code>","text":"<p>               Bases: <code>Protocol</code></p> <p>Function that runs after all fitting stages are over. This is where you may want make some visualization or initial analysis of your data (ie. plot residuals, check statistical significance, etc.) You can also do nothing if you wish. See docstring of <code>__call__</code> for details on the parameters and returns.</p> Source code in <code>witch/dataset.py</code> <pre><code>@runtime_checkable\nclass PostFit(Protocol):\n    \"\"\"\n    Function that runs after all fitting stages are over.\n    This is where you may want make some visualization or initial analysis of your data\n    (ie. plot residuals, check statistical significance, etc.)\n    You can also do nothing if you wish.\n    See docstring of `__call__` for details on the parameters and returns.\n    \"\"\"\n\n    def __call__(\n        self: Self,\n        dset_name: str,\n        cfg: dict,\n        datavec: DataVec,\n        model: Model,\n        info: dict,\n    ):\n        \"\"\"\n        Parameters\n        ----------\n        dset_name : str\n            The name of the dataset to get file list for.\n        cfg : dict\n            The loaded `witcher` config.\n        datavec : DataVec\n            The `jitkasi` container for the data.\n            This is going to be `TODVec` for TODs\n            and `SolutionSet` for maps.\n        model : Model\n            The cluster model.\n            This will contain the final best fit parameters.\n        info : dict\n            Dictionairy containing dataset information.\n        \"\"\"\n        ...\n</code></pre>"},{"location":"reference/dataset/#witch.dataset.PostFit.__call__","title":"<code>__call__(dset_name, cfg, datavec, model, info)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>dset_name</code> <code>str</code> <p>The name of the dataset to get file list for.</p> required <code>cfg</code> <code>dict</code> <p>The loaded <code>witcher</code> config.</p> required <code>datavec</code> <code>DataVec</code> <p>The <code>jitkasi</code> container for the data. This is going to be <code>TODVec</code> for TODs and <code>SolutionSet</code> for maps.</p> required <code>model</code> <code>Model</code> <p>The cluster model. This will contain the final best fit parameters.</p> required <code>info</code> <code>dict</code> <p>Dictionairy containing dataset information.</p> required Source code in <code>witch/dataset.py</code> <pre><code>def __call__(\n    self: Self,\n    dset_name: str,\n    cfg: dict,\n    datavec: DataVec,\n    model: Model,\n    info: dict,\n):\n    \"\"\"\n    Parameters\n    ----------\n    dset_name : str\n        The name of the dataset to get file list for.\n    cfg : dict\n        The loaded `witcher` config.\n    datavec : DataVec\n        The `jitkasi` container for the data.\n        This is going to be `TODVec` for TODs\n        and `SolutionSet` for maps.\n    model : Model\n        The cluster model.\n        This will contain the final best fit parameters.\n    info : dict\n        Dictionairy containing dataset information.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/dataset/#witch.dataset.PostProc","title":"<code>PostProc</code>","text":"<p>               Bases: <code>Protocol</code></p> <p>Function that runs after the data vector is processed. (see <code>witch.fitter.process_tods</code> and <code>witch.fitter.process_maps</code>). This is where you may want make some visualization or initial analysis of your data (ie. make a map from your TODs, improve the noise model estimation, etc.) You can also do nothing if you wish. See docstring of <code>__call__</code> for details on the parameters and returns.</p> Source code in <code>witch/dataset.py</code> <pre><code>@runtime_checkable\nclass PostProc(Protocol):\n    \"\"\"\n    Function that runs after the data vector is processed.\n    (see `witch.fitter.process_tods` and `witch.fitter.process_maps`).\n    This is where you may want make some visualization or initial analysis of your data\n    (ie. make a map from your TODs, improve the noise model estimation, etc.)\n    You can also do nothing if you wish.\n    See docstring of `__call__` for details on the parameters and returns.\n    \"\"\"\n\n    def __call__(\n        self: Self,\n        dset_name: str,\n        cfg: dict,\n        datavec: DataVec,\n        model: Model,\n        info: dict,\n    ):\n        \"\"\"\n        Parameters\n        ----------\n        dset_name : str\n            The name of the dataset to get file list for.\n        cfg : dict\n            The loaded `witcher` config.\n        datavec : DataVec\n            The `jitkasi` container for the data.\n            This is going to be `TODVec` for TODs\n            and `SolutionSet` for maps.\n        model : Model\n            The cluster model.\n            At this point this will just be the initial state of the model.\n        info : dict\n            Dictionairy containing dataset information.\n        \"\"\"\n        ...\n</code></pre>"},{"location":"reference/dataset/#witch.dataset.PostProc.__call__","title":"<code>__call__(dset_name, cfg, datavec, model, info)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>dset_name</code> <code>str</code> <p>The name of the dataset to get file list for.</p> required <code>cfg</code> <code>dict</code> <p>The loaded <code>witcher</code> config.</p> required <code>datavec</code> <code>DataVec</code> <p>The <code>jitkasi</code> container for the data. This is going to be <code>TODVec</code> for TODs and <code>SolutionSet</code> for maps.</p> required <code>model</code> <code>Model</code> <p>The cluster model. At this point this will just be the initial state of the model.</p> required <code>info</code> <code>dict</code> <p>Dictionairy containing dataset information.</p> required Source code in <code>witch/dataset.py</code> <pre><code>def __call__(\n    self: Self,\n    dset_name: str,\n    cfg: dict,\n    datavec: DataVec,\n    model: Model,\n    info: dict,\n):\n    \"\"\"\n    Parameters\n    ----------\n    dset_name : str\n        The name of the dataset to get file list for.\n    cfg : dict\n        The loaded `witcher` config.\n    datavec : DataVec\n        The `jitkasi` container for the data.\n        This is going to be `TODVec` for TODs\n        and `SolutionSet` for maps.\n    model : Model\n        The cluster model.\n        At this point this will just be the initial state of the model.\n    info : dict\n        Dictionairy containing dataset information.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/dataset/#witch.dataset.PreProc","title":"<code>PreProc</code>","text":"<p>               Bases: <code>Protocol</code></p> <p>Function that runs before the data vector is processed. (see <code>witch.fitter.process_tods</code> and <code>witch.fitter.process_maps</code>). This is where you may want to compute something about the data's noise properties or some other statistic that may be useful to your analysis. You can also do nothing if you wish. See docstring of <code>__call__</code> for details on the parameters and returns.</p> Source code in <code>witch/dataset.py</code> <pre><code>@runtime_checkable\nclass PreProc(Protocol):\n    \"\"\"\n    Function that runs before the data vector is processed.\n    (see `witch.fitter.process_tods` and `witch.fitter.process_maps`).\n    This is where you may want to compute something about the data's noise properties\n    or some other statistic that may be useful to your analysis.\n    You can also do nothing if you wish.\n    See docstring of `__call__` for details on the parameters and returns.\n    \"\"\"\n\n    def __call__(\n        self: Self,\n        dset_name: str,\n        cfg: dict,\n        datavec: DataVec,\n        model: Model,\n        info: dict,\n    ):\n        \"\"\"\n        Parameters\n        ----------\n        dset_name : str\n            The name of the dataset to get file list for.\n        cfg : dict\n            The loaded `witcher` config.\n        datavec : DataVec\n            The `jitkasi` container for the data.\n            This is going to be `TODVec` for TODs\n            and `SolutionSet` for maps.\n        model : Model\n            The cluster model.\n            At this point this will just be the initial state of the model.\n        info : dict\n            Dictionairy containing dataset information.\n        \"\"\"\n        ...\n</code></pre>"},{"location":"reference/dataset/#witch.dataset.PreProc.__call__","title":"<code>__call__(dset_name, cfg, datavec, model, info)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>dset_name</code> <code>str</code> <p>The name of the dataset to get file list for.</p> required <code>cfg</code> <code>dict</code> <p>The loaded <code>witcher</code> config.</p> required <code>datavec</code> <code>DataVec</code> <p>The <code>jitkasi</code> container for the data. This is going to be <code>TODVec</code> for TODs and <code>SolutionSet</code> for maps.</p> required <code>model</code> <code>Model</code> <p>The cluster model. At this point this will just be the initial state of the model.</p> required <code>info</code> <code>dict</code> <p>Dictionairy containing dataset information.</p> required Source code in <code>witch/dataset.py</code> <pre><code>def __call__(\n    self: Self,\n    dset_name: str,\n    cfg: dict,\n    datavec: DataVec,\n    model: Model,\n    info: dict,\n):\n    \"\"\"\n    Parameters\n    ----------\n    dset_name : str\n        The name of the dataset to get file list for.\n    cfg : dict\n        The loaded `witcher` config.\n    datavec : DataVec\n        The `jitkasi` container for the data.\n        This is going to be `TODVec` for TODs\n        and `SolutionSet` for maps.\n    model : Model\n        The cluster model.\n        At this point this will just be the initial state of the model.\n    info : dict\n        Dictionairy containing dataset information.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/fitter/","title":"fitter","text":"<p>Master fitting and map making script. You typically want to run the <code>witcher</code> command instead of this.</p>"},{"location":"reference/fitter/#witch.fitter.deep_merge","title":"<code>deep_merge(a, b)</code>","text":"<p>Based on https://gist.github.com/angstwad/bf22d1822c38a92ec0a9?permalink_comment_id=3517209</p> Source code in <code>witch/fitter.py</code> <pre><code>def deep_merge(a: dict, b: dict) -&gt; dict:\n    \"\"\"\n    Based on https://gist.github.com/angstwad/bf22d1822c38a92ec0a9?permalink_comment_id=3517209\n    \"\"\"\n    result = deepcopy(a)\n    for bk, bv in b.items():\n        av = result.get(bk)\n        if isinstance(av, dict) and isinstance(bv, dict):\n            result[bk] = deep_merge(av, bv)\n        else:\n            result[bk] = deepcopy(bv)\n    return result\n</code></pre>"},{"location":"reference/fitter/#witch.fitter.load_config","title":"<code>load_config(start_cfg, cfg_path)</code>","text":"<p>We want to load a config and if it has the key \"base\", load that as well and merge them. We only want to take things from base that are not in the original config so we merge the original into the newly loaded one.</p> Source code in <code>witch/fitter.py</code> <pre><code>def load_config(start_cfg, cfg_path):\n    \"\"\"\n    We want to load a config and if it has the key \"base\",\n    load that as well and merge them.\n    We only want to take things from base that are not in the original config\n    so we merge the original into the newly loaded one.\n    \"\"\"\n    with open(cfg_path) as file:\n        new_cfg = yaml.safe_load(file)\n    cfg = deep_merge(new_cfg, start_cfg)\n    if \"base\" in new_cfg:\n        base_path = new_cfg[\"base\"]\n        if not os.path.isabs(base_path):\n            base_path = os.path.join(os.path.dirname(cfg_path), base_path)\n        return load_config(cfg, base_path)\n    return cfg\n</code></pre>"},{"location":"reference/fitter/#witch.fitter.print_once","title":"<code>print_once(*args)</code>","text":"<p>Helper function to print only once when running with MPI. Only the rank 0 process will print.</p> <p>Parameters:</p> Name Type Description Default <code>*args</code> <code>Unpack[tuple[Any, ...]]</code> <p>Arguments to pass to print.</p> <code>()</code> Source code in <code>witch/fitter.py</code> <pre><code>def print_once(*args: Unpack[tuple[Any, ...]]):\n    \"\"\"\n    Helper function to print only once when running with MPI.\n    Only the rank 0 process will print.\n\n    Parameters\n    ----------\n    *args : Unpack[tuple[Any, ...]]\n        Arguments to pass to print.\n    \"\"\"\n    if comm.Get_rank() == 0:\n        print(*args)\n        sys.stdout.flush()\n</code></pre>"},{"location":"reference/fitting/","title":"fitting","text":""},{"location":"reference/fitting/#witch.fitting.fit_dataset","title":"<code>fit_dataset(model, dataset, maxiter=10, chitol=1e-05)</code>","text":"<p>Fit a model to TODs. This uses a modified Levenberg\u2013Marquardt fitter with flat priors. This function is MPI aware.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>Model</code> <p>The model object that defines the model and grid we are fitting with.</p> required <code>dataset</code> <code>DataSet</code> <p>The dataset to fit. The <code>dataset.datavec.comm</code> object is used to fit in an MPI aware way.</p> required <code>maxiter</code> <code>int</code> <p>The maximum number of iterations to fit.</p> <code>10</code> <code>chitol</code> <code>float</code> <p>The delta chisq to use as the convergence criteria.</p> <code>1e-5</code> <p>Returns:</p> Name Type Description <code>model</code> <code>Model</code> <p>Model with the final set of fit parameters, errors, and chisq.</p> <code>final_iter</code> <code>int</code> <p>The number of iterations the fitter ran for.</p> <code>delta_chisq</code> <code>float</code> <p>The final delta chisq.</p> Source code in <code>witch/fitting.py</code> <pre><code>@partial(jax.jit, static_argnums=(2, 3))\ndef fit_dataset(\n    model: Model,\n    dataset: DataSet,\n    maxiter: int = 10,\n    chitol: float = 1e-5,\n) -&gt; tuple[Model, int, float]:\n    \"\"\"\n    Fit a model to TODs.\n    This uses a modified Levenberg\u2013Marquardt fitter with flat priors.\n    This function is MPI aware.\n\n    Parameters\n    ----------\n    model : Model\n        The model object that defines the model and grid we are fitting with.\n    dataset : DataSet\n        The dataset to fit.\n        The `dataset.datavec.comm` object is used to fit in an MPI aware way.\n    maxiter : int, default: 10\n        The maximum number of iterations to fit.\n    chitol : float, default: 1e-5\n        The delta chisq to use as the convergence criteria.\n\n    Returns\n    -------\n    model : Model\n        Model with the final set of fit parameters, errors, and chisq.\n    final_iter : int\n        The number of iterations the fitter ran for.\n    delta_chisq : float\n        The final delta chisq.\n    \"\"\"\n    if dataset.mode not in [\"tod\", \"map\"]:\n        raise ValueError(\"Invalid mode\")\n    zero = jnp.array(0.0)\n\n    def _cond_func(val):\n        i, delta_chisq, lmd, *_ = val\n        iterbool = jax.lax.lt(i, maxiter)\n        chisqbool = jax.lax.ge(delta_chisq, chitol) + jax.lax.gt(lmd, zero)\n        return iterbool * chisqbool\n\n    def _body_func(val):\n        i, delta_chisq, lmd, model, curve, grad = val\n        curve_use = curve.at[:].add(lmd * jnp.diag(jnp.diag(curve)))\n        # Get the step\n        step = jnp.dot(invscale(curve_use), grad)\n        new_pars, to_fit = _prior_pars_fit(\n            model.priors, model.pars.at[:].add(step), jnp.array(model.to_fit)\n        )\n        # Get errs\n        errs = jnp.where(to_fit, jnp.sqrt(jnp.diag(invscale(curve_use))), 0)\n        # Now lets get an updated model\n        new_model = deepcopy(model).update(new_pars, model.errs, model.chisq)\n        new_chisq, new_grad, new_curve = dataset.objective(\n            new_model, dataset.datavec, dataset.mode, True, True, True\n        )\n        new_model = new_model.update(new_pars, errs, new_chisq)\n\n        new_delta_chisq = model.chisq - new_model.chisq\n        model, grad, curve, delta_chisq, lmd = jax.lax.cond(\n            new_delta_chisq &gt; 0,\n            _success,\n            _failure,\n            model,\n            new_model,\n            grad,\n            new_grad,\n            curve,\n            new_curve,\n            delta_chisq,\n            new_delta_chisq,\n            lmd,\n        )\n\n        return (i + 1, delta_chisq, lmd, model, curve, grad)\n\n    pars, _ = _prior_pars_fit(model.priors, model.pars, jnp.array(model.to_fit))\n    model = model.update(pars, model.errs, model.chisq)\n    chisq, grad, curve = dataset.objective(\n        model, dataset.datavec, dataset.mode, True, True, True\n    )\n    model = model.update(pars, model.errs, chisq)\n    i, delta_chisq, _, model, *_ = jax.lax.while_loop(\n        _cond_func, _body_func, (0, jnp.inf, zero, model, curve, grad)\n    )\n\n    return model, i, delta_chisq\n</code></pre>"},{"location":"reference/fitting/#witch.fitting.hmc","title":"<code>hmc(params, log_prob, log_prob_grad, num_steps, num_leaps, step_size, comm, key)</code>","text":"<p>Runs Hamilonian Monte Carlo using a leapfrog integrator to approximate Hamilonian dynamics. This is a naive implementaion that will be replaced in the future.</p> <p>The parallelism model employed here is different that most samplers where each task runs a subset of the chain, instead since the rest of WITCH employs a model where the data is distributed across tasks we do that here as well. In this model the chain evolves simultaneously in all tasks, but only rank 0 actually stores the chain.</p> <p>Parameters:</p> Name Type Description Default <code>params</code> <code>Array</code> <p>The initial parameters to start the chain at.</p> required <code>log_prob</code> <code>Callable[[Array], Array]</code> <p>Function that returns the log probability of the model for a given set of params. This should take <code>params</code> as its first arguments, all other arguments should be fixed ahead of time (ie: using <code>functools.partial</code>).</p> required <code>log_prob_grad</code> <code>Callable[[Array], Array]</code> <p>Function that returns the gradient log probability of the model for a given set of params. This should take <code>params</code> as its first arguments, all other arguments should be fixed ahead of time (ie: using <code>functools.partial</code>). The returned gradient should have shape <code>(len(params),)</code>.</p> required <code>num_steps</code> <code>int</code> <p>The number of steps to run the chain for.</p> required <code>num_leaps</code> <code>int</code> <p>The number of leapfrog steps to run at each step of the chain.</p> required <code>step_size</code> <code>float</code> <p>The step size to use. At each leapfrog step the parameters will evolve by <code>step_size</code>*<code>momentum</code>.</p> required <code>comm</code> <code>Intracomm</code> <p>The MPI comm object to use.</p> required <p>Returns:</p> Name Type Description <code>chain</code> <code>Array</code> <p>The chain of samples. Will have shape <code>(num_steps, len(params))</code> in the rank 0 task. Note that on tasks with rank other than 0 the actual chain is not returned, instead a dummy array of size <code>(0,)</code> is returned.</p> Source code in <code>witch/fitting.py</code> <pre><code>def hmc(\n    params: jax.Array,\n    log_prob: Callable[[jax.Array], jax.Array],\n    log_prob_grad: Callable[[jax.Array], jax.Array],\n    num_steps: int,\n    num_leaps: int,\n    step_size: float,\n    comm: MPI.Intracomm,\n    key: jax.Array,\n) -&gt; jax.Array:\n    \"\"\"\n    Runs Hamilonian Monte Carlo using a leapfrog integrator to approximate Hamilonian dynamics.\n    This is a naive implementaion that will be replaced in the future.\n\n    The parallelism model employed here is different that most samplers where each task runs\n    a subset of the chain, instead since the rest of WITCH employs a model where the data is\n    distributed across tasks we do that here as well.\n    In this model the chain evolves simultaneously in all tasks,\n    but only rank 0 actually stores the chain.\n\n    Parameters\n    ----------\n    params : jax.Array\n        The initial parameters to start the chain at.\n    log_prob : Callable[[jax.Array], jax.Array]\n        Function that returns the log probability of the model\n        for a given set of params. This should take `params` as its\n        first arguments, all other arguments should be fixed ahead of time\n        (ie: using `functools.partial`).\n    log_prob_grad : Callable[[jax.Array], jax.Array]\n        Function that returns the gradient log probability of the model\n        for a given set of params. This should take `params` as its\n        first arguments, all other arguments should be fixed ahead of time\n        (ie: using `functools.partial`). The returned gradient should have\n        shape `(len(params),)`.\n    num_steps : int\n        The number of steps to run the chain for.\n    num_leaps : int\n        The number of leapfrog steps to run at each step of the chain.\n    step_size : float\n        The step size to use.\n        At each leapfrog step the parameters will evolve by `step_size`*`momentum`.\n    comm : MPI.Intracomm\n        The MPI comm object to use.\n\n    Returns\n    -------\n    chain : jax.Array\n        The chain of samples.\n        Will have shape `(num_steps, len(params))` in the rank 0 task.\n        Note that on tasks with rank other than 0 the actual\n        chain is not returned, instead a dummy array of size `(0,)` is\n        returned.\n    \"\"\"\n    rank = comm.Get_rank()\n    vnorm = jax.vmap(\n        partial(jax.random.normal, shape=params[0].shape, dtype=params.dtype)\n    )\n    npar = len(params)\n    ones = jnp.ones(npar, dtype=bool)\n\n    @jax.jit\n    def _leap(_, args):\n        params, momentum = args\n        momentum = momentum.at[:].add(0.5 * step_size * log_prob_grad(params))  # kick\n        params = params.at[:].add(step_size * momentum)  # drift\n        momentum = momentum.at[:].add(0.5 * step_size * log_prob_grad(params))  # kick\n\n        return params, momentum\n\n    @jax.jit\n    def _sample(key, params):\n        token = mpi4jax.barrier(comm=comm)\n        key, token = mpi4jax.bcast(key, 0, comm=comm, token=token)\n        key, uniform_key = jax.random.split(key, 2)\n\n        # generate random momentum\n        momentum = vnorm(jax.random.split(key, npar))\n        new_params, new_momentum = jax.lax.fori_loop(\n            0, num_leaps, _leap, (params, momentum)\n        )\n\n        # MH correction\n        dpe = log_prob(new_params) - log_prob(params)\n        dke = -0.5 * (jnp.sum(new_momentum**2) - jnp.sum(momentum**2))\n        log_accept = dke + dpe\n        accept_prob = jnp.minimum(jnp.exp(log_accept), 1)\n        accept = jax.random.uniform(uniform_key) &lt; accept_prob\n        params = jax.lax.select(accept * ones, new_params, params)\n\n        return key, params, accept_prob\n\n    t0 = time.time()\n    l_sample = _sample.lower(key, params)\n    c_sample = l_sample.compile()\n    t1 = time.time()\n    if rank == 0:\n        print(f\"Compiled MC sample function in {t1-t0} s\")\n\n    chain = []\n    accept_prob = []\n    for _ in tqdm(range(num_steps), disable=(rank != 0)):\n        key, params, prob = c_sample(key, params)\n        if rank == 0:\n            chain += [params]\n            accept_prob += [prob]\n    if rank == 0:\n        chain = jnp.vstack(chain)\n        accept_prob = jnp.array(accept_prob)\n        print(f\"Accepted {accept_prob.mean():.2%} of samples\")\n    else:\n        chain = jnp.zeros(0)\n    return chain\n</code></pre>"},{"location":"reference/fitting/#witch.fitting.invsafe","title":"<code>invsafe(matrix, thresh=1e-14)</code>","text":"<p>Safe SVD based psuedo-inversion of the matrix. This zeros out modes that are too small when inverting. Use with caution in cases where you really care about what the inverse is.</p> <p>Parameters:</p> Name Type Description Default <code>matrix</code> <code>Array</code> <p>The matrix to invert. Should be a <code>(n, n)</code> array.</p> required <code>thresh</code> <code>float</code> <p>Threshold at which to zero out a mode.</p> <code>1e-14</code> <p>Returns:</p> Name Type Description <code>invmat</code> <code>Array</code> <p>The inverted matrix. Same shape as <code>matrix</code>.</p> Source code in <code>witch/fitting.py</code> <pre><code>@jax.jit\ndef invsafe(matrix: jax.Array, thresh: float = 1e-14) -&gt; jax.Array:\n    \"\"\"\n    Safe SVD based psuedo-inversion of the matrix.\n    This zeros out modes that are too small when inverting.\n    Use with caution in cases where you really care about what the inverse is.\n\n    Parameters\n    ----------\n    matrix : jax.Array\n        The matrix to invert.\n        Should be a `(n, n)` array.\n    thresh : float, default: 1e-14\n        Threshold at which to zero out a mode.\n\n    Returns\n    -------\n    invmat: jax.Array\n        The inverted matrix.\n        Same shape as `matrix`.\n    \"\"\"\n    u, s, v = jnp.linalg.svd(matrix, False)\n    s_inv = jnp.array(jnp.where(jnp.abs(s) &lt; thresh * jnp.max(s), 0, 1 / s))\n\n    return jnp.dot(jnp.transpose(v), jnp.dot(jnp.diag(s_inv), jnp.transpose(u)))\n</code></pre>"},{"location":"reference/fitting/#witch.fitting.invscale","title":"<code>invscale(matrix, thresh=1e-14)</code>","text":"<p>Invert and rescale a matrix by the diagonal. This uses <code>invsafe</code> for the inversion.</p> <p>Parameters:</p> Name Type Description Default <code>Parameters</code> required <code>matrix</code> <code>Array</code> <p>The matrix to invert and sxane. Should be a <code>(n, n)</code> array.</p> required <code>thresh</code> <code>float</code> <p>Threshold for <code>invsafe</code>. See that function for more info.</p> <code>1e-14</code> <p>Returns:</p> Name Type Description <code>invmat</code> <code>Array</code> <p>The inverted and rescaled matrix. Same shape as <code>matrix</code>.</p> Source code in <code>witch/fitting.py</code> <pre><code>@jax.jit\ndef invscale(matrix: jax.Array, thresh: float = 1e-14) -&gt; jax.Array:\n    \"\"\"\n    Invert and rescale a matrix by the diagonal.\n    This uses `invsafe` for the inversion.\n\n    Parameters\n    ----------\n    Parameters\n    ----------\n    matrix : jax.Array\n        The matrix to invert and sxane.\n        Should be a `(n, n)` array.\n    thresh : float, default: 1e-14\n        Threshold for `invsafe`.\n        See that function for more info.\n\n    Returns\n    -------\n    invmat: jax.Array\n        The inverted and rescaled matrix.\n        Same shape as `matrix`.\n    \"\"\"\n    diag = jnp.diag(matrix)\n    vec = jnp.array(jnp.where(diag != 0, 1.0 / jnp.sqrt(jnp.abs(diag)), 1e-10))\n    mm = jnp.outer(vec, vec)\n\n    return mm * invsafe(mm * matrix, thresh)\n</code></pre>"},{"location":"reference/fitting/#witch.fitting.run_mcmc","title":"<code>run_mcmc(model, dataset, num_steps=5000, num_leaps=10, step_size=0.02, sample_which=-1)</code>","text":"<p>Run MCMC using the <code>emcee</code> package to estimate the posterior for our model. Currently this function only support flat priors, but more will be supported down the line. In order to ensure accuracy of the noise model used, it is reccomended that you run at least one round of <code>fit_tods</code> followed by noise reestimation before this function.</p> <p>This is MPI aware. Eventually this will be replaced with something more jaxy.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>Model</code> <p>The model to run MCMC on. We expect that all parameters in this model have priors defined.</p> required <code>dataset</code> <code>DataSet</code> <p>The dataset to compute the model posterior with. The <code>dataset.datavec.comm</code> object is used to fit in an MPI aware way.</p> required <code>num_steps</code> <code>int</code> <p>The number of steps to run MCMC for.</p> <code>5000</code> <code>num_leaps</code> <code>int</code> <p>The number of leapfrog steps to take at each sample.</p> <code>10</code> <code>step_size</code> <code>float</code> <p>The step size to use in the leapfrog algorithm. This should be tuned to get an acceptance fraction of ~.65.</p> <code>0.02</code> <code>default</code> <code>float</code> <p>The step size to use in the leapfrog algorithm. This should be tuned to get an acceptance fraction of ~.65.</p> <code>0.02</code> <code>sample_which</code> <code>int</code> <p>Sets which parameters to sample. If this is &gt;= 0 then we will sample which ever parameters were fit in that round of fitting. If this is -1 then we will sample which ever parameters were fit in the last round of fitting. If this is -2 then any parameters that were ever fit will be sampled. If this is &lt;= -3 or &gt;= <code>model.n_rounds</code> then all parameters are sampled.</p> <code>-1,</code> <p>Returns:</p> Name Type Description <code>model</code> <code>Model</code> <p>The model with MCMC estimated parameters and errors. The parameters are estimated as the mean of the samples. The errors are estimated as the standard deviation. This also has the chi-squared of the estimated parameters.</p> <code>flat_samples</code> <code>Array</code> <p>Array of samples from running MCMC.</p> Source code in <code>witch/fitting.py</code> <pre><code>def run_mcmc(\n    model: Model,\n    dataset: DataSet,\n    num_steps: int = 5000,\n    num_leaps: int = 10,\n    step_size: float = 0.02,\n    sample_which: int = -1,\n) -&gt; tuple[Model, jax.Array]:\n    \"\"\"\n    Run MCMC using the `emcee` package to estimate the posterior for our model.\n    Currently this function only support flat priors, but more will be supported\n    down the line. In order to ensure accuracy of the noise model used, it is\n    reccomended that you run at least one round of `fit_tods` followed by noise\n    reestimation before this function.\n\n    This is MPI aware.\n    Eventually this will be replaced with something more jaxy.\n\n    Parameters\n    ----------\n    model : Model\n        The model to run MCMC on.\n        We expect that all parameters in this model have priors defined.\n    dataset : DataSet\n        The dataset to compute the model posterior with.\n        The `dataset.datavec.comm` object is used to fit in an MPI aware way.\n    num_steps : int, default: 5000\n        The number of steps to run MCMC for.\n    num_leaps: int, default: 10\n        The number of leapfrog steps to take at each sample.\n    step_size, default: .02\n        The step size to use in the leapfrog algorithm.\n        This should be tuned to get an acceptance fraction of ~.65.\n    sample_which : int, default: -1,\n        Sets which parameters to sample.\n        If this is &gt;= 0 then we will sample which ever parameters were\n        fit in that round of fitting.\n        If this is -1 then we will sample which ever parameters were fit\n        in the last round of fitting.\n        If this is -2 then any parameters that were ever fit will be sampled.\n        If this is &lt;= -3 or &gt;= `model.n_rounds` then all parameters are sampled.\n\n    Returns\n    -------\n    model : Model\n        The model with MCMC estimated parameters and errors.\n        The parameters are estimated as the mean of the samples.\n        The errors are estimated as the standard deviation.\n        This also has the chi-squared of the estimated parameters.\n    flat_samples : jax.Array\n        Array of samples from running MCMC.\n\n    \"\"\"\n    token = mpi4jax.barrier(comm=dataset.datavec.comm)\n    rank = dataset.datavec.comm.Get_rank()\n\n    if sample_which &gt;= 0 and sample_which &lt; model.n_rounds:\n        model.cur_round = sample_which\n        to_fit = model.to_fit\n    elif sample_which == -1:\n        to_fit = model.to_fit\n    elif sample_which == -2:\n        to_fit = model.to_fit_ever\n    else:\n        to_fit = jnp.ones_like(model.to_fit_ever, dtype=bool)\n    to_fit = jnp.array(to_fit)\n    model = model.add_round(jnp.array(to_fit))\n\n    init_pars = jnp.array(model.pars)\n    init_errs = jnp.zeros_like(model.pars)\n    final_pars = init_pars.copy()\n    final_errs = init_errs.copy()\n\n    prior_l, prior_u = model.priors\n    scale = (jnp.abs(prior_l) + jnp.abs(prior_u)) / 2.0\n    scale = jnp.where(scale == 0, 1, scale)\n    init_pars = init_pars.at[:].multiply(1.0 / scale)\n    npar = jnp.sum(to_fit)\n\n    def _is_inf(pars, model):\n        _ = (pars, model)\n        return -1 * jnp.inf\n\n    def _not_inf(pars, model):\n        pars, _ = mpi4jax.bcast(pars, 0, comm=dataset.datavec.comm)\n        temp_model = model.update(pars, init_errs, model.chisq)\n        chisq, *_ = dataset.objective(\n            temp_model, dataset.datavec, dataset.mode, True, False, False\n        )\n        log_like = -0.5 * chisq\n        return log_like\n\n    @jax.jit\n    def _log_prob(pars, model=model, init_pars=init_pars):\n        full_pars = init_pars.at[to_fit].set(pars)\n        full_pars = full_pars.at[:].multiply(scale)\n        _, in_bounds = _prior_pars_fit(model.priors, full_pars, jnp.array(model.to_fit))\n        log_prior = jnp.sum(\n            jnp.where(in_bounds.at[model.to_fit].get(), 0, -1 * jnp.inf)\n        )\n        return jax.lax.cond(\n            jnp.isfinite(log_prior),\n            _not_inf,\n            _is_inf,\n            full_pars,\n            model,\n        )\n\n    def _is_inf_grad(pars, model, scale):\n        _ = (pars, model, scale)\n        return jnp.inf * jnp.ones(npar)\n\n    def _not_inf_grad(pars, model, scale):\n        pars, _ = mpi4jax.bcast(pars, 0, comm=dataset.datavec.comm)\n        temp_model = model.update(pars, init_errs, model.chisq)\n        _, grad, _ = dataset.objective(\n            temp_model, dataset.datavec, dataset.mode, False, True, False\n        )\n        grad = grad.at[:].multiply(scale)\n        return grad.at[to_fit].get().ravel()\n\n    @jax.jit\n    def _log_prob_grad(pars, model=model, init_pars=init_pars):\n        full_pars = init_pars.at[to_fit].set(pars)\n        full_pars = full_pars.at[:].multiply(scale)\n        _, in_bounds = _prior_pars_fit(model.priors, full_pars, jnp.array(model.to_fit))\n        log_prior = jnp.sum(jnp.where(in_bounds.at[to_fit].get(), 0, -1 * jnp.inf))\n        return jax.lax.cond(\n            jnp.isfinite(log_prior),\n            _not_inf_grad,\n            _is_inf_grad,\n            full_pars,\n            model,\n            scale,\n        )\n\n    key = jax.random.PRNGKey(0)\n    key, token = mpi4jax.bcast(key, 0, comm=dataset.datavec.comm, token=token)\n    chain = hmc(\n        init_pars.at[to_fit].get().ravel(),\n        _log_prob,\n        _log_prob_grad,\n        num_steps=num_steps,\n        num_leaps=num_leaps,\n        step_size=step_size,\n        comm=dataset.datavec.comm,\n        key=key,\n    )\n    flat_samples = chain.at[:].multiply(scale.at[to_fit].get())\n    if rank == 0:\n        final_pars = final_pars.at[to_fit].set(jnp.median(flat_samples, axis=0).ravel())\n        final_errs = final_errs.at[to_fit].set(jnp.std(flat_samples, axis=0).ravel())\n    final_pars, token = mpi4jax.bcast(\n        final_pars, 0, comm=dataset.datavec.comm, token=token\n    )\n    final_errs, _ = mpi4jax.bcast(final_errs, 0, comm=dataset.datavec.comm, token=token)\n    model = model.update(\n        final_pars.block_until_ready(), final_errs.block_until_ready(), model.chisq\n    )\n    chisq, *_ = dataset.objective(\n        model, dataset.datavec, dataset.mode, True, False, False\n    )\n    model = model.update(final_pars, final_errs, chisq)\n\n    return model, flat_samples\n</code></pre>"},{"location":"reference/forward_modeling/","title":"forward_modeling","text":"<p>Functions for performing forward modeling</p>"},{"location":"reference/forward_modeling/#witch.forward_modeling.get_chis","title":"<code>get_chis(m, idx, idy, rhs, v, weight, dd=None)</code>","text":"<p>A faster, but more importantly much less memory intensive, way to get chis. The idea is \\({\\chi}^{2} = (d-Am)^T N^{-1} (d-Am)\\). Previously we would calculate the residuals \\(d-Am\\) and calculate directly. However \\(d-Am\\) has shape [ndet, nsamp], which is very big. \\(m\\) has shape [nx, ny], much smaller. \\(A\\), the pointing reconstruction, can be encapsulated into a few pars. Therefore if we can do everthing in map shape, we save a lot on the ammount of stuff we need to put on the GPU. We can expand \\({\\chi}^{2}\\) as</p> \\[ d^T N^{-1} d -2d^T N^{-1} A m + m^T A^T N^{-1} A m = dd - 2(m \\cdot rhs) + mm \\] <p>the first term only has to do with the data. If we care about the absolute value of \\({\\chi}^2\\), which we do at the end, then we can include it in calculation. For MCMC however, we only care about the relative delta chi2 between models. So we can drop that term. For the other terms</p> \\[ mm = m^T A^T N^{-1} A m \\] <p>This term is essentially what we've been doing before, except that m is now in map shape, whereas before m was in tod shape so we essentially had \\(Am\\). So we need to do \\(Am\\), but this is in general fast and Jon has a very fast way of doing it. Finally rhs need only be computed once, and while it is an additional thing to put on the gpu it is small, map shape.</p> <p>Parameters:</p> Name Type Description Default <code>m</code> <code>NDArray[floating]</code> <p>The model evaluated at all the map pixels</p> required <code>idx</code> <code>NDArray[floating]</code> <p>tod.info[\"model_idx\"], the x index output by tod_to_index</p> required <code>idy</code> <code>NDArray[floating]</code> <p>tod.info[\"model_idy\"], the y index output by tod_to_index</p> required <code>rhs</code> <code>NDArray[floating]</code> <p>The map output of todvec.make_rhs. Note this is how the data enters into the chi2 calc.</p> required <code>v</code> <code>NDArray[floating]</code> <p>The right singular vectors for the noise SVD. These rotate the data into the basis of the SVD.</p> required <code>weight</code> <code>NDArray[floating]</code> <p>The noise weights, in fourier space, SVD decomposed.</p> required <code>dd</code> <code>None | floating</code> <p>Optional chi2 from dd. Not necessary for MCMC but is important for evaluating goodness of fit.</p> <code>None</code> Outputs <p>chi2 : np.floating     The chi2 of the model m to the data.</p> Source code in <code>witch/forward_modeling.py</code> <pre><code>@jax.jit\ndef get_chis(m, idx, idy, rhs, v, weight, dd=None):\n    r\"\"\"\n    A faster, but more importantly much less memory intensive, way to get chis.\n    The idea is ${\\chi}^{2} = (d-Am)^T N^{-1} (d-Am)$. Previously we would calculate the residuals $d-Am$\n    and calculate directly. However $d-Am$ has shape [ndet, nsamp], which is very big. $m$ has shape\n    [nx, ny], much smaller. $A$, the pointing reconstruction, can be encapsulated into a few pars.\n    Therefore if we can do everthing in map shape, we save a lot on the ammount of stuff we\n    need to put on the GPU. We can expand ${\\chi}^{2}$ as\n\n    $$\n    d^T N^{-1} d -2d^T N^{-1} A m + m^T A^T N^{-1} A m = dd - 2(m \\cdot rhs) + mm\n    $$\n\n    the first term only has to do with the data. If we care about the absolute value of ${\\chi}^2$,\n    which we do at the end, then we can include it in calculation. For MCMC however, we only\n    care about the relative delta chi2 between models. So we can drop that term. For the other\n    terms\n\n    $$\n    mm = m^T A^T N^{-1} A m\n    $$\n\n    This term is essentially what we've been doing before, except that m is now in map shape,\n    whereas before m was in tod shape so we essentially had $Am$. So we need to do $Am$, but this is\n    in general fast and Jon has a very fast way of doing it. Finally rhs need only be computed\n    once, and while it is an additional thing to put on the gpu it is small, map shape.\n\n    Parameters\n    ----------\n    m : NDArray[np.floating]\n        The model evaluated at all the map pixels\n    idx : NDArray[np.floating]\n        tod.info[\"model_idx\"], the x index output by tod_to_index\n    idy : NDArray[np.floating]\n        tod.info[\"model_idy\"], the y index output by tod_to_index\n    rhs : NDArray[np.floating]\n        The map output of todvec.make_rhs. Note this is how the data enters into the chi2 calc.\n    v : NDArray[np.floating]\n        The right singular vectors for the noise SVD. These rotate the data into the basis of\n        the SVD.\n    weight : NDArray[np.floating]\n        The noise weights, in fourier space, SVD decomposed.\n    dd : None | np.floating\n        Optional chi2 from dd. Not necessary for MCMC but is important for evaluating goodness\n        of fit.\n\n    Outputs\n    -------\n    chi2 : np.floating\n        The chi2 of the model m to the data.\n    \"\"\"\n\n    model = m.at[idy.astype(int), idx.astype(int)].get(mode=\"fill\", fill_value=0)\n\n    # model = model.at[:,0].set((jnp.sqrt(0.5)*model)[:,0]) #This doesn't actually do anything\n    # model = model.at[:,-1].set((jnp.sqrt(0.5)*model)[:,-1])\n    model_rot = jnp.dot(v, model)\n    tmp = jnp.hstack(\n        [model_rot, jnp.fliplr(model_rot[:, 1:-1])]\n    )  # mirror pred so we can do dct of first kind\n    predft = jnp.real(jnp.fft.rfft(tmp, axis=1))\n    nn = predft.shape[1]\n\n    chisq = (\n        jnp.sum(weight[:, :nn] * predft**2) - 2 * jnp.dot(rhs.ravel(), m.ravel()) / 2\n    )  # Man IDK about this factor of 2\n\n    return chisq\n</code></pre>"},{"location":"reference/forward_modeling/#witch.forward_modeling.sample","title":"<code>sample(model_params, xyz, beam, params, tods)</code>","text":"<p>Generate a model realization and compute the chis of that model to data.</p> <p>Arguements:</p> <pre><code>tods: Array of tod parameters. See prep tods\n\nparams: model parameters\n\nmodel_params: number of each model componant\n\nxyz: grid to evaluate model at\n\nbeam: Beam to smooth by\n</code></pre> <p>Returns:</p> <pre><code>chi2: the chi2 difference of the model to the tods\n</code></pre> Source code in <code>witch/forward_modeling.py</code> <pre><code>def sample(model_params, xyz, beam, params, tods):  # , model_params, xyz, beam):\n    \"\"\"\n    Generate a model realization and compute the chis of that model to data.\n\n    Arguements:\n\n        tods: Array of tod parameters. See prep tods\n\n        params: model parameters\n\n        model_params: number of each model componant\n\n        xyz: grid to evaluate model at\n\n        beam: Beam to smooth by\n\n    Returns:\n\n        chi2: the chi2 difference of the model to the tods\n\n    \"\"\"\n    log_like = 0\n    n_iso, n_gnfw, n_gauss, n_egauss, n_uni, n_expo, n_power, n_power_cos = model_params\n\n    m = model(\n        xyz,\n        n_iso,\n        n_gnfw,\n        n_gauss,\n        n_egauss,\n        n_uni,\n        n_expo,\n        n_power,\n        n_power_cos,\n        -2.5e-05,\n        beam,\n        params,\n    )\n\n    for i, tod in enumerate(tods):\n        x, y, rhs, v, weight, norm = tod  # unravel tod\n\n        log_like += jget_chis(m, x, y, rhs, v, weight) / norm\n\n    return log_like\n</code></pre>"},{"location":"reference/grid/","title":"grid","text":"<p>Functions for building and working with the model grid.</p>"},{"location":"reference/grid/#witch.grid.make_grid","title":"<code>make_grid(r_map, dx, dy=None, dz=None, x0=0, y0=0)</code>","text":"<p>Make coordinate grids to build models in. All grids are sparse and are <code>int(2*r_map / dr)</code> in each the non-sparse dimension.</p> <p>Parameters:</p> Name Type Description Default <code>r_map</code> <code>float</code> <p>Size of grid radially.</p> required <code>dx</code> <code>float</code> <p>Grid resolution in x, should be in same units as r_map.</p> required <code>dy</code> <code>Optional[float]</code> <p>Grid resolution in y, should be in same units as r_map. If None then dy is set to dx.</p> <code>None</code> <code>dz</code> <code>Optional[float]</code> <p>Grid resolution in z, should be in same units as r_map. If None then dz is set to dx.</p> <code>None</code> <code>x0</code> <code>float</code> <p>Origin of grid in RA, assumed to be in same units as r_map.</p> <code>0</code> <code>y0</code> <code>float</code> <p>Origin of grid in Dec, assumed to be in same units as r_map.</p> <code>0</code> <p>Returns:</p> Name Type Description <code>x</code> <code>Array</code> <p>Grid of x coordinates in same units as r_map. Has shape (`int(2*r_map / dr), 1, 1).</p> <code>y</code> <code>Array</code> <p>Grid of y coordinates in same units as r_map. Has shape (1, `int(2*r_map / dr), 1).</p> <code>z</code> <code>Array</code> <p>Grid of z coordinates in same units as r_map. Has shape (1, 1, <code>int(2*r_map / dr)</code>).</p> <code>x0</code> <code>float</code> <p>Origin of grid in RA, in same units as r_map.</p> <code>y0</code> <code>float</code> <p>Origin of grid in Dec, in same units as r_map.</p> Source code in <code>witch/grid.py</code> <pre><code>def make_grid(\n    r_map: float,\n    dx: float,\n    dy: Optional[float] = None,\n    dz: Optional[float] = None,\n    x0: float = 0,\n    y0: float = 0,\n) -&gt; Grid:\n    \"\"\"\n    Make coordinate grids to build models in.\n    All grids are sparse and are `int(2*r_map / dr)` in each the non-sparse dimension.\n\n    Parameters\n    ----------\n    r_map : float\n        Size of grid radially.\n    dx : float\n        Grid resolution in x, should be in same units as r_map.\n    dy : Optional[float], default: None\n        Grid resolution in y, should be in same units as r_map.\n        If None then dy is set to dx.\n    dz : Optional[float], default: None\n        Grid resolution in z, should be in same units as r_map.\n        If None then dz is set to dx.\n    x0 : float, default: 0\n        Origin of grid in RA, assumed to be in same units as r_map.\n    y0 : float, default: 0\n        Origin of grid in Dec, assumed to be in same units as r_map.\n\n    Returns\n    -------\n    x : jax.Array\n        Grid of x coordinates in same units as r_map.\n        Has shape (`int(2*r_map / dr), 1, 1).\n    y : jax.Array\n        Grid of y coordinates in same units as r_map.\n        Has shape (1, `int(2*r_map / dr), 1).\n    z : jax.Array\n        Grid of z coordinates in same units as r_map.\n        Has shape (1, 1, `int(2*r_map / dr)`).\n    x0 : float\n        Origin of grid in RA, in same units as r_map.\n    y0 : float\n        Origin of grid in Dec, in same units as r_map.\n    \"\"\"\n    if dy is None:\n        dy = dx\n    if dz is None:\n        dz = dx\n\n    # Make grid with resolution dr and size r_map\n    x = (\n        jnp.linspace(-1 * r_map, r_map, 2 * int(r_map / dx))\n        / jnp.cos(y0 / rad_to_arcsec)\n        + x0\n    )\n    y = jnp.linspace(-1 * r_map, r_map, 2 * int(r_map / dy)) + y0\n    z = jnp.linspace(-1 * r_map, r_map, 2 * int(r_map / dz))\n    x, y, z = jnp.meshgrid(x, y, z, sparse=True, indexing=\"ij\")\n\n    return (x, y, z, x0, y0)\n</code></pre>"},{"location":"reference/grid/#witch.grid.make_grid_from_wcs","title":"<code>make_grid_from_wcs(wcs, nx, ny, z_map, dz, x0=None, y0=None)</code>","text":"<p>Make coordinate grids to build models in from a minkasi skymap. All grids are sparse and match the input map and xy and have size <code>int(2*z_map/dz)</code> in z. Unlike <code>make_grid</code> here we assume things are radians.</p> <p>Parameters:</p> Name Type Description Default <code>wcs</code> <code>WCS</code> <p>The WCS to base the grid off of.</p> required <code>nx</code> <code>int</code> <p>The number of pixels in x.</p> required <code>ny</code> <code>int</code> <p>The number of pixels in y.</p> required <code>z_map</code> <code>float</code> <p>Size of grid along LOS, in radians.</p> required <code>dz</code> <code>float</code> <p>Grid resolution along LOS, in radians.</p> required <code>x0</code> <code>Optional[float]</code> <p>Map x center in radians. If None, grid center is used.</p> <code>None</code> <code>y0</code> <code>Optional[float]</code> <p>Map y center in radians. If None, grid center is used.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>x</code> <code>Array</code> <p>Grid of x coordinates in radians. Has shape (<code>skymap.nx</code>, 1, 1).</p> <code>y</code> <code>Array</code> <p>Grid of y coordinates in radians. Has shape (1, <code>skymap.ny</code>, 1).</p> <code>z</code> <code>Array</code> <p>Grid of z coordinates in same units as radians. Has shape (1, 1, <code>int(2*z_map / dz)</code>).</p> <code>x0</code> <code>float</code> <p>Origin of grid in RA, in radians.</p> <code>y0</code> <code>float</code> <p>Origin of grid in Dec, in radians.</p> Source code in <code>witch/grid.py</code> <pre><code>def make_grid_from_wcs(\n    wcs: WCS,\n    nx: int,\n    ny: int,\n    z_map: float,\n    dz: float,\n    x0: Optional[float] = None,\n    y0: Optional[float] = None,\n) -&gt; Grid:\n    \"\"\"\n    Make coordinate grids to build models in from a minkasi skymap.\n    All grids are sparse and match the input map and xy and have size `int(2*z_map/dz)` in z.\n    Unlike `make_grid` here we assume things are radians.\n\n    Parameters\n    ----------\n    wcs : WCS\n        The WCS to base the grid off of.\n    nx : int\n        The number of pixels in x.\n    ny : int\n        The number of pixels in y.\n    z_map : float\n        Size of grid along LOS, in radians.\n    dz : float\n        Grid resolution along LOS, in radians.\n    x0 : Optional[float], default: None\n        Map x center in radians.\n        If None, grid center is used.\n    y0 : Optional[float], default: None\n        Map y center in radians. If None, grid center is used.\n\n    Returns\n    -------\n    x : jax.Array\n        Grid of x coordinates in radians.\n        Has shape (`skymap.nx`, 1, 1).\n    y : jax.Array\n        Grid of y coordinates in radians.\n        Has shape (1, `skymap.ny`, 1).\n    z : jax.Array\n        Grid of z coordinates in same units as radians.\n        Has shape (1, 1, `int(2*z_map / dz)`).\n    x0 : float\n        Origin of grid in RA, in radians.\n    y0 : float\n        Origin of grid in Dec, in radians.\n    \"\"\"\n    # make grid\n    _x = jnp.arange(nx, dtype=float)\n    _y = jnp.arange(ny, dtype=float)\n    _z = jnp.linspace(-1 * z_map, z_map, 2 * int(z_map / dz), dtype=float)\n    x, y, z = jnp.meshgrid(_x, _y, _z, sparse=True, indexing=\"ij\")\n\n    # Pad so we don't need to broadcast\n    x_flat = x.ravel()\n    y_flat = y.ravel()\n    len_diff = len(x_flat) - len(y_flat)\n    if len_diff &gt; 0:\n        y_flat = jnp.pad(y_flat, (0, len_diff), \"edge\")\n    elif len_diff &lt; 0:\n        x_flat = jnp.pad(x_flat, (0, abs(len_diff)), \"edge\")\n\n    # Convert x and y to ra/dec\n    ra_dec = wcs.wcs_pix2world(jnp.column_stack((x_flat, y_flat)), 0, ra_dec_order=True)\n    ra_dec = np.deg2rad(ra_dec)\n    ra = ra_dec[:, 0]\n    dec = ra_dec[:, 1]\n\n    # Remove padding\n    if len_diff &gt; 0:\n        dec = dec[: (-1 * len_diff)]\n    elif len_diff &lt; 0:\n        ra = ra[:len_diff]\n\n    if not x0:\n        x0 = (np.max(ra) + np.min(ra)) / 2\n    if not y0:\n        y0 = (np.max(dec) + np.min(dec)) / 2\n\n    if x0 is None or y0 is None:\n        raise TypeError(\"Origin still None\")\n\n    # Sparse indexing to save mem\n    x = x.at[:, 0, 0].set(ra * rad_to_arcsec)\n    y = y.at[0, :, 0].set(dec * rad_to_arcsec)\n    z = z * rad_to_arcsec\n    x0 *= rad_to_arcsec\n    y0 *= rad_to_arcsec\n\n    return x, y, z, float(x0), float(y0)\n</code></pre>"},{"location":"reference/grid/#witch.grid.tod_to_index","title":"<code>tod_to_index(xi, yi, x0, y0, grid, conv_factor=1.0)</code>","text":"<p>Convert RA/Dec TODs to index space.</p> <p>Parameters:</p> Name Type Description Default <code>xi</code> <code>NDArray[floating]</code> <p>RA TOD, usually in radians</p> required <code>yi</code> <code>NDArray[floating]</code> <p>Dec TOD, usually in radians</p> required <code>grid</code> <code>Grid</code> <p>The grid to index on.</p> required <code>conv_factor</code> <code>float</code> <p>Conversion factor to put RA and Dec in same units as the grid.</p> <code>1.</code> <p>Returns:</p> Name Type Description <code>idx</code> <code>Array</code> <p>The RA TOD in index space</p> <code>idy</code> <code>Array</code> <p>The Dec TOD in index space.</p> Source code in <code>witch/grid.py</code> <pre><code>def tod_to_index(\n    xi: NDArray[np.floating],\n    yi: NDArray[np.floating],\n    x0: float,\n    y0: float,\n    grid: Grid,\n    conv_factor: float = 1.0,\n) -&gt; tuple[jax.Array, jax.Array]:\n    \"\"\"\n    Convert RA/Dec TODs to index space.\n\n    Parameters\n    ----------\n    xi : NDArray[np.floating]\n        RA TOD, usually in radians\n    yi : NDArray[np.floating]\n        Dec TOD, usually in radians\n    grid : Grid\n        The grid to index on.\n    conv_factor : float, default: 1.\n        Conversion factor to put RA and Dec in same units as the grid.\n\n    Returns\n    -------\n    idx : jax.Array\n        The RA TOD in index space\n    idy : jax.Array\n        The Dec TOD in index space.\n    \"\"\"\n    x0, y0 = grid[-2:]\n    dx = (xi - x0) * jnp.cos(yi)\n    dy = yi - y0\n\n    dx *= conv_factor\n    dy *= conv_factor\n\n    # Assuming sparse indexing here\n    idx = np.digitize(dx, grid[0].ravel())\n    idy = np.digitize(dy, grid[1].ravel())\n\n    idx = np.rint(idx).astype(int)\n    idy = np.rint(idy).astype(int)\n\n    # Ensure out of bounds for stuff not in grid\n    idx = jnp.where((idx &lt; 0) + (idx &gt;= grid[0].shape[0]), 2 * grid[0].shape[0], idx)\n    idy = jnp.where((idy &lt; 0) + (idy &gt;= grid[1].shape[1]), 2 * grid[1].shape[1], idy)\n\n    return idx, idy\n</code></pre>"},{"location":"reference/grid/#witch.grid.transform_grid","title":"<code>transform_grid(dx, dy, dz, r_1, r_2, r_3, theta, xyz)</code>","text":"<p>Shift, rotate, and apply ellipticity to coordinate grid. Note that the <code>Grid</code> type is an alias for <code>tuple[jax.Array, jax.Array, jax.Array, float, float]</code>.</p> <p>Parameters:</p> Name Type Description Default <code>dx</code> <code>float</code> <p>Amount to move grid origin in x</p> required <code>dy</code> <code>float</code> <p>Amount to move grid origin in y</p> required <code>dz</code> <code>float</code> <p>Amount to move grid origin in z</p> required <code>r_1</code> <code>float</code> <p>Amount to scale along x-axis</p> required <code>r_2</code> <code>float</code> <p>Amount to scale along y-axis</p> required <code>r_3</code> <code>float</code> <p>Amount to scale along z-axis</p> required <code>theta</code> <code>float</code> <p>Angle to rotate in xy-plane in radians</p> required <code>xyz</code> <code>Grid</code> <p>Coordinte grid to transform</p> required <p>Returns:</p> Name Type Description <code>trasnformed</code> <code>Grid</code> <p>Transformed coordinate grid.</p> Source code in <code>witch/grid.py</code> <pre><code>@jax.jit\ndef transform_grid(\n    dx: float,\n    dy: float,\n    dz: float,\n    r_1: float,\n    r_2: float,\n    r_3: float,\n    theta: float,\n    xyz: Grid,\n):\n    \"\"\"\n    Shift, rotate, and apply ellipticity to coordinate grid.\n    Note that the `Grid` type is an alias for `tuple[jax.Array, jax.Array, jax.Array, float, float]`.\n\n    Parameters\n    ----------\n    dx : float\n        Amount to move grid origin in x\n    dy : float\n        Amount to move grid origin in y\n    dz : float\n        Amount to move grid origin in z\n    r_1 : float\n        Amount to scale along x-axis\n    r_2 : float\n        Amount to scale along y-axis\n    r_3 : float\n        Amount to scale along z-axis\n    theta : float\n        Angle to rotate in xy-plane in radians\n    xyz : Grid\n        Coordinte grid to transform\n\n    Returns\n    -------\n    trasnformed : Grid\n        Transformed coordinate grid.\n    \"\"\"\n    # Get origin\n    x0, y0 = xyz[3], xyz[4]\n    # Shift origin\n    x = (xyz[0] - (x0 + dx / jnp.cos(y0 / rad_to_arcsec))) * jnp.cos(\n        (y0 + dy) / rad_to_arcsec\n    )\n    y = xyz[1] - (y0 + dy)\n    z = xyz[2] - dz\n\n    # Rotate\n    xx = x * jnp.cos(theta) + y * jnp.sin(theta)\n    yy = y * jnp.cos(theta) - x * jnp.sin(theta)\n\n    # Apply ellipticity\n    x = xx / r_1\n    y = yy / r_2\n    z = z / r_3\n\n    return x, y, z, x0 - dx, y0 - dy\n</code></pre>"},{"location":"reference/nonparametric/","title":"nonparametric","text":""},{"location":"reference/nonparametric/#witch.nonparametric.bin_map","title":"<code>bin_map(hdu, rbins, x0=None, y0=None, cunit=None)</code>","text":"<p>Radially bin a map into rbins. Code adapted from CLASS</p> <p>Parameters:</p> Name Type Description Default <code>hdu</code> <code>HDUList</code> <p>hdu containing map to bin</p> required <code>rbins</code> <code>NDArray[floating]</code> <p>Bin edges in radians</p> required <code>cunit</code> <code>Union[None, np.floating], Default: None</code> <p>Pixel units. If None, will atempt to infer from imap</p> <code>None</code> <p>Returns:</p> Name Type Description <code>bin1d</code> <code>NDArray[floating]</code> <p>Bin center values</p> <code>var1d</code> <code>NDArray[floating]</code> <p>Bin variance estimate</p> Source code in <code>witch/nonparametric.py</code> <pre><code>def bin_map(hdu, rbins, x0=None, y0=None, cunit=None):\n    \"\"\"\n    Radially bin a map into rbins. Code adapted from CLASS\n\n    Parameters\n    ----------\n    hdu : fits.HDUList\n        hdu containing map to bin\n    rbins : NDArray[np.floating]\n        Bin edges in radians\n    cunit : Union[None, np.floating], Default: None\n        Pixel units. If None, will atempt to infer from imap\n\n    Returns\n    -------\n    bin1d : NDArray[np.floating]\n        Bin center values\n    var1d : NDArray[np.floating]\n        Bin variance estimate\n    \"\"\"\n\n    if cunit is None:\n        try:\n            cunit = hdu[0].header[\"CUNIT1\"].lower()\n        except KeyError as e:\n            raise e\n\n    if (\n        cunit.lower() == \"rad\"\n        or cunit.lower() == \"radian\"\n        or cunit.lower() == \"radians\"\n    ):\n        pixunits = 1\n    elif (\n        cunit.lower() == \"deg\"\n        or cunit.lower() == \"degree\"\n        or cunit.lower() == \"degrees\"\n    ):\n        pixunits = wu.rad_to_deg\n    elif (\n        cunit.lower() == \"arcmin\"\n        or cunit.lower() == \"arcminute\"\n        or cunit.lower() == \"arcminutes\"\n    ):\n        pixunits = wu.rad_to_arcmin\n    elif (\n        cunit.lower() == \"arcsec\"\n        or cunit.lower() == \"arcsecond\"\n        or cunit.lower() == \"arcseconds\"\n    ):\n        pixunits = wu.rad_to_arcsec\n    else:\n        raise ValueError(\"Error: cunit {} is not a valid pixel unit\".format(cunit))\n\n    pixsize = np.abs(hdu[0].header[\"CDELT1\"]) / pixunits\n    x0 = hdu[0].header[\"CRVAL1\"] / pixunits\n    y0 = hdu[0].header[\"CRVAL2\"] / pixunits\n\n    if np.abs(hdu[0].header[\"CDELT1\"]) != np.abs(hdu[0].header[\"CDELT2\"]):\n        warnings.warn(\n            \"Warning: non-square pixels: RA: {} Dec{}\".format(\n                np.abs(hdu[0].header[\"CDELT1\"]), np.abs(hdu[0].header[\"CDELT2\"])\n            )\n        )\n\n    # The offset is redundent if the binning center is taken to be the map center but frequently it is not\n    x = np.linspace(\n        -hdu[0].data.shape[1] / 2 * pixsize + hdu[0].header[\"CRVAL1\"] / pixunits,\n        hdu[0].data.shape[1] / 2 * pixsize + hdu[0].header[\"CRVAL1\"] / pixunits,\n        hdu[0].data.shape[1],\n    )\n    y = np.linspace(\n        -hdu[0].data.shape[0] / 2 * pixsize + hdu[0].header[\"CRVAL2\"] / pixunits,\n        hdu[0].data.shape[0] / 2 * pixsize + hdu[0].header[\"CRVAL2\"] / pixunits,\n        hdu[0].data.shape[0],\n    )\n\n    X, Y = np.meshgrid(x, y)\n    R = np.sqrt((X - x0) ** 2 + (Y - y0) ** 2)\n    rbins = rbins.append(999999)\n    bin1d = np.zeros(len(rbins) - 1)\n    var1d = np.zeros(len(rbins) - 1)\n\n    for k in range(len(rbins) - 1):\n        pixels = [\n            hdu[0].data[i, j]\n            for i in range(len(y))\n            for j in range(len(x))\n            if rbins[k] &lt; R[i, j] &lt;= rbins[k + 1]\n        ]\n        bin1d[k] = np.mean(pixels)\n        var1d[k] = np.var(pixels)\n\n    return bin1d, var1d\n</code></pre>"},{"location":"reference/nonparametric/#witch.nonparametric.broken_power","title":"<code>broken_power(rs, condlist, rbins, amps, pows, c)</code>","text":"<p>Function which returns a broken powerlaw evaluated at rs.</p> Parameters: <p>rs : jax.Array     Array of rs at which to compute pl. condlist : tuple     tuple which enocdes which rs are evaluated by which parametric function rbins : jax.Array     Array of bin edges for power laws amps : jax.Array     Amplitudes of power laws pows : jax.Array                                                                                                                                                                                                                                                                            Exponents of power laws c : float     Constant offset for powerlaws</p> Source code in <code>witch/nonparametric.py</code> <pre><code>@jax.jit\ndef broken_power(\n    rs: jax.Array,\n    condlist: tuple,\n    rbins: jax.Array,\n    amps: jax.Array,\n    pows: jax.Array,\n    c: float,\n) -&gt; jax.Array:\n    \"\"\"\n    Function which returns a broken powerlaw evaluated at rs.\n\n    Parameters:\n    -----------\n    rs : jax.Array\n        Array of rs at which to compute pl.\n    condlist : tuple\n        tuple which enocdes which rs are evaluated by which parametric function\n    rbins : jax.Array\n        Array of bin edges for power laws\n    amps : jax.Array\n        Amplitudes of power laws\n    pows : jax.Array                                                                                                                                                                                                                                                                            Exponents of power laws\n    c : float\n        Constant offset for powerlaws\n    \"\"\"\n    cur_c = c  # TODO: necessary?\n    funclist = []\n    for i in range(len(condlist) - 1, -1, -1):\n        funclist.append(\n            partial(power, rbin=rbins[i + 1], cur_amp=amps[i], cur_pow=pows[i], c=cur_c)\n        )\n        cur_c += amps[i] * (rbins[i] ** pows[i] - rbins[i + 1] ** pows[i])\n    return jnp.piecewise(rs, condlist, funclist)\n</code></pre>"},{"location":"reference/nonparametric/#witch.nonparametric.get_rbins","title":"<code>get_rbins(model, rmax=3.0 * 60.0, struct_num=0, sig_params=['amp', 'P0'], default=(0, 10, 20, 30, 50, 80, 120, 180))</code>","text":"<p>Function which returns a good set of rbins for a non-parametric fit given the significance of the underlying parametric model.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>Model</code> <p>Parametric model to calculate rbins on</p> required <code>rmax</code> <code>float</code> <p>Maximum radius of the rbins</p> <code>180</code> <code>struct_num</code> <code>int, defualt: 0</code> <p>Structure within model to calculate rbins on</p> <code>0</code> <code>sig_params</code> <code>list[str]</code> <p>Parameters to consider for computing significance. Only first match will be used.</p> <code>['amp', 'P0']</code> <code>default</code> <code>tuple[int]</code> <p>Default rbins to be returned if generation fails.</p> <code>(0, 10, 20, 30, 50, 80, 120, 180)</code> <p>Returns:</p> Name Type Description <code>rbins</code> <code>tuple[int]</code> <p>rbins for nonparametric fit</p> Source code in <code>witch/nonparametric.py</code> <pre><code>def get_rbins(\n    model,\n    rmax: float = 3.0 * 60.0,\n    struct_num: int = 0,\n    sig_params: list[str] = [\"amp\", \"P0\"],\n    default: tuple[int] = (0, 10, 20, 30, 50, 80, 120, 180),\n) -&gt; tuple[int]:\n    \"\"\"\n    Function which returns a good set of rbins for a non-parametric fit given the significance of the underlying parametric model.\n\n    Parameters\n    ----------\n    model : container.Model\n        Parametric model to calculate rbins on\n    rmax : float, default: 180\n        Maximum radius of the rbins\n    struct_num : int, defualt: 0\n        Structure within model to calculate rbins on\n    sig_params: list[str], default: [\"amp\", \"P0\"]\n        Parameters to consider for computing significance.\n        Only first match will be used.\n    default: tuple[int], default: (0, 10, 20, 30, 50, 80, 120, 180)\n        Default rbins to be returned if generation fails.\n\n    Returns\n    -------\n    rbins: tuple[int]\n        rbins for nonparametric fit\n    \"\"\"\n    sig = 0\n    for par in model.structures[struct_num].parameters:\n        if par.name == \"amp\" or par.name == \"P0\":\n            sig = par.val / par.err\n            break\n    if sig == 0:\n        warnings.warn(\n            \"Warning: model does not contain any valid significance parameters {}. Returning default bins.\".format(\n                sig_params\n            )\n        )\n        return default\n\n    if sig &lt; 10:\n        warnings.warn(\n            \"Warning, significance {} too low to calculate bins. Returning default bins.\".format(\n                sig\n            )\n        )\n        return default\n\n    rbins = [0, 10, 20]\n    rmin = 30\n    nrbins = int(np.floor(sig / 5)[0] - 3)\n    step = (\n        np.logspace(np.log10(rmin), np.log10(rmax), nrbins)[1]\n        - np.logspace(np.log10(rmin), np.log10(rmax), nrbins)[0]\n    )\n    while step &lt; 10:\n        rbins.append(rmin)\n        rmin += 10\n        nrbins -= 1\n        logrange = np.logspace(np.log10(rmin), np.log10(rmax), nrbins)\n        step = logrange[1] - logrange[0]\n        if rmin &gt; rmax or nrbins &lt; 1:\n            break\n    rbins = np.array(rbins)\n    rbins = np.append(rbins, logrange)\n\n    return tuple(rbins)\n</code></pre>"},{"location":"reference/nonparametric/#witch.nonparametric.power","title":"<code>power(x, rbin, cur_amp, cur_pow, c)</code>","text":"<p>Function which returns the powerlaw, given the bin-edge constraints. Exists to be partialed.</p> Parameters: <p>x : float     Dummy variable to be partialed over rbin : float     Edge of bin for powerlaw cur_amp : float     Amplitude of power law cur_pow : float     Power of power law c : float     Constant offset</p> <p>Returns:</p> Name Type Description <code>tmp</code> <code>float</code> <p>Powerlaw evaluated at x</p> Source code in <code>witch/nonparametric.py</code> <pre><code>@jax.jit\ndef power(x: float, rbin: float, cur_amp: float, cur_pow: float, c: float):\n    \"\"\"\n    Function which returns the powerlaw, given the bin-edge constraints. Exists to be partialed.\n\n    Parameters:\n    -----------\n    x : float\n        Dummy variable to be partialed over\n    rbin : float\n        Edge of bin for powerlaw\n    cur_amp : float\n        Amplitude of power law\n    cur_pow : float\n        Power of power law\n    c : float\n        Constant offset\n\n    Returns\n    -------\n    tmp : float\n        Powerlaw evaluated at x\n    \"\"\"\n    tmp = cur_amp * (x**cur_pow - rbin**cur_pow) + c\n    return tmp\n</code></pre>"},{"location":"reference/nonparametric/#witch.nonparametric.profile_to_broken_power","title":"<code>profile_to_broken_power(rs, ys, condlist, rbins)</code>","text":"<p>Estimates a non-parametric broken power profile from a generic profile. Note this is an estimation only; in partciular since we fit piece-wise the c's get messed up. This broken powerlaw should then be fit to the data.</p> <p>Parameters:</p> Name Type Description Default <code>rs</code> <code>ArrayLike</code> <p>Array of radius values for the profile</p> required <code>ys</code> <code>ArrayLike</code> <p>Profile y values</p> required <code>condlist</code> <code>list[ArrayLike]</code> <p>List which defines which powerlaws map to which radii. See broken_power</p> required <code>rbins</code> <code>ArrayLike</code> <p>Array of bin edges defining the broken powerlaws</p> required <p>Returns:</p> Name Type Description <code>amps</code> <code>array</code> <p>Best fit amps for the powerlaws</p> <code>pows</code> <code>array</code> <p>Best fit powers for the powerlaws</p> <code>c</code> <code>float</code> <p>Best fit c for only the outermost powerlaw</p> Source code in <code>witch/nonparametric.py</code> <pre><code>def profile_to_broken_power(\n    rs: ArrayLike, ys: ArrayLike, condlist: list[ArrayLike], rbins: ArrayLike\n) -&gt; tuple[jnp.array, jnp.array, float]:\n    \"\"\"\n    Estimates a non-parametric broken power profile from a generic profile.\n    Note this is an estimation only; in partciular since we fit piece-wise\n    the c's get messed up. This broken powerlaw should then be fit to the\n    data.\n\n    Parameters\n    ----------\n    rs : ArrayLike\n        Array of radius values for the profile\n    ys : ArrayLike\n        Profile y values\n    condlist : list[ArrayLike]\n        List which defines which powerlaws map to which radii. See broken_power\n    rbins : ArrayLike\n        Array of bin edges defining the broken powerlaws\n\n    Returns\n    -------\n    amps : jnp.array\n        Best fit amps for the powerlaws\n    pows : jnp.array\n        Best fit powers for the powerlaws\n    c : float\n        Best fit c for only the outermost powerlaw\n    \"\"\"\n    rs = jnp.array([x if x != 0 else 1e-1 for x in rs])  # Dont blow up\n\n    rbins = jnp.array(\n        [x if x != 0 else jnp.amin(rs) for x in rbins]\n    )  # Dont blow up 2.0\n\n    amps = jnp.zeros(len(condlist))\n    pows = jnp.zeros(len(condlist))\n\n    for i in range(len(condlist)):\n        xdata = rs[condlist[i]]\n        ydata = ys[condlist[i]]\n        if i == len(condlist) - 1:\n            popt, pcov = curve_fit(power, xdata, ydata, method=\"trf\")\n        else:\n            popt, pcov = curve_fit(\n                power, xdata, ydata, method=\"trf\", p0=[rbins[::-1][i], 1e-4, -4.0, 0.0]\n            )\n        if i == 0:\n            c = popt[3]\n        amps.at[i].set(popt[1])\n        pows.at[i].set(popt[2])\n\n    return amps[::-1], pows[::-1], c\n</code></pre>"},{"location":"reference/objective/","title":"objective","text":"<p>Module for the objective functions used by LM fitting and MCMC. All objective functions should return a log-likelihood (modulo a DC offset) as well as the gradient and curvature of the log-likelihood with respect to the model parameters.</p> <p>Note that everything in done in analogy to chi-squared so there is a factor of -2 applied as needed to the non chi-squared distributions.</p>"},{"location":"reference/objective/#witch.objective.chisq_objective","title":"<code>chisq_objective(model, datavec, mode='tod', do_loglike=True, do_grad=True, do_curve=True)</code>","text":"<p>Objective function to minimize when fitting a dataset where a Gaussian distribution is reasonible. This is an MPI aware function.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>Model</code> <p>The model object we are using to fit.</p> required <code>datavec</code> <code>TODVec | SolutionSet</code> <p>The data to fit against. This is what we use to compute our fit residuals.</p> required <code>mode</code> <code>str</code> <p>The type of data we compile this function for. Should be either \"tod\" or \"map\".</p> <code>\"tod\"</code> <code>do_loglike</code> <code>bool</code> <p>If True then we will compute the chi-squared between the model and the data.</p> <code>True</code> <code>do_grad</code> <code>bool</code> <p>If True then compute the gradient of chi-squared with respect to the model parameters.</p> <code>True</code> <code>do_curve</code> <code>bool</code> <p>If True than compute the curvature of chi-squared with respect to the model parameters.</p> <code>True</code> <p>Returns:</p> Name Type Description <code>chisq</code> <code>Array</code> <p>The chi-squared between the model and data. If <code>do_loglike</code> is <code>False</code> then this is <code>jnp.array(0)</code>.</p> <code>grad</code> <code>Array</code> <p>The gradient of the parameters at there current values. If <code>do_grad</code> is <code>False</code> then this is an array of zeros. This is a <code>(npar,)</code> array.</p> <code>curve</code> <code>Array</code> <p>The curvature of the parameter space at the current values. If <code>do_curve</code> is <code>False</code> then this is an array of zeros. This is a <code>(npar, npar)</code> array.</p> Source code in <code>witch/objective.py</code> <pre><code>@partial(jax.jit, static_argnames=(\"mode\", \"do_loglike\", \"do_grad\", \"do_curve\"))\ndef chisq_objective(\n    model: Model,\n    datavec: TODVec | SolutionSet,\n    mode: str = \"tod\",\n    do_loglike: bool = True,\n    do_grad: bool = True,\n    do_curve: bool = True,\n) -&gt; tuple[jax.Array, jax.Array, jax.Array]:\n    \"\"\"\n    Objective function to minimize when fitting a dataset where a Gaussian distribution is reasonible.\n    This is an MPI aware function.\n\n    Parameters\n    ----------\n    model : Model\n        The model object we are using to fit.\n    datavec: TODVec | SolutionSet\n        The data to fit against.\n        This is what we use to compute our fit residuals.\n    mode : str, default: \"tod\"\n        The type of data we compile this function for.\n        Should be either \"tod\" or \"map\".\n    do_loglike : bool, default: True\n        If True then we will compute the chi-squared between\n        the model and the data.\n    do_grad : bool, default: True\n        If True then compute the gradient of chi-squared with\n        respect to the model parameters.\n    do_curve : bool, default: True\n        If True than compute the curvature of chi-squared with\n        respect to the model parameters.\n\n    Returns\n    -------\n    chisq : jax.Array\n        The chi-squared between the model and data.\n        If `do_loglike` is `False` then this is `jnp.array(0)`.\n    grad : jax.Array\n        The gradient of the parameters at there current values.\n        If `do_grad` is `False` then this is an array of zeros.\n        This is a `(npar,)` array.\n    curve : jax.Array\n        The curvature of the parameter space at the current values.\n        If `do_curve` is `False` then this is an array of zeros.\n        This is a `(npar, npar)` array.\n    \"\"\"\n    if mode not in [\"tod\", \"map\"]:\n        raise ValueError(\"Invalid mode\")\n    npar = len(model.pars)\n    chisq = jnp.array(0)\n    grad = jnp.zeros(npar)\n    curve = jnp.zeros((npar, npar))\n\n    zero = jnp.zeros((1, 1))\n    only_chisq = not (do_grad or do_curve)\n\n    for data in datavec:\n        if mode == \"tod\":\n            x = data.x * wu.rad_to_arcsec\n            y = data.y * wu.rad_to_arcsec\n            if only_chisq:\n                pred_dat = model.to_tod(x, y)\n                grad_dat = zero\n            else:\n                pred_dat, grad_dat = model.to_tod_grad(x, y)\n        else:\n            x, y = data.xy\n            if only_chisq:\n                pred_dat = model.to_map(x * wu.rad_to_arcsec, y * wu.rad_to_arcsec)\n                grad_dat = zero\n            else:\n                pred_dat, grad_dat = model.to_map_grad(\n                    x * wu.rad_to_arcsec, y * wu.rad_to_arcsec\n                )\n\n        resid = data.data - pred_dat\n        resid_filt = data.noise.apply_noise(resid)\n        if do_loglike:\n            chisq += jnp.sum(resid * resid_filt)\n\n        if only_chisq:\n            continue\n\n        grad_filt = jnp.zeros_like(grad_dat)\n        for i in range(npar):\n            grad_filt = grad_filt.at[i].set(\n                data.noise.apply_noise(grad_dat.at[i].get())\n            )\n        grad_filt = jnp.reshape(grad_filt, (npar, -1))\n        grad_dat = jnp.reshape(grad_dat, (npar, -1))\n        resid = resid.ravel()\n\n        if do_grad:\n            grad = grad.at[:].add(jnp.dot(grad_filt, jnp.transpose(resid)))\n        if do_curve:\n            curve = curve.at[:].add(jnp.dot(grad_filt, jnp.transpose(grad_dat)))\n\n    token = mpi4jax.barrier(comm=datavec.comm)\n    if do_loglike:\n        chisq, token = mpi4jax.allreduce(chisq, MPI.SUM, comm=datavec.comm, token=token)\n    if do_grad:\n        grad, token = mpi4jax.allreduce(grad, MPI.SUM, comm=datavec.comm, token=token)\n    if do_curve:\n        curve, token = mpi4jax.allreduce(curve, MPI.SUM, comm=datavec.comm, token=token)\n    _ = token\n\n    return chisq, grad, curve\n</code></pre>"},{"location":"reference/objective/#witch.objective.poisson_objective","title":"<code>poisson_objective(model, datavec, mode='tod', do_loglike=True, do_grad=True, do_curve=True)</code>","text":"<p>Objective function to minimize when fitting a dataset where a Poisson distribution is reasonible. This is an MPI aware function.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>Model</code> <p>The model object we are using to fit.</p> required <code>datavec</code> <code>TODVec | SolutionSet</code> <p>The data to fit against. This is what we use to compute our fit residuals.</p> required <code>mode</code> <code>str</code> <p>The type of data we compile this function for. Should be either \"tod\" or \"map\".</p> <code>\"tod\"</code> <code>do_loglike</code> <code>bool</code> <p>If True then we will compute the log-likelihood between the model and the data.</p> <code>True</code> <code>do_grad</code> <code>bool</code> <p>If True then compute the gradient of chi-squared with respect to the model parameters.</p> <code>True</code> <code>do_curve</code> <code>bool</code> <p>If True than compute the curvature of chi-squared with respect to the model parameters.</p> <code>True</code> <p>Returns:</p> Name Type Description <code>loglike</code> <code>Array</code> <p>The log-likelihood between the model and data. If <code>do_loglike</code> is <code>False</code> then this is <code>jnp.array(0)</code>. Note that there is a factor of -2 here to make it add with chi-squared.</p> <code>grad</code> <code>Array</code> <p>The gradient of the parameters at there current values. If <code>do_grad</code> is <code>False</code> then this is an array of zeros. This is a <code>(npar,)</code> array. Note that there is a factor of -2 here to make it add with the gradient of chi-squared.</p> <code>curve</code> <code>Array</code> <p>The curvature of the parameter space at the current values. If <code>do_curve</code> is <code>False</code> then this is an array of zeros. This is a <code>(npar, npar)</code> array. Note that there is a factor of -2 here to make it add with the cruvature of chi-squared.</p> Source code in <code>witch/objective.py</code> <pre><code>@partial(jax.jit, static_argnames=(\"mode\", \"do_loglike\", \"do_grad\", \"do_curve\"))\ndef poisson_objective(\n    model: Model,\n    datavec: TODVec | SolutionSet,\n    mode: str = \"tod\",\n    do_loglike: bool = True,\n    do_grad: bool = True,\n    do_curve: bool = True,\n) -&gt; tuple[jax.Array, jax.Array, jax.Array]:\n    \"\"\"\n    Objective function to minimize when fitting a dataset where a Poisson distribution is reasonible.\n    This is an MPI aware function.\n\n    Parameters\n    ----------\n    model : Model\n        The model object we are using to fit.\n    datavec: TODVec | SolutionSet\n        The data to fit against.\n        This is what we use to compute our fit residuals.\n    mode : str, default: \"tod\"\n        The type of data we compile this function for.\n        Should be either \"tod\" or \"map\".\n    do_loglike : bool, default: True\n        If True then we will compute the log-likelihood between\n        the model and the data.\n    do_grad : bool, default: True\n        If True then compute the gradient of chi-squared with\n        respect to the model parameters.\n    do_curve : bool, default: True\n        If True than compute the curvature of chi-squared with\n        respect to the model parameters.\n\n    Returns\n    -------\n    loglike : jax.Array\n        The log-likelihood between the model and data.\n        If `do_loglike` is `False` then this is `jnp.array(0)`.\n        Note that there is a factor of -2 here to make it add with chi-squared.\n    grad : jax.Array\n        The gradient of the parameters at there current values.\n        If `do_grad` is `False` then this is an array of zeros.\n        This is a `(npar,)` array.\n        Note that there is a factor of -2 here to make it add with the gradient of chi-squared.\n    curve : jax.Array\n        The curvature of the parameter space at the current values.\n        If `do_curve` is `False` then this is an array of zeros.\n        This is a `(npar, npar)` array.\n        Note that there is a factor of -2 here to make it add with the cruvature of chi-squared.\n    \"\"\"\n    if mode not in [\"tod\", \"map\"]:\n        raise ValueError(\"Invalid mode\")\n    npar = len(model.pars)\n    loglike = jnp.array(0)\n    grad = jnp.zeros(npar)\n    curve = jnp.zeros((npar, npar))\n\n    zero = jnp.zeros((1, 1))\n    only_loglike = not (do_grad or do_curve)\n\n    for data in datavec:\n        if mode == \"tod\":\n            x = data.x * wu.rad_to_arcsec\n            y = data.y * wu.rad_to_arcsec\n            if only_loglike:\n                pred_dat = model.to_tod(x, y)\n                grad_dat = zero\n            else:\n                pred_dat, grad_dat = model.to_tod_grad(x, y)\n        else:\n            x, y = data.xy\n            if only_loglike:\n                pred_dat = model.to_map(x * wu.rad_to_arcsec, y * wu.rad_to_arcsec)\n                grad_dat = zero\n            else:\n                pred_dat, grad_dat = model.to_map_grad(\n                    x * wu.rad_to_arcsec, y * wu.rad_to_arcsec\n                )\n\n        resid = (data.data / pred_dat) - 1\n        if do_loglike:\n            loglike += jnp.sum(\n                data.data * jnp.log(pred_dat) - pred_dat - jnp.log(factorial(data.data))\n            )\n\n        if only_loglike:\n            continue\n\n        grad_filt = jnp.zeros_like(grad_dat)\n        for i in range(npar):\n            grad_filt = grad_filt.at[i].set(\n                data.noise.apply_noise(grad_dat.at[i].get())\n            )\n        grad_filt = jnp.reshape(grad_filt, (npar, -1))\n        grad_dat = jnp.reshape(grad_dat, (npar, -1))\n        resid = resid.ravel()\n\n        if do_grad:\n            grad = grad.at[:].add(jnp.dot(grad_dat, jnp.transpose(resid)))\n        if do_curve:\n            # Dropping the second term here, so Jon note for justification\n            curve = curve.at[:].add(\n                jnp.dot(\n                    -1 * grad_dat * (data.data / (pred_dat**2)).ravel(),\n                    jnp.transpose(grad_dat),\n                )\n            )\n\n    token = mpi4jax.barrier(comm=datavec.comm)\n    if do_loglike:\n        loglike, token = mpi4jax.allreduce(\n            loglike, MPI.SUM, comm=datavec.comm, token=token\n        )\n    if do_grad:\n        grad, token = mpi4jax.allreduce(grad, MPI.SUM, comm=datavec.comm, token=token)\n    if do_curve:\n        curve, token = mpi4jax.allreduce(curve, MPI.SUM, comm=datavec.comm, token=token)\n    _ = token\n\n    return -2 * loglike, -2 * grad, -2 * curve\n</code></pre>"},{"location":"reference/plotting/","title":"plotting","text":""},{"location":"reference/plotting/#witch.plotting.plot_cluster","title":"<code>plot_cluster(name, fits_path, root=None, pix_size=None, ra=None, dec=None, units='mJy', scale=1.0, cmap='mustang', bound=None, radius=2.0, plot_r=True, figsize=(6, 5), ncontours=0, hdu_int=0, downsample=1, smooth=9.0, convention='calabretta')</code>","text":"<p>Function for doing core plotting. TODO: This function could probably use an args/kwargs, but there are an enourmous number of keyword args within so that might be difficult.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>name of the cluster</p> required <code>fits_path</code> <code>str</code> <p>Path to the fits file to be plotted.</p> required <code>root</code> <code>None | str</code> <p>Path to the output root. If none, then it will assume WITCH output formating.</p> <code>None</code> <code>pix_size</code> <code>None | float</code> <p>Pixel size. If None, then will be computed from results file.</p> <code>None</code> <code>ra</code> <code>None | float</code> <p>RA of center of plot, in degrees. If none, will be taken from config</p> <code>None</code> <code>dec</code> <code>None | float, dfault: None</code> <p>Dec of center of plot, in degrees. If none, will be taken from config</p> <code>None</code> <code>units</code> <code>str</code> <p>String to be used as units. If snr, then it will autoformat to sigma</p> <code>mJy</code> <code>scale</code> <code>float</code> <p>Amount to scale data by</p> <code>1</code> <code>bound</code> <code>None | float</code> <p>Bounds for the colormap. If none, reasonable bounds will be computed.</p> <code>None</code> <code>radius</code> <code>float</code> <p>Radius, in arcmin, of figure</p> <code>2.0</code> <code>plot_r</code> <code>bool | str</code> <p>If true, plot r500. If a str, plot a related critical radius</p> <code>True</code> <code>figsize</code> <code>tuple[float, float]</code> <p>Width and height of plot in inches.</p> <code>(5,5)</code> <code>ncontours</code> <code>int</code> <p>Number of countours to be plotted</p> <code>= 0</code> <code>hdu_int</code> <code>int</code> <p>Fits hdu corresponding to the image to be plotted</p> <code>0</code> <code>downsample</code> <code>int</code> <p>Factor by which to downsample the image.</p> <code>1</code> <code>smooth</code> <code>float</code> <p>Scale, in arcminutes, at which to smooth the image.</p> <code>9.0</code> <code>convention</code> <code>str</code> <p>Determines interpretation of abigious fits headers. See aplpy.FITSFigure documentation</p> <code>calabretta</code> <p>Returns:</p> Name Type Description <code>img</code> <code>FITSFigure</code> <p>FITSFigure plot of the cluster</p> Source code in <code>witch/plotting.py</code> <pre><code>def plot_cluster(\n    name: str,\n    fits_path: str,\n    root: Optional[str] = None,\n    pix_size: Optional[float] = None,\n    ra: Optional[float] = None,\n    dec: Optional[float] = None,\n    units: str = \"mJy\",\n    scale: float = 1.0,\n    cmap: str = \"mustang\",\n    bound: Optional[float] = None,\n    radius: float = 2.0,\n    plot_r=True,\n    figsize: tuple[float, float] = (6, 5),\n    ncontours: int = 0,\n    hdu_int: int = 0,\n    downsample: int = 1,\n    smooth: float = 9.0,\n    convention: str = \"calabretta\",\n):\n    \"\"\"\n    Function for doing core plotting.\n    TODO: This function could probably use an args/kwargs, but there are an enourmous number of keyword args within so that might be difficult.\n\n    Parameters\n    ----------\n    name : str\n        name of the cluster\n    fits_path : str\n        Path to the fits file to be plotted.\n    root : None | str, default: None\n        Path to the output root. If none, then it will assume WITCH output formating.\n    pix_size : None | float, default: None\n        Pixel size. If None, then will be computed from results file.\n    ra : None | float, default: None\n        RA of center of plot, in degrees. If none, will be taken from config\n    dec : None | float, dfault: None\n        Dec of center of plot, in degrees. If none, will be taken from config\n    units : str, default: mJy\n        String to be used as units. If snr, then it will autoformat to sigma\n    scale : float, default: 1\n        Amount to scale data by\n    bound : None | float, default: None\n        Bounds for the colormap. If none, reasonable bounds will be computed.\n    radius : float, default: 2.0\n        Radius, in arcmin, of figure\n    plot_r : bool | str, default: True\n        If true, plot r500. If a str, plot a related critical radius\n    figsize : tuple[float, float], default: (5,5)\n        Width and height of plot in inches.\n    ncontours : int, default = 0\n        Number of countours to be plotted\n    hdu_int : int, default: 0\n        Fits hdu corresponding to the image to be plotted\n    downsample : int, default: 1\n        Factor by which to downsample the image.\n    smooth : float, default: 9.0\n        Scale, in arcminutes, at which to smooth the image.\n    convention : str, default: calabretta\n        Determines interpretation of abigious fits headers. See aplpy.FITSFigure documentation\n\n    Returns\n    -------\n    img: aplpy.FITSFigure\n        FITSFigure plot of the cluster\n    \"\"\"\n\n    fits_path = os.path.abspath(fits_path)\n    if root is None:\n        root = os.path.split(os.path.split(os.path.split(fits_path)[0])[0])[\n            0\n        ]  # TODO: There's gotta be a better way!\n\n    cfg_path = root + \"/\" + \"config.yaml\"\n    cfg = load_config({}, cfg_path)\n    # Do imports\n    for module, name in cfg.get(\"imports\", {}).items():\n        mod = import_module(module)\n        if isinstance(name, str):\n            locals()[name] = mod\n        elif isinstance(name, list):\n            for n in name:\n                locals()[n] = getattr(mod, n)\n        else:\n            raise TypeError(\"Expect import name to be a string or a list\")\n\n    res_path = (\n        root\n        + \"/\"\n        + str(sorted([file for file in os.listdir(root) if \".dill\" in file])[-1])\n    )\n    with open(res_path, \"rb\") as f:\n        results = pk.load(f)\n\n    if pix_size is None:\n        pix_size = results.pix_size * rad_to_arcsec\n\n    if ra is None or dec is None:\n        ra = eval(cfg[\"coords\"][\"x0\"])\n        dec = eval(cfg[\"coords\"][\"y0\"])\n        ra, dec = np.rad2deg(\n            [ra, dec]\n        )  # TODO: Currently center on config center, which is fine but should probably be fit center\n\n    smooth = max(\n        1, int(smooth / pix_size)\n    )  # FITSfigure smoothing is in pixels, so convert arcsec to pixels\n\n    kernel = Gaussian2DKernel(x_stddev=smooth * 5)\n\n    fig = plt.figure(figsize=figsize)\n\n    hdu = fits.open(fits_path)[0]\n    hdu.data *= scale\n\n    plot_hdu = fits.PrimaryHDU(data=hdu.data, header=hdu.header)\n\n    img = aplpy.FITSFigure(\n        plot_hdu,\n        hdu=hdu_int,\n        figure=fig,\n        downsample=downsample,\n        smooth=False,\n        convention=convention,\n    )  # Smooth here does something whack\n    img.set_theme(\"publication\")\n\n    if units is not None:\n        if units == \"snr\":\n            cbar_label = r\"$\\sigma$\"\n        elif units == \"uK_cmb\":\n            img._data *= 1e6\n            cbar_label = r\"$uK_{CMB}$\"\n        elif units == \"uK_RJ\":\n            img._data *= 1e6\n            cbar_label = r\"$uK_{RJ}$\"\n        elif units == \"uJy/beam\":\n            img._data *= 0.7 * 1e6\n            cbar_label = r\"$\\mu Jy/beam$\"\n        else:\n            cbar_label = str(units)\n\n    if bound is None:\n        nx, ny = img._data.shape\n        lims = int(radius * 60 / pix_size)\n        xmin = int(nx / 2 - lims)\n        xmax = int(nx / 2 + lims)\n        ymin = int(ny / 2 - lims)\n        ymax = int(ny / 2 + lims)\n        bound = np.amax(np.abs(img._data[xmin:xmax, ymin:ymax]))\n        order = int(np.floor(np.log10(bound)))\n        bound = np.round(bound, -1 * order) / 2\n\n    img.show_colorscale(cmap=cmap, stretch=\"linear\", vmin=-bound, vmax=bound, smooth=3)\n    img.recenter(ra, dec, radius=radius / 60.0)\n    img.ax.tick_params(axis=\"both\", which=\"both\", direction=\"in\")\n\n    matplotlib.rcParams[\"lines.linewidth\"] = 3.0\n    img.add_scalebar(\n        0.5 / 60.0, '30\"', color=\"black\"\n    )  # Adds a 30 arcsec scalebar to the image\n\n    matplotlib.rcParams[\"lines.linewidth\"] = 2.0\n\n    img.add_beam(\n        major=9.0 / 3600.0, minor=9.0 / 3600.0, angle=0\n    )  # TODO: For now hard-coded to M2 beam but may want some flexibility later\n    img.beam.set_color(\"white\")\n    img.beam.set_edgecolor(\"green\")\n    img.beam.set_facecolor(\"white\")\n    img.beam.set_corner(\"bottom left\")\n\n    img.show_markers(\n        ra,\n        dec,\n        facecolor=\"black\",\n        edgecolor=None,\n        marker=\"+\",\n        s=50,\n        linewidths=2,\n        alpha=0.5,\n    )\n    if units is not None:\n        img.add_colorbar(\"right\")\n        img.colorbar.set_width(0.12)\n        img.colorbar.set_axis_label_text(cbar_label)\n\n    if ncontours:\n        matplotlib.rcParams[\"lines.linewidth\"] = 0.5\n        clevels = np.linspace(-bound, bound, ncontours)\n        img.show_contour(\n            fits_path,\n            colors=\"gray\",\n            levels=clevels,\n            returnlevels=True,\n            convention=\"calabretta\",\n            smooth=3,\n        )\n\n    if plot_r:  # TODO: Allow passing of r500 values, make this a subfunction\n        if \"a10\" in cfg[\"model\"][\"structures\"].keys():\n            mod_type = \"a10\"\n        elif \"ea10\" in cfg[\"model\"][\"structures\"].keys():\n            mod_type = \"ea10\"\n        elif \"gnfw_rs\" in cfg[\"model\"][\"structures\"].keys():\n            mod_type = \"gnfw_rs\"\n        else:\n            raise ValueError(\"For R500, must have structure type gnfw_rs, A10, or EA10\")\n\n        # Get index of structure of interest. TODO: currently only plots first\n        for i in range(len(results.structures)):\n            if str(results.structures[i].name) == mod_type:\n                break\n\n        if mod_type == \"ea10\" or mod_type == \"a10\":\n            for parameter in results.structures[i].parameters:\n                if str(parameter.name.lower()) == \"m500\":\n                    m500 = parameter.val\n                    break\n\n            z = float(cfg[\"constants\"][\"z\"])\n            nz = get_nz(z)\n\n            r500 = (m500 / (4.00 * np.pi / 3.00) / 5.00e02 / nz) ** (1.00 / 3.00)\n            da = get_da(z)\n            r500 /= da\n            if plot_r == \"rs\":\n                r500 /= float(\n                    cfg[\"model\"][\"structures\"][mod_type][\"parameters\"][\"c500\"][\"value\"]\n                )  # Convert to rs\n            img.show_circles(\n                ra, dec, radius=r500 / 3600, coords_frame=\"world\", color=\"green\"\n            )\n\n        elif mod_type == \"gnfw_rs\":\n            for parameter in results.structures[i].parameters:\n                if (\n                    str(parameter.name.lower()) == \"rs\"\n                    or str(parameter.name.lower()) == \"r_s\"\n                ):\n                    rs = parameter.val\n                    break\n            img.show_circles(\n                ra, dec, radius=rs / 3600, coords_frame=\"world\", color=\"green\"\n            )\n\n    return img\n</code></pre>"},{"location":"reference/plotting/#witch.plotting.plot_cluster_act","title":"<code>plot_cluster_act(name, fits_path, cfg_path=None, ra=None, dec=None, units='mJy', bound=None, radius=2.0, plot_r=True, figsize=(5, 5), ncontours=0, hdu=0, downsample=1, smooth=60.0, convention='calabretta')</code>","text":"<p>Function for doing core plotting. TODO: This function could probably use an args/kwargs, but there are an enourmous number of keyword args within so that might be difficult.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of the cluster</p> required <code>fits_path</code> <code>str</code> <p>Path to the fits file to be plotted.</p> required <code>cfg_path</code> <code>None | str</code> <p>Path to WITCH config file corresponding to same cluster</p> <code>None</code> <code>ra</code> <code>None | float</code> <p>RA of center of plot, in degrees. If none, will be taken from config</p> <code>None</code> <code>dec</code> <code>None | float, dfault: None</code> <p>Dec of center of plot, in degrees. If none, will be taken from config</p> <code>None</code> <code>units</code> <code>str</code> <p>String to be used as units. If snr, then it will autoformat to sigma</p> <code>mJy</code> <code>bound</code> <code>None | float</code> <p>Bounds for the colormap. If none, reasonable bounds will be computed.</p> <code>None</code> <code>radius</code> <code>float</code> <p>Radius, in arcmin, of figure</p> <code>2.0</code> <code>plot_r</code> <code>bool | str</code> <p>If true, plot r500. If a str, plot a related critical radius</p> <code>True</code> <code>figsize</code> <code>tuple[float, float]</code> <p>Width and height of plot in inches.</p> <code>(5,5)</code> <code>ncontours</code> <code>int</code> <p>Number of countours to be plotted</p> <code>= 0</code> <code>hdu</code> <code>int</code> <p>Fits hdu corresponding to the image to be plotted</p> <code>0</code> <code>downsample</code> <code>int</code> <p>Factor by which to downsample the image.</p> <code>1</code> <code>smooth</code> <code>float</code> <p>Scale, in arcminutes, at which to smooth the image.</p> <code>60.0</code> <code>convention</code> <code>str</code> <p>Determines interpretation of abigious fits headers. See aplpy.FITSFigure documentation</p> <code>calabretta</code> <p>Returns:</p> Name Type Description <code>img</code> <code>FITSFigure</code> <p>FITSFigure plot of the cluster</p> Source code in <code>witch/plotting.py</code> <pre><code>def plot_cluster_act(\n    name: str,\n    fits_path: str,\n    cfg_path: Optional[str] = None,\n    ra: Optional[float] = None,\n    dec: Optional[float] = None,\n    units: str = \"mJy\",\n    bound: Optional[float] = None,\n    radius: float = 2.0,\n    plot_r=True,\n    figsize: tuple[float, float] = (5, 5),\n    ncontours: int = 0,\n    hdu: int = 0,\n    downsample: int = 1,\n    smooth: float = 60.0,\n    convention: str = \"calabretta\",\n):\n    \"\"\"\n    Function for doing core plotting.\n    TODO: This function could probably use an args/kwargs, but there are an enourmous number of keyword args within so that might be difficult.\n\n    Parameters\n    ----------\n    name : str\n        Name of the cluster\n    fits_path : str\n        Path to the fits file to be plotted.\n    cfg_path : None | str, default: None\n        Path to WITCH config file corresponding to same cluster\n    ra : None | float, default: None\n        RA of center of plot, in degrees. If none, will be taken from config\n    dec : None | float, dfault: None\n        Dec of center of plot, in degrees. If none, will be taken from config\n    units : str, default: mJy\n        String to be used as units. If snr, then it will autoformat to sigma\n    bound : None | float, default: None\n        Bounds for the colormap. If none, reasonable bounds will be computed.\n    radius : float, default: 2.0\n        Radius, in arcmin, of figure\n    plot_r : bool | str, default: True\n        If true, plot r500. If a str, plot a related critical radius\n    figsize : tuple[float, float], default: (5,5)\n        Width and height of plot in inches.\n    ncontours : int, default = 0\n        Number of countours to be plotted\n    hdu : int, default: 0\n        Fits hdu corresponding to the image to be plotted\n    downsample : int, default: 1\n        Factor by which to downsample the image.\n    smooth : float, default: 60.0\n        Scale, in arcminutes, at which to smooth the image.\n    convention : str, default: calabretta\n        Determines interpretation of abigious fits headers. See aplpy.FITSFigure documentation\n\n    Returns\n    -------\n    img: aplpy.FITSFigure\n        FITSFigure plot of the cluster\n    \"\"\"\n    if cfg_path is not None:\n        cfg = load_config({}, cfg_path)\n        ra = eval(cfg[\"coords\"][\"x0\"])\n        dec = eval(cfg[\"coords\"][\"y0\"])\n        ra, dec = np.rad2deg(\n            [ra, dec]\n        )  # TODO: Currently center on config center, which is fine but should probably be fit center\n    elif ra is None or dec is None:\n        raise ValueError(\"Either cfg_path or both ra and dec must be specified.\")\n    cur_hdu = fits.open(fits_path)\n    pix_size = cur_hdu[0].header[\"CDELT1\"] * 3600\n\n    smooth = max(\n        1, int(smooth / pix_size)\n    )  # FITSfigure smoothing is in pixels, so convert arcsec to pixels\n\n    kernel = Gaussian2DKernel(x_stddev=smooth * 5)\n\n    fig = plt.figure(figsize=figsize)\n    img = aplpy.FITSFigure(\n        fits_path,\n        hdu=hdu,\n        figure=fig,\n        downsample=downsample,\n        smooth=False,\n        convention=convention,\n    )  # Smooth here does something whack\n    img.set_theme(\"publication\")\n\n    beam_fwhm = 2.2\n    fwhm_to_sigma = 1.0 / (8 * np.log(2)) ** 0.5\n    beam_sigma = beam_fwhm * fwhm_to_sigma\n    omega_B = 2 * np.pi * beam_sigma**2\n\n    if units == \"snr\":\n        cbar_label = r\"$\\sigma$\"\n    elif units == \"uK\":\n        img._data *= np.sqrt(omega_B)\n        cbar_label = r\"$uK_{CMB}$\"\n    else:\n        cbar_label = str(units)\n\n    cmap = \"mymap\"\n    try:\n        cm.get_cmap(\n            cmap\n        )  # Stops these anoying messages if you've already registered mymap\n\n    except:\n        bottom = cm.get_cmap(\"Oranges\", 128)\n        top = cm.get_cmap(\"Blues_r\", 128)\n        newcolors = np.vstack(\n            (top(np.linspace(0, 1, 128)), bottom(np.linspace(0, 1, 128)))\n        )\n        cm.register_cmap(cmap, cmap=ListedColormap(newcolors))\n\n    if bound is None:\n        nx, ny = img._data.shape\n        lims = int(radius * 60 / pix_size)\n        xmin = int(nx / 2 - lims)\n        xmax = int(nx / 2 + lims)\n        ymin = int(ny / 2 - lims)\n        ymax = int(ny / 2 + lims)\n        bound = np.amax(np.abs(img._data[xmin:xmax, ymin:ymax]))\n        order = int(np.floor(np.log10(bound)))\n        bound = np.round(bound, -1 * order) / 2\n\n    img.show_colorscale(cmap=cmap, stretch=\"linear\", vmin=-bound, vmax=bound, smooth=1)\n\n    img.recenter(ra, dec, radius=radius / 60.0)\n    img.ax.tick_params(axis=\"both\", which=\"both\", direction=\"in\")\n\n    matplotlib.rcParams[\"lines.linewidth\"] = 3.0\n    img.add_scalebar(\n        0.5 / 60.0, '30\"', color=\"black\"\n    )  # Adds a 30 arcsec scalebar to the image\n\n    matplotlib.rcParams[\"lines.linewidth\"] = 2.0\n\n    img.add_beam(\n        major=120.0 / 3600.0, minor=120.0 / 3600.0, angle=0\n    )  # TODO: For now hard-coded to M2 beam but may want some flexibility later\n    img.beam.set_color(\"white\")\n    img.beam.set_edgecolor(\"green\")\n    img.beam.set_facecolor(\"white\")\n    img.beam.set_corner(\"bottom left\")\n\n    img.show_markers(\n        ra,\n        dec,\n        facecolor=\"black\",\n        edgecolor=None,\n        marker=\"+\",\n        s=50,\n        linewidths=2,\n        alpha=0.5,\n    )\n\n    img.add_colorbar(\"right\")\n    img.colorbar.set_width(0.12)\n    img.colorbar.set_axis_label_text(cbar_label)\n\n    if ncontours:\n        matplotlib.rcParams[\"lines.linewidth\"] = 0.5\n        clevels = np.linspace(-bound, bound, ncontours)\n        img.show_contour(\n            fits_path,\n            colors=\"gray\",\n            levels=clevels,\n            returnlevels=True,\n            convention=\"calabretta\",\n            smooth=3,\n        )\n\n    if plot_r:  # TODO: Allow passing of r500 values, make this a subfunction\n        if \"a10\" in cfg[\"model\"][\"structures\"].keys():\n            mod_type = \"a10\"\n        elif \"ea10\" in cfg[\"model\"][\"structures\"].keys():\n            mod_type = \"ea10\"\n        else:\n            raise ModelError(\"For R500, must have structure type A10 or EA10\")\n\n        for i in range(len(results.structures)):\n            if str(results.structures[i].name) == mod_type:\n                break\n\n        for parameter in results.structures[i].parameters:\n            if str(parameter.name.lower()) == \"m500\":\n                m500 = parameter.val\n                break\n\n        z = float(cfg[\"constants\"][\"z\"])\n        nz = get_nz(z)\n\n        r500 = (m500 / (4.00 * np.pi / 3.00) / 5.00e02 / nz) ** (1.00 / 3.00)\n        da = get_da(z)\n        r500 /= da\n        if plot_r == \"rs\":\n            r500 /= float(\n                cfg[\"model\"][\"structures\"][mod_type][\"parameters\"][\"c500\"][\"value\"]\n            )  # Convert to rs\n        img.show_circles(\n            ra, dec, radius=r500 / 3600, coords_frame=\"world\", color=\"green\"\n        )\n\n    return img\n</code></pre>"},{"location":"reference/structure/","title":"structure","text":"<p>Functions for generating structure. This includes both cluster profiles and substructure.</p>"},{"location":"reference/structure/#witch.structure.a10","title":"<code>a10(dx, dy, dz, theta, P0, c500, m500, gamma, alpha, beta, z, xyz)</code>","text":"<p>gNFW pressure profile in 3d based on Arnaud2010. Compared to the function gnfw, this function fixes r1/r2/r3 to r500. This function does not include smoothing or declination stretch which should be applied at the end.</p> <p>See the docstring for <code>gnfw</code> for more details.</p> <p>Parameters:</p> Name Type Description Default <code>dx</code> <code>float</code> <p>RA of cluster center relative to grid origin. Passed to <code>grid.transform_grid</code>. Units: arcsec</p> required <code>dy</code> <code>float</code> <p>Dec of cluster center relative to grid origin. Passed to <code>grid.transform_grid</code>. Units: arcsec</p> required <code>dz</code> <code>float</code> <p>Line of sight offset of cluster center relative to grid origin. Passed to <code>grid.transform_grid</code>. Units: arcsec</p> required <code>theta</code> <code>float</code> <p>Angle to rotate in xy-plane. Passed to <code>grid.transform_grid</code>. Units: radians</p> required <code>P0</code> <code>float</code> <p>Amplitude of the pressure profile Units: unitless</p> required <code>c500</code> <code>float</code> <p>Concentration parameter at a density contrast of 500 Units: unitless</p> required <code>m500</code> <code>float</code> <p>Mass at a density contrast of 500 Units: M_solar</p> required <code>gamma</code> <code>float</code> <p>The central slope Units: unitless</p> required <code>alpha</code> <code>float</code> <p>The intermediate slope Units: unitless</p> required <code>beta</code> <code>float</code> <p>The outer slope Units: unitless</p> required <code>z</code> <code>float</code> <p>Redshift of cluster Units: redshift</p> required <code>xyz</code> <code>tuple[Array, Array, Array, float, float]</code> <p>Coordinte grid to calculate model on. See <code>containers.Model.xyz</code> for details.</p> required <p>Returns:</p> Name Type Description <code>model</code> <code>Array</code> <p>The gnfw model evaluated on the grid.</p> Source code in <code>witch/structure.py</code> <pre><code>@jax.jit\ndef a10(\n    dx: float,\n    dy: float,\n    dz: float,\n    theta: float,\n    P0: float,\n    c500: float,\n    m500: float,\n    gamma: float,\n    alpha: float,\n    beta: float,\n    z: float,\n    xyz: tuple[jax.Array, jax.Array, jax.Array, float, float],\n) -&gt; jax.Array:\n    r\"\"\"\n    gNFW pressure profile in 3d based on [Arnaud2010](https://ui.adsabs.harvard.edu/abs/2010A%26A...517A..92A/).\n    Compared to the function gnfw, this function fixes r1/r2/r3 to r500.\n    This function does not include smoothing or declination stretch\n    which should be applied at the end.\n\n    See the docstring for `gnfw` for more details.\n\n    Parameters\n    ----------\n    dx : float\n        RA of cluster center relative to grid origin.\n        Passed to `grid.transform_grid`.\n        Units: arcsec\n    dy : float\n        Dec of cluster center relative to grid origin.\n        Passed to `grid.transform_grid`.\n        Units: arcsec\n    dz : float\n        Line of sight offset of cluster center relative to grid origin.\n        Passed to `grid.transform_grid`.\n        Units: arcsec\n    theta : float\n        Angle to rotate in xy-plane.\n        Passed to `grid.transform_grid`.\n        Units: radians\n    P0 : float\n        Amplitude of the pressure profile\n        Units: unitless\n    c500 : float\n        Concentration parameter at a density contrast of 500\n        Units: unitless\n    m500 : float\n        Mass at a density contrast of 500\n        Units: M_solar\n    gamma : float\n        The central slope\n        Units: unitless\n    alpha : float\n        The intermediate slope\n        Units: unitless\n    beta : float\n        The outer slope\n        Units: unitless\n    z : float\n        Redshift of cluster\n        Units: redshift\n    xyz : tuple[jax.Array, jax.Array, jax.Array, float, float]\n        Coordinte grid to calculate model on.\n        See `containers.Model.xyz` for details.\n\n    Returns\n    -------\n    model : jax.Array\n        The gnfw model evaluated on the grid.\n    \"\"\"\n\n    nz = get_nz(z)\n    hz = get_hz(z)\n    da = get_da(z)  # TODO pass these arguments rather than recompute them everytime???\n\n    r500 = (m500 / (4.00 * jnp.pi / 3.00) / 5.00e02 / nz) ** (1.00 / 3.00)\n    r_1, r_2, r_3 = r500 / da, r500 / da, r500 / da\n\n    x, y, z, *_ = transform_grid(dx, dy, dz, r_1, r_2, r_3, theta, xyz)\n\n    r = c500 * jnp.sqrt(x**2 + y**2 + z**2)\n    denominator = (r**gamma) * (1 + r**alpha) ** ((beta - gamma) / alpha)\n\n    P500 = (\n        1.65e-03\n        * (m500 / (3.00e14 / h70)) ** (2.00 / 3.00 + ap)\n        * hz ** (8.00 / 3.00)\n        * h70**2\n    )\n\n    return P500 * P0 / denominator\n</code></pre>"},{"location":"reference/structure/#witch.structure.add_exponential","title":"<code>add_exponential(pressure, xyz, dx, dy, dz, r_1, r_2, r_3, theta, amp, xk, x0, yk, y0, zk, z0)</code>","text":"<p>Add ellipsoid with exponential structure to 3d pressure profile.</p> <p>After transforming the grid the region where \\(\\sqrt{x^2 + y^2 + z^2} \\leq 1\\) will be multiplied by a factor of \\(1 + P_{0} e^{x_k(x-x_0) + y_k(y-y_0) + z_k(z-z_0)}\\) where \\(P_{0}\\) is <code>amp</code>.</p> <p>Parameters:</p> Name Type Description Default <code>pressure</code> <code>Array</code> <p>The pressure profile to modify with this ellipsoid. Should be evaluated on the same grid as <code>xyz</code>.</p> required <code>xyz</code> <code>tuple[Array, Array, Array, float, float]</code> <p>Coordinte grid to calculate model on. See <code>containers.Model.xyz</code> for details.</p> required <code>dx</code> <code>float</code> <p>RA of cluster center relative to grid origin. Passed to <code>grid.transform_grid</code>. Units: arcsec</p> required <code>dy</code> <code>float</code> <p>Dec of cluster center relative to grid origin. Passed to <code>grid.transform_grid</code>. Units: arcsec</p> required <code>dz</code> <code>float</code> <p>Line of sight offset of cluster center relative to grid origin. Passed to <code>grid.transform_grid</code>. Units: arcsec</p> required <code>r_1</code> <code>float</code> <p>Amount to scale along x-axis. The absolute value of these is degenerate with sigma. Units are arbitrary, only ratio of r_1/r_2, r_1/r_3, r_2/r_3 matters Passed to <code>grid.transform_grid</code>. Units: arbitrary</p> required <code>r_2</code> <code>float</code> <p>Amount to scale along y-axis. Passed to <code>grid.transform_grid</code>. Units: arbitrary</p> required <code>r_3</code> <code>float</code> <p>Amount to scale along z-axis. Passed to <code>grid.transform_grid</code>. Units: arbitrary</p> required <code>theta</code> <code>float</code> <p>Angle to rotate in xy-plane. Passed to <code>grid.transform_grid</code>. Units: radians</p> required <code>amp</code> <code>float</code> <p>Factor by which pressure is enhanced at the peak of ellipsoid. Units: unitless</p> required <code>xk</code> <code>float</code> <p>Power of exponential in RA direction Units: unitless</p> required <code>x0</code> <code>float</code> <p>RA offset of exponential. Note that this is in transformed coordinates so x0=1 is at xs + sr_1. Units: arcsec</p> required <code>yk</code> <code>float</code> <p>Power of exponential in Dec direction Units: unitless</p> required <code>y0</code> <code>float</code> <p>Dec offset of exponential. Note that this is in transformed coordinates so y0=1 is at ys + sr_2. Units: arcsec</p> required <code>zk</code> <code>float</code> <p>Power of exponential along the line of sight Units: unitless</p> required <code>z0</code> <code>float</code> <p>Line of sight offset of exponential. Note that this is in transformed coordinates so z0=1 is at zs + sr_3. Units: arcsec</p> required <p>Returns:</p> Name Type Description <code>new_pressure</code> <code>Array</code> <p>Pressure profile with ellipsoid added.</p> Source code in <code>witch/structure.py</code> <pre><code>@jax.jit\ndef add_exponential(\n    pressure: jax.Array,\n    xyz: tuple[jax.Array, jax.Array, jax.Array, float, float],\n    dx: float,\n    dy: float,\n    dz: float,\n    r_1: float,\n    r_2: float,\n    r_3: float,\n    theta: float,\n    amp: float,\n    xk: float,\n    x0: float,\n    yk: float,\n    y0: float,\n    zk: float,\n    z0: float,\n) -&gt; jax.Array:\n    r\"\"\"\n    Add ellipsoid with exponential structure to 3d pressure profile.\n\n    After transforming the grid the region where $\\sqrt{x^2 + y^2 + z^2} \\leq 1$\n    will be multiplied by a factor of $1 + P_{0} e^{x_k(x-x_0) + y_k(y-y_0) + z_k(z-z_0)}$\n    where $P_{0}$ is `amp`.\n\n    Parameters\n    ----------\n    pressure : jax.Array\n        The pressure profile to modify with this ellipsoid.\n        Should be evaluated on the same grid as `xyz`.\n    xyz : tuple[jax.Array, jax.Array, jax.Array, float, float]\n        Coordinte grid to calculate model on.\n        See `containers.Model.xyz` for details.\n    dx : float\n        RA of cluster center relative to grid origin.\n        Passed to `grid.transform_grid`.\n        Units: arcsec\n    dy : float\n        Dec of cluster center relative to grid origin.\n        Passed to `grid.transform_grid`.\n        Units: arcsec\n    dz : float\n        Line of sight offset of cluster center relative to grid origin.\n        Passed to `grid.transform_grid`.\n        Units: arcsec\n    r_1 : float\n        Amount to scale along x-axis. The absolute value of these is degenerate with sigma.\n        Units are arbitrary, only ratio of r_1/r_2, r_1/r_3, r_2/r_3 matters\n        Passed to `grid.transform_grid`.\n        Units: arbitrary\n    r_2 : float\n        Amount to scale along y-axis.\n        Passed to `grid.transform_grid`.\n        Units: arbitrary\n    r_3 : float\n        Amount to scale along z-axis.\n        Passed to `grid.transform_grid`.\n        Units: arbitrary\n    theta : float\n        Angle to rotate in xy-plane.\n        Passed to `grid.transform_grid`.\n        Units: radians\n    amp : float\n        Factor by which pressure is enhanced at the peak of ellipsoid.\n        Units: unitless\n    xk : float\n        Power of exponential in RA direction\n        Units: unitless\n    x0 : float\n        RA offset of exponential.\n        Note that this is in transformed coordinates so x0=1 is at xs + sr_1.\n        Units: arcsec\n    yk : float\n        Power of exponential in Dec direction\n        Units: unitless\n    y0 : float\n        Dec offset of exponential.\n        Note that this is in transformed coordinates so y0=1 is at ys + sr_2.\n        Units: arcsec\n    zk : float\n        Power of exponential along the line of sight\n        Units: unitless\n    z0 : float\n        Line of sight offset of exponential.\n        Note that this is in transformed coordinates so z0=1 is at zs + sr_3.\n        Units: arcsec\n\n    Returns\n    -------\n    new_pressure : Array\n        Pressure profile with ellipsoid added.\n    \"\"\"\n    x, y, z, *_ = transform_grid(dx, dy, dz, r_1, r_2, r_3, theta, xyz)\n\n    exponential = amp * jnp.exp(((x - x0) * xk) + ((y - y0) * yk) + ((z - z0) * zk))\n\n    new_pressure = jnp.where(\n        jnp.sqrt(x**2 + y**2 + z**2) &gt; 1, pressure, (1 + exponential) * pressure\n    )\n    return new_pressure\n</code></pre>"},{"location":"reference/structure/#witch.structure.add_powerlaw","title":"<code>add_powerlaw(pressure, xyz, dx, dy, dz, r_1, r_2, r_3, theta, amp, phi0, k_r, k_phi)</code>","text":"<p>Add ellipsoid with power law structure to 3d pressure profile.</p> <p>After transforming the grid the region where \\(\\sqrt{x^2 + y^2 + z^2} \\leq 1\\) will be multiplied by a factor of \\(1 + P_{0}(1 - {1 + r}^{-k_r})(1 - {1 + \\phi}^{-k_{\\phi}})\\). Where \\(r\\) and \\(\\phi\\) are the usual polar coordinates and \\(P_{0}\\) is <code>amp</code>.</p> <p>Parameters:</p> Name Type Description Default <code>pressure</code> <code>Array</code> <p>The pressure profile to modify with this ellipsoid. Should be evaluated on the same grid as <code>xyz</code>.</p> required <code>xyz</code> <code>tuple[Array, Array, Array, float, float]</code> <p>Coordinte grid to calculate model on. See <code>containers.Model.xyz</code> for details.</p> required <code>dx</code> <code>float</code> <p>RA of cluster center relative to grid origin. Passed to <code>grid.transform_grid</code>. Units: arcsec</p> required <code>dy</code> <code>float</code> <p>Dec of cluster center relative to grid origin. Passed to <code>grid.transform_grid</code>. Units: arcsec</p> required <code>dz</code> <code>float</code> <p>Line of sight offset of cluster center relative to grid origin. Passed to <code>grid.transform_grid</code>. Units: arcsec</p> required <code>r_1</code> <code>float</code> <p>Amount to scale along x-axis. The absolute value of these is degenerate with sigma. Units are arbitrary, only ratio of r_1/r_2, r_1/r_3, r_2/r_3 matters Passed to <code>grid.transform_grid</code>. Units: arbitrary</p> required <code>r_2</code> <code>float</code> <p>Amount to scale along y-axis. Passed to <code>grid.transform_grid</code>. Units: arbitrary</p> required <code>r_3</code> <code>float</code> <p>Amount to scale along z-axis. Passed to <code>grid.transform_grid</code>. Units: arbitrary</p> required <code>theta</code> <code>float</code> <p>Angle to rotate in xy-plane. Passed to <code>grid.transform_grid</code>. Units: radians</p> required <code>amp</code> <code>float</code> <p>Factor by which pressure is enhanced within the ellipsoid. Units: unitless</p> required <code>phi0</code> <code>float</code> <p>Polar angle of nose of power law. This is CCW from the x-axis, after the grid rotation. See arctan2 documentation Units: radians</p> required <code>k_r</code> <code>float</code> <p>Slope of power law in radial direction. Units: unitless</p> required <code>k_phi</code> <code>float</code> <p>Slope of power law in polar direction. Units: unitless</p> required <p>Returns:</p> Name Type Description <code>new_pressure</code> <code>Array</code> <p>Pressure profile with ellipsoid added.</p> Source code in <code>witch/structure.py</code> <pre><code>@jax.jit\ndef add_powerlaw(\n    pressure: jax.Array,\n    xyz: tuple[jax.Array, jax.Array, jax.Array, float, float],\n    dx: float,\n    dy: float,\n    dz: float,\n    r_1: float,\n    r_2: float,\n    r_3: float,\n    theta: float,\n    amp: float,\n    phi0: float,\n    k_r: float,\n    k_phi: float,\n) -&gt; jax.Array:\n    r\"\"\"\n    Add ellipsoid with power law structure to 3d pressure profile.\n\n    After transforming the grid the region where $\\sqrt{x^2 + y^2 + z^2} \\leq 1$\n    will be multiplied by a factor of $1 + P_{0}(1 - {1 + r}^{-k_r})(1 - {1 + \\phi}^{-k_{\\phi}})$.\n    Where $r$ and $\\phi$ are the usual polar coordinates and $P_{0}$ is `amp`.\n\n    Parameters\n    ----------\n    pressure : jax.Array\n        The pressure profile to modify with this ellipsoid.\n        Should be evaluated on the same grid as `xyz`.\n    xyz : tuple[jax.Array, jax.Array, jax.Array, float, float]\n        Coordinte grid to calculate model on.\n        See `containers.Model.xyz` for details.\n    dx : float\n        RA of cluster center relative to grid origin.\n        Passed to `grid.transform_grid`.\n        Units: arcsec\n    dy : float\n        Dec of cluster center relative to grid origin.\n        Passed to `grid.transform_grid`.\n        Units: arcsec\n    dz : float\n        Line of sight offset of cluster center relative to grid origin.\n        Passed to `grid.transform_grid`.\n        Units: arcsec\n    r_1 : float\n        Amount to scale along x-axis. The absolute value of these is degenerate with sigma.\n        Units are arbitrary, only ratio of r_1/r_2, r_1/r_3, r_2/r_3 matters\n        Passed to `grid.transform_grid`.\n        Units: arbitrary\n    r_2 : float\n        Amount to scale along y-axis.\n        Passed to `grid.transform_grid`.\n        Units: arbitrary\n    r_3 : float\n        Amount to scale along z-axis.\n        Passed to `grid.transform_grid`.\n        Units: arbitrary\n    theta : float\n        Angle to rotate in xy-plane.\n        Passed to `grid.transform_grid`.\n        Units: radians\n    amp : float\n        Factor by which pressure is enhanced within the ellipsoid.\n        Units: unitless\n    phi0 : float\n        Polar angle of nose of power law. This is CCW from the x-axis,\n        after the grid rotation. See arctan2 documentation\n        Units: radians\n    k_r : float\n        Slope of power law in radial direction.\n        Units: unitless\n    k_phi : float\n        Slope of power law in polar direction.\n        Units: unitless\n\n    Returns\n    -------\n    new_pressure : Array\n        Pressure profile with ellipsoid added.\n    \"\"\"\n    x, y, z, *_ = transform_grid(dx, dy, dz, r_1, r_2, r_3, theta, xyz)\n    r = jnp.sqrt(x**2 + y**2 + z**2)\n    phi = abs((jnp.arctan2(y, x) - phi0) % (2 * jnp.pi) - jnp.pi) / jnp.pi\n\n    powerlaw = (\n        amp\n        * (1 - jnp.float_power(1 + r, -1.0 * k_r))\n        * (1 - jnp.float_power(1 + phi, -1 * k_phi))\n    )\n    new_pressure = jnp.where(r &gt; 1, pressure, (1 + powerlaw) * pressure)\n    return new_pressure\n</code></pre>"},{"location":"reference/structure/#witch.structure.add_powerlaw_cos","title":"<code>add_powerlaw_cos(pressure, xyz, dx, dy, dz, r_1, r_2, r_3, theta, amp, phi0, k_r, omega)</code>","text":"<p>Add ellipsoid with radial power law and angular cosine dependant structure to 3d pressure profile.</p> <p>After transforming the grid the region where \\(\\sqrt{x^2 + y^2 + z^2} \\leq 1\\) will be multiplied by a factor of \\(1 + P_{0} ({1 + r}^{-k_r}) \\left| cos(\\omega\\phi) \\right|\\). Where \\(r\\) and \\(\\phi\\) are the usual polar coordinates and \\(P_{0}\\) is <code>amp</code>.</p> <p>Parameters:</p> Name Type Description Default <code>pressure</code> <code>Array</code> <p>The pressure profile to modify with this ellipsoid. Should be evaluated on the same grid as <code>xyz</code>.</p> required <code>xyz</code> <code>tuple[Array, Array, Array, float, float]</code> <p>Coordinte grid to calculate model on. See <code>containers.Model.xyz</code> for details.</p> required <code>dx</code> <code>float</code> <p>RA of cluster center relative to grid origin. Passed to <code>grid.transform_grid</code>. Units: arcsec</p> required <code>dy</code> <code>float</code> <p>Dec of cluster center relative to grid origin. Passed to <code>grid.transform_grid</code>. Units: arcsec</p> required <code>dz</code> <code>float</code> <p>Line of sight offset of cluster center relative to grid origin. Passed to <code>grid.transform_grid</code>. Units: arcsec</p> required <code>r_1</code> <code>float</code> <p>Amount to scale along x-axis. The absolute value of these is degenerate with sigma. Units are arbitrary, only ratio of r_1/r_2, r_1/r_3, r_2/r_3 matters Passed to <code>grid.transform_grid</code>. Units: arbitrary</p> required <code>r_2</code> <code>float</code> <p>Amount to scale along y-axis. Passed to <code>grid.transform_grid</code>. Units: unitless</p> required <code>r_3</code> <code>float</code> <p>Amount to scale along z-axis. Passed to <code>grid.transform_grid</code>. Units: unitless</p> required <code>theta</code> <code>float</code> <p>Angle to rotate in xy-plane. Passed to <code>grid.transform_grid</code>. Units: radians</p> required <code>amp</code> <code>float</code> <p>Factor by which pressure is enhanced within the ellipsoid. Units: unitless</p> required <code>phi0</code> <code>float</code> <p>Polar angle of nose of power law. This is CCW from the x-axis,  after the grid rotation. See arctan2 documentation  Units: radians</p> required <code>k_r</code> <code>float</code> <p>Slope of power law in radial direction. Units: unitless</p> required <code>omega</code> <code>float</code> <p>Angular freqency of the cosine term. Units: unitless</p> required <p>Returns:</p> Name Type Description <code>new_pressure</code> <code>Array</code> <p>Pressure profile with ellipsoid added.</p> Source code in <code>witch/structure.py</code> <pre><code>@jax.jit\ndef add_powerlaw_cos(\n    pressure: jax.Array,\n    xyz: tuple[jax.Array, jax.Array, jax.Array, float, float],\n    dx: float,\n    dy: float,\n    dz: float,\n    r_1: float,\n    r_2: float,\n    r_3: float,\n    theta: float,\n    amp: float,\n    phi0: float,\n    k_r: float,\n    omega: float,\n) -&gt; jax.Array:\n    r\"\"\"\n    Add ellipsoid with radial power law and angular cosine dependant structure to 3d pressure profile.\n\n    After transforming the grid the region where $\\sqrt{x^2 + y^2 + z^2} \\leq 1$\n    will be multiplied by a factor of $1 + P_{0} ({1 + r}^{-k_r}) \\left| cos(\\omega\\phi) \\right|$.\n    Where $r$ and $\\phi$ are the usual polar coordinates and $P_{0}$ is `amp`.\n\n    Parameters\n    ----------\n    pressure : jax.Array\n        The pressure profile to modify with this ellipsoid.\n        Should be evaluated on the same grid as `xyz`.\n    xyz : tuple[jax.Array, jax.Array, jax.Array, float, float]\n        Coordinte grid to calculate model on.\n        See `containers.Model.xyz` for details.\n    dx : float\n        RA of cluster center relative to grid origin.\n        Passed to `grid.transform_grid`.\n        Units: arcsec\n    dy : float\n        Dec of cluster center relative to grid origin.\n        Passed to `grid.transform_grid`.\n        Units: arcsec\n    dz : float\n        Line of sight offset of cluster center relative to grid origin.\n        Passed to `grid.transform_grid`.\n        Units: arcsec\n    r_1 : float\n        Amount to scale along x-axis. The absolute value of these is degenerate with sigma.\n        Units are arbitrary, only ratio of r_1/r_2, r_1/r_3, r_2/r_3 matters\n        Passed to `grid.transform_grid`.\n        Units: arbitrary\n    r_2 : float\n        Amount to scale along y-axis.\n        Passed to `grid.transform_grid`.\n        Units: unitless\n    r_3 : float\n        Amount to scale along z-axis.\n        Passed to `grid.transform_grid`.\n        Units: unitless\n    theta : float\n        Angle to rotate in xy-plane.\n        Passed to `grid.transform_grid`.\n        Units: radians\n    amp : float\n        Factor by which pressure is enhanced within the ellipsoid.\n        Units: unitless\n    phi0 : float\n         Polar angle of nose of power law. This is CCW from the x-axis,\n         after the grid rotation. See arctan2 documentation\n         Units: radians\n    k_r : float\n        Slope of power law in radial direction.\n        Units: unitless\n    omega : float\n        Angular freqency of the cosine term.\n        Units: unitless\n\n    Returns\n    -------\n    new_pressure : Array\n        Pressure profile with ellipsoid added.\n    \"\"\"\n    x, y, z, *_ = transform_grid(dx, dy, dz, r_1, r_2, r_3, theta, xyz)\n    r = jnp.sqrt(x**2 + y**2 + z**2)\n    phi = (jnp.arctan2(y, x) - phi0) % (2 * jnp.pi)\n\n    powerlaw = amp * jnp.abs(jnp.cos(omega * phi)) * jnp.float_power(r, k_r)\n    new_pressure = jnp.where(r &gt; 1, pressure, (1 + powerlaw) * pressure)\n    return new_pressure\n</code></pre>"},{"location":"reference/structure/#witch.structure.add_uniform","title":"<code>add_uniform(pressure, xyz, dx, dy, dz, r_1, r_2, r_3, theta, amp)</code>","text":"<p>Add ellipsoid with uniform structure to 3d pressure profile.</p> <p>After transforming the grid the region where \\(\\sqrt{x^2 + y^2 + z^2} \\leq 1\\) will be multiplied by a factor of \\(1 + P_{0}\\) where \\(P_{0}\\) is <code>amp</code>.</p> <p>Parameters:</p> Name Type Description Default <code>pressure</code> <code>Array</code> <p>The pressure profile to modify with this ellipsoid. Should be evaluated on the same grid as <code>xyz</code>.</p> required <code>xyz</code> <code>tuple[Array, Array, Array, float, float]</code> <p>Coordinte grid to calculate model on. See <code>containers.Model.xyz</code> for details.</p> required <code>dx</code> <code>float</code> <p>RA of cluster center relative to grid origin. Passed to <code>grid.transform_grid</code>. Units: arcsec</p> required <code>dy</code> <code>float</code> <p>Dec of cluster center relative to grid origin. Passed to <code>grid.transform_grid</code>. Units: arcsec</p> required <code>dz</code> <code>float</code> <p>Line of sight offset of cluster center relative to grid origin. Passed to <code>grid.transform_grid</code>. Units: arcsec</p> required <code>r_1</code> <code>float</code> <p>Amount to scale along x-axis. The absolute value of these is degenerate with sigma. Units are arbitrary, only ratio of r_1/r_2, r_1/r_3, r_2/r_3 matters Passed to <code>grid.transform_grid</code>. Units: arbitrary</p> required <code>r_2</code> <code>float</code> <p>Amount to scale along y-axis. Passed to <code>grid.transform_grid</code>. Units: arbitrary</p> required <code>r_3</code> <code>float</code> <p>Amount to scale along z-axis. Passed to <code>grid.transform_grid</code>. Units: arbitrary</p> required <code>theta</code> <code>float</code> <p>Angle to rotate in xy-plane. Passed to <code>grid.transform_grid</code>. Units: radians</p> required <code>amp</code> <code>float</code> <p>Factor by which pressure is enhanced within the ellipsoid. Units: unitless</p> required <p>Returns:</p> Name Type Description <code>new_pressure</code> <code>Array</code> <p>Pressure profile with ellipsoid added.</p> Source code in <code>witch/structure.py</code> <pre><code>@jax.jit\ndef add_uniform(\n    pressure: jax.Array,\n    xyz: tuple[jax.Array, jax.Array, jax.Array, float, float],\n    dx: float,\n    dy: float,\n    dz: float,\n    r_1: float,\n    r_2: float,\n    r_3: float,\n    theta: float,\n    amp: float,\n) -&gt; jax.Array:\n    r\"\"\"\n    Add ellipsoid with uniform structure to 3d pressure profile.\n\n    After transforming the grid the region where $\\sqrt{x^2 + y^2 + z^2} \\leq 1$\n    will be multiplied by a factor of $1 + P_{0}$ where $P_{0}$ is `amp`.\n\n    Parameters\n    ----------\n    pressure : jax.Array\n        The pressure profile to modify with this ellipsoid.\n        Should be evaluated on the same grid as `xyz`.\n    xyz : tuple[jax.Array, jax.Array, jax.Array, float, float]\n        Coordinte grid to calculate model on.\n        See `containers.Model.xyz` for details.\n    dx : float\n        RA of cluster center relative to grid origin.\n        Passed to `grid.transform_grid`.\n        Units: arcsec\n    dy : float\n        Dec of cluster center relative to grid origin.\n        Passed to `grid.transform_grid`.\n        Units: arcsec\n    dz : float\n        Line of sight offset of cluster center relative to grid origin.\n        Passed to `grid.transform_grid`.\n        Units: arcsec\n    r_1 : float\n        Amount to scale along x-axis. The absolute value of these is degenerate with sigma.\n        Units are arbitrary, only ratio of r_1/r_2, r_1/r_3, r_2/r_3 matters\n        Passed to `grid.transform_grid`.\n        Units: arbitrary\n    r_2 : float\n        Amount to scale along y-axis.\n        Passed to `grid.transform_grid`.\n        Units: arbitrary\n    r_3 : float\n        Amount to scale along z-axis.\n        Passed to `grid.transform_grid`.\n        Units: arbitrary\n    theta : float\n        Angle to rotate in xy-plane.\n        Passed to `grid.transform_grid`.\n        Units: radians\n    amp : float\n        Factor by which pressure is enhanced within the ellipsoid.\n        Units: unitless\n\n    Returns\n    -------\n    new_pressure : Array\n        Pressure profile with ellipsoid added.\n    \"\"\"\n    x, y, z, *_ = transform_grid(dx, dy, dz, r_1, r_2, r_3, theta, xyz)\n\n    new_pressure = jnp.where(\n        jnp.sqrt(x**2 + y**2 + z**2) &gt; 1, pressure, (1 + amp) * pressure\n    )\n    return new_pressure\n</code></pre>"},{"location":"reference/structure/#witch.structure.cylindrical_beta","title":"<code>cylindrical_beta(dx, dy, dz, L, theta, P0, r_c, beta, xyz)</code>","text":"<p>This function does not include smoothing or declination stretch which should be applied at the end.</p> <p>Once the grid is transformed the profile is computed as:</p> \\[ P_{0}\\left( 1 + \\frac{y^2 + z^2}{{r_c}^2} \\right)^{-1.5\\beta} \\] <p>Parameters:</p> Name Type Description Default <code>dx</code> <code>float</code> <p>RA of cluster center relative to grid origin. Passed to <code>grid.transform_grid</code>. Units: arcsec</p> required <code>dy</code> <code>float</code> <p>Dec of cluster center relative to grid origin. Passed to <code>grid.transform_grid</code>. Units: arcsec</p> required <code>dz</code> <code>float</code> <p>Line of sight offset of cluster center relative to grid origin. Passed to <code>grid.transform_grid</code>. Units: arcsec</p> required <code>L</code> <code>float</code> <p>Length of the cylinder. Aligned with the x-axis. Note that we consider anything where \\(\\left| x \\right| \\\\leq L\\) to be in the profile, so the actual length is \\(2L\\). Units: arcsec</p> required <code>theta</code> <code>float</code> <p>Angle to rotate in xy-plane. Passed to <code>grid.transform_grid</code>. Units: radians</p> required <code>P0</code> <code>float</code> <p>Amplitude of the pressure profile. Units: unitless</p> required <code>r_c</code> <code>float</code> <p>The critical radius of the cylindrical profile. Units: arcsec</p> required <code>beta</code> <code>float</code> <p>Beta value of isobeta model. Units: unitless</p> required <code>xyz</code> <code>tuple[Array, Array, Array, float, float]</code> <p>Coordinte grid to calculate model on. See <code>containers.Model.xyz</code> for details.</p> required <p>Returns:</p> Name Type Description <code>model</code> <code>Array</code> <p>The cylindrical beta model evaluated on the grid.</p> Source code in <code>witch/structure.py</code> <pre><code>@jax.jit\ndef cylindrical_beta(\n    dx: float,\n    dy: float,\n    dz: float,\n    L: float,\n    theta: float,\n    P0: float,\n    r_c: float,\n    beta: float,\n    xyz: tuple[jax.Array, jax.Array, jax.Array, float, float],\n) -&gt; jax.Array:\n    r\"\"\"\n\n    This function does not include smoothing or declination stretch\n    which should be applied at the end.\n\n    Once the grid is transformed the profile is computed as:\n\n    $$\n    P_{0}\\left( 1 + \\frac{y^2 + z^2}{{r_c}^2} \\right)^{-1.5\\beta}\n    $$\n\n    Parameters\n    ----------\n    dx : float\n        RA of cluster center relative to grid origin.\n        Passed to `grid.transform_grid`.\n        Units: arcsec\n    dy : float\n        Dec of cluster center relative to grid origin.\n        Passed to `grid.transform_grid`.\n        Units: arcsec\n    dz : float\n        Line of sight offset of cluster center relative to grid origin.\n        Passed to `grid.transform_grid`.\n        Units: arcsec\n    L : float\n        Length of the cylinder.\n        Aligned with the x-axis.\n        Note that we consider anything where $\\left| x \\right| \\\\leq L$\n        to be in the profile, so the actual length is $2L$.\n        Units: arcsec\n    theta : float\n        Angle to rotate in xy-plane.\n        Passed to `grid.transform_grid`.\n        Units: radians\n    P0 : float\n        Amplitude of the pressure profile.\n        Units: unitless\n    r_c : float\n        The critical radius of the cylindrical profile.\n        Units: arcsec\n    beta : float\n        Beta value of isobeta model.\n        Units: unitless\n    xyz : tuple[jax.Array, jax.Array, jax.Array, float, float]\n        Coordinte grid to calculate model on.\n        See `containers.Model.xyz` for details.\n\n    Returns\n    -------\n    model : jax.Array\n        The cylindrical beta model evaluated on the grid.\n    \"\"\"\n    x, y, z, *_ = transform_grid(dx, dy, dz, 1.0, 1.0, 1.0, theta, xyz)\n    r = jnp.sqrt(y**2 + z**2)\n    powerlaw = P0 / (1.0 + (r / r_c) ** 2) ** (3.0 / 2.0 * beta)\n\n    pressure = jnp.where(jnp.abs(x) &gt;= L / 2.0, 0, powerlaw)\n\n    return pressure\n</code></pre>"},{"location":"reference/structure/#witch.structure.cylindrical_beta_2d","title":"<code>cylindrical_beta_2d(dx, dy, dz, L, theta, phi, P0, r_c, beta, xyz)</code>","text":"<p>Same as cylindrical_beta but compute 2D profile analytically. Should be faster than 3D integration. Useful when you are not modifying the 3D grid. Also includes the LoS angle phi.</p> <p>Once the grid is transformed the profile is computed as:</p> \\[ y(R) = \\frac{\\sqrt{\\pi} \\Gamma (3\\beta/2 - 1/2)}{\\Gamma(3\\beta /2)} \\sec{\\phi} P_0 r_c [1+\\frac{R}{r_c}^2]^{-3\\beta /2 + 1/2} \\] <p>Note the missing factor of</p> \\[ \\frac{\\sigma_T}{m_e c^2} \\] <p>is provided by the unit conversion functionality.</p> <p>Derivation from Craig Sarazin</p> <p>Parameters:</p> Name Type Description Default <code>dx</code> <code>float</code> <p>RA of cluster center relative to grid origin. Passed to <code>grid.transform_grid</code>. Units: arcsec</p> required <code>dy</code> <code>float</code> <p>Dec of cluster center relative to grid origin. Passed to <code>grid.transform_grid</code>. Units: arcsec</p> required <code>dz</code> <code>float</code> <p>Line of sight offset of cluster center relative to grid origin. Passed to <code>grid.transform_grid</code>. Units: arcsec</p> required <code>L</code> <code>float</code> <p>Length of the cylinder. Aligned with the x-axis. Note that we consider anything where \\(\\left| x \\right| \\\\leq L\\) to be in the profile, so the actual length is \\(2L\\). Units: arcsec</p> required <code>theta</code> <code>float</code> <p>Angle to rotate in xy-plane. Passed to <code>grid.transform_grid</code>. Units: radians</p> required <code>phi</code> <code>float</code> <p>Angle to rotate in xz-plane Units: radians</p> required <code>P0</code> <code>float</code> <p>Amplitude of the pressure profile. Units: unitless</p> required <code>r_c</code> <code>float</code> <p>The critical radius of the cylindrical profile. Units: arcsec</p> required <code>beta</code> <code>float</code> <p>Beta value of isobeta model. Units: unitless</p> required <code>xyz</code> <code>tuple[Array, Array, Array, float, float]</code> <p>Coordinte grid to calculate model on. See <code>containers.Model.xyz</code> for details.</p> required <p>Returns:</p> Name Type Description <code>model</code> <code>Array</code> <p>The cylindrical beta model evaluated on the grid.</p> Source code in <code>witch/structure.py</code> <pre><code>@jax.jit\ndef cylindrical_beta_2d(\n    dx: float,\n    dy: float,\n    dz: float,\n    L: float,\n    theta: float,\n    phi: float,\n    P0: float,\n    r_c: float,\n    beta: float,\n    xyz: tuple[jax.Array, jax.Array, jax.Array, float, float],\n) -&gt; jax.Array:\n    r\"\"\"\n\n    Same as cylindrical_beta but compute 2D profile analytically.\n    Should be faster than 3D integration. Useful when you are\n    not modifying the 3D grid. Also includes the LoS angle phi.\n\n    Once the grid is transformed the profile is computed as:\n\n    $$\n    y(R) = \\frac{\\sqrt{\\pi} \\Gamma (3\\beta/2 - 1/2)}{\\Gamma(3\\beta /2)} \\sec{\\phi} P_0 r_c [1+\\frac{R}{r_c}^2]^{-3\\beta /2 + 1/2}\n    $$\n\n    Note the missing factor of\n\n    $$\n    \\frac{\\sigma_T}{m_e c^2}\n    $$\n\n    is provided by the unit conversion functionality.\n\n    Derivation from Craig Sarazin\n    Parameters\n    ----------\n    dx : float\n        RA of cluster center relative to grid origin.\n        Passed to `grid.transform_grid`.\n        Units: arcsec\n    dy : float\n        Dec of cluster center relative to grid origin.\n        Passed to `grid.transform_grid`.\n        Units: arcsec\n    dz : float\n        Line of sight offset of cluster center relative to grid origin.\n        Passed to `grid.transform_grid`.\n        Units: arcsec\n    L : float\n        Length of the cylinder.\n        Aligned with the x-axis.\n        Note that we consider anything where $\\left| x \\right| \\\\leq L$\n        to be in the profile, so the actual length is $2L$.\n        Units: arcsec\n    theta : float\n        Angle to rotate in xy-plane.\n        Passed to `grid.transform_grid`.\n        Units: radians\n    phi : float\n        Angle to rotate in xz-plane\n        Units: radians\n    P0 : float\n        Amplitude of the pressure profile.\n        Units: unitless\n    r_c : float\n        The critical radius of the cylindrical profile.\n        Units: arcsec\n    beta : float\n        Beta value of isobeta model.\n        Units: unitless\n    xyz : tuple[jax.Array, jax.Array, jax.Array, float, float]\n        Coordinte grid to calculate model on.\n        See `containers.Model.xyz` for details.\n\n    Returns\n    -------\n    model : jax.Array\n        The cylindrical beta model evaluated on the grid.\n    \"\"\"\n    x, y, *_ = transform_grid(dx, dy, dz, 1.0, 1.0, 1.0, theta, xyz)\n    rr = x[..., 0] ** 2 + y[..., 0] ** 2\n\n    gamma_term = (\n        jnp.sqrt(jnp.pi) * jax.scipy.special.gamma(3 * beta / 2 - 1 / 2)\n    ) / jax.scipy.special.gamma(3 * beta / 2)\n\n    r_term = (1 + (rr / r_c) ** 2) ** (-3 * beta / 2 + 1 / 2)\n\n    return gamma_term * 1 / jnp.cos(phi) * (P0 * r_c) * r_term\n</code></pre>"},{"location":"reference/structure/#witch.structure.ea10","title":"<code>ea10(dx, dy, dz, r_1, r_2, r_3, theta, P0, c500, m500, gamma, alpha, beta, z, xyz)</code>","text":"<p>Eliptical gNFW pressure profile in 3d based on Arnaud2010. r_ell is computed in the usual way for an a10 profile, then the axes are scaled according to r_1, r_2, r_3, with a normalization applied. This function does not include smoothing or declination stretch which should be applied at the end.</p> <p>See the docstring for <code>gnfw</code> for more details.</p> <p>Parameters:</p> Name Type Description Default <code>dx</code> <code>float</code> <p>RA of cluster center relative to grid origin. Passed to <code>grid.transform_grid</code>. Units: arcsec</p> required <code>dy</code> <code>float</code> <p>Dec of cluster center relative to grid origin. Passed to <code>grid.transform_grid</code>. Units: arcsec</p> required <code>dz</code> <code>float</code> <p>Line of sight offset of cluster center relative to grid origin. Passed to <code>grid.transform_grid</code>. Units: arcsec</p> required <code>r_1</code> <code>float</code> <p>Amount to scale along x-axis. Units are arbitrary, only ratio of r_1/r_2, r_1/r_3, r_2/r_3 matters Passed to <code>grid.transform_grid</code>. Units: arbitrary</p> required <code>r_2</code> <code>float</code> <p>Amount to scale along y-axis. Passed to <code>grid.transform_grid</code>. Units: arbitrary</p> required <code>r_3</code> <code>float</code> <p>Amount to scale along z-axis. Passed to <code>grid.transform_grid</code>. Units: arbitrary</p> required <code>theta</code> <code>float</code> <p>Angle to rotate in xy-plane. Passed to <code>grid.transform_grid</code>. Units: radians</p> required <code>P0</code> <code>float</code> <p>Amplitude of the pressure profile Units: unitless</p> required <code>c500</code> <code>float</code> <p>Concentration parameter at a density contrast of 500 Units: unitless</p> required <code>m500</code> <code>float</code> <p>Mass at a density contrast of 500 Units: M_solar</p> required <code>gamma</code> <code>float</code> <p>The central slope Units: unitless</p> required <code>alpha</code> <code>float</code> <p>The intermediate slope Units: unitless</p> required <code>beta</code> <code>float</code> <p>The outer slope Units: unitless</p> required <code>z</code> <code>float</code> <p>Redshift of cluster Units: redshift</p> required <code>xyz</code> <code>tuple[Array, Array, Array, float, float]</code> <p>Coordinte grid to calculate model on. See <code>containers.Model.xyz</code> for details.</p> required <p>Returns:</p> Name Type Description <code>model</code> <code>Array</code> <p>The gnfw model evaluated on the grid.</p> Source code in <code>witch/structure.py</code> <pre><code>@jax.jit\ndef ea10(\n    dx: float,\n    dy: float,\n    dz: float,\n    r_1: float,\n    r_2: float,\n    r_3: float,\n    theta: float,\n    P0: float,\n    c500: float,\n    m500: float,\n    gamma: float,\n    alpha: float,\n    beta: float,\n    z: float,\n    xyz: tuple[jax.Array, jax.Array, jax.Array, float, float],\n) -&gt; jax.Array:\n    r\"\"\"\n    Eliptical gNFW pressure profile in 3d based on Arnaud2010.\n    r_ell is computed in the usual way for an a10 profile, then the axes are\n    scaled according to r_1, r_2, r_3, with a normalization applied.\n    This function does not include smoothing or declination stretch\n    which should be applied at the end.\n\n    See the docstring for `gnfw` for more details.\n\n    Parameters\n    ----------\n    dx : float\n        RA of cluster center relative to grid origin.\n        Passed to `grid.transform_grid`.\n        Units: arcsec\n    dy : float\n        Dec of cluster center relative to grid origin.\n        Passed to `grid.transform_grid`.\n        Units: arcsec\n    dz : float\n        Line of sight offset of cluster center relative to grid origin.\n        Passed to `grid.transform_grid`.\n        Units: arcsec\n    r_1 : float\n        Amount to scale along x-axis.\n        Units are arbitrary, only ratio of r_1/r_2, r_1/r_3, r_2/r_3 matters\n        Passed to `grid.transform_grid`.\n        Units: arbitrary\n    r_2 : float\n        Amount to scale along y-axis.\n        Passed to `grid.transform_grid`.\n        Units: arbitrary\n    r_3 : float\n        Amount to scale along z-axis.\n        Passed to `grid.transform_grid`.\n        Units: arbitrary\n    theta : float\n        Angle to rotate in xy-plane.\n        Passed to `grid.transform_grid`.\n        Units: radians\n    P0 : float\n        Amplitude of the pressure profile\n        Units: unitless\n    c500 : float\n        Concentration parameter at a density contrast of 500\n        Units: unitless\n    m500 : float\n        Mass at a density contrast of 500\n        Units: M_solar\n    gamma : float\n        The central slope\n        Units: unitless\n    alpha : float\n        The intermediate slope\n        Units: unitless\n    beta : float\n        The outer slope\n        Units: unitless\n    z : float\n        Redshift of cluster\n        Units: redshift\n    xyz : tuple[jax.Array, jax.Array, jax.Array, float, float]\n        Coordinte grid to calculate model on.\n        See `containers.Model.xyz` for details.\n\n    Returns\n    -------\n    model : jax.Array\n        The gnfw model evaluated on the grid.\n    \"\"\"\n    nz = get_nz(z)\n    hz = get_hz(z)\n    da = get_da(z)  # TODO pass these arguments rather than recompute them everytime???\n\n    r500 = (m500 / (4.00 * jnp.pi / 3.00) / 5.00e02 / nz) ** (1.00 / 3.00)\n    r_ell = r500 / da\n    r_norm = (r_1 * r_2 * r_3) ** (1 / 3)\n\n    r_1 *= r_ell / r_norm\n    r_2 *= r_ell / r_norm\n    r_3 *= r_ell / r_norm\n\n    x, y, z, *_ = transform_grid(dx, dy, dz, r_1, r_2, r_3, theta, xyz)\n\n    r = c500 * jnp.sqrt(x**2 + y**2 + z**2)\n    denominator = (r**gamma) * (1 + r**alpha) ** ((beta - gamma) / alpha)\n\n    P500 = (\n        1.65e-03\n        * (m500 / (3.00e14 / h70)) ** (2.00 / 3.00 + ap)\n        * hz ** (8.00 / 3.00)\n        * h70**2\n    )\n\n    return P500 * P0 / denominator\n</code></pre>"},{"location":"reference/structure/#witch.structure.egaussian","title":"<code>egaussian(dx, dy, dz, r_1, r_2, r_3, theta, sigma, amp, xyz)</code>","text":"<p>Elliptical gaussian profile in 3d. This function does not include smoothing or declination stretch which should be applied at the end.</p> <p>Once the grid is transformed the profile is computed as:</p> \\[ P_{0} e^{-\\frac{x^2 + y^2 + z^2}{2\\sigma^2}} \\] <p>where \\(P_{0}\\) is <code>amp</code>.</p> <p>Parameters:</p> Name Type Description Default <code>dx</code> <code>float</code> <p>RA of cluster center relative to grid origin. Passed to <code>grid.transform_grid</code>. Units: arcsec</p> required <code>dy</code> <code>float</code> <p>Dec of cluster center relative to grid origin. Passed to <code>grid.transform_grid</code>. Units: arcsec</p> required <code>dz</code> <code>float</code> <p>Line of sight offset of cluster center relative to grid origin. Passed to <code>grid.transform_grid</code>. Units: arcsec</p> required <code>r_1</code> <code>float</code> <p>Amount to scale along x-axis. The absolute value of these is degenerate with sigma. Units are arbitrary, only ratio of r_1/r_2, r_1/r_3, r_2/r_3 matters Passed to <code>grid.transform_grid</code>. Units: arbitrary</p> required <code>r_2</code> <code>float</code> <p>Amount to scale along y-axis. Passed to <code>grid.transform_grid</code>. Units: arbitrary</p> required <code>r_3</code> <code>float</code> <p>Amount to scale along z-axis. Passed to <code>grid.transform_grid</code>. Units: arbitrary</p> required <code>theta</code> <code>float</code> <p>Angle to rotate in xy-plane. Passed to <code>grid.transform_grid</code>. Units: radians</p> required <code>sigma</code> <code>float</code> <p>Sigma value of gaussian model. Units: arcsec</p> required <code>amp</code> <code>float</code> <p>Amplitude of gaussian model. Units: Jy</p> required <code>xyz</code> <code>tuple[Array, Array, Array, float, float]</code> <p>Coordinte grid to calculate model on. See <code>containers.Model.xyz</code> for details.</p> required <p>Returns:</p> Name Type Description <code>model</code> <code>Array</code> <p>The gaussain model evaluated on the grid.</p> Source code in <code>witch/structure.py</code> <pre><code>@jax.jit\ndef egaussian(\n    dx: float,\n    dy: float,\n    dz: float,\n    r_1: float,\n    r_2: float,\n    r_3: float,\n    theta: float,\n    sigma: float,\n    amp: float,\n    xyz: tuple[jax.Array, jax.Array, jax.Array, float, float],\n) -&gt; jax.Array:\n    r\"\"\"\n    Elliptical gaussian profile in 3d.\n    This function does not include smoothing or declination stretch\n    which should be applied at the end.\n\n    Once the grid is transformed the profile is computed as:\n\n    $$\n    P_{0} e^{-\\frac{x^2 + y^2 + z^2}{2\\sigma^2}}\n    $$\n\n    where $P_{0}$ is `amp`.\n\n    Parameters\n    ----------\n    dx : float\n        RA of cluster center relative to grid origin.\n        Passed to `grid.transform_grid`.\n        Units: arcsec\n    dy : float\n        Dec of cluster center relative to grid origin.\n        Passed to `grid.transform_grid`.\n        Units: arcsec\n    dz : float\n        Line of sight offset of cluster center relative to grid origin.\n        Passed to `grid.transform_grid`.\n        Units: arcsec\n    r_1 : float\n        Amount to scale along x-axis. The absolute value of these is degenerate with sigma.\n        Units are arbitrary, only ratio of r_1/r_2, r_1/r_3, r_2/r_3 matters\n        Passed to `grid.transform_grid`.\n        Units: arbitrary\n    r_2 : float\n        Amount to scale along y-axis.\n        Passed to `grid.transform_grid`.\n        Units: arbitrary\n    r_3 : float\n        Amount to scale along z-axis.\n        Passed to `grid.transform_grid`.\n        Units: arbitrary\n    theta : float\n        Angle to rotate in xy-plane.\n        Passed to `grid.transform_grid`.\n        Units: radians\n    sigma : float\n        Sigma value of gaussian model.\n        Units: arcsec\n    amp : float\n        Amplitude of gaussian model.\n        Units: Jy\n    xyz : tuple[jax.Array, jax.Array, jax.Array, float, float]\n        Coordinte grid to calculate model on.\n        See `containers.Model.xyz` for details.\n\n    Returns\n    -------\n    model : jax.Array\n        The gaussain model evaluated on the grid.\n    \"\"\"\n    x, y, z, *_ = transform_grid(dx, dy, dz, r_1, r_2, r_3, theta, xyz)\n\n    rr = x**2 + y**2 + z**2\n    power = -1 * rr / (2 * sigma**2)\n\n    return amp * jnp.exp(power)\n</code></pre>"},{"location":"reference/structure/#witch.structure.egnfw","title":"<code>egnfw(dx, dy, dz, r_1, r_2, r_3, theta, P0, c500, m500, gamma, alpha, beta, z, xyz)</code>","text":"<p>Elliptical gNFW pressure profile in 3d. This function does not include smoothing or declination stretch which should be applied at the end. TODO: Add units to add parameters!</p> <p>Once the grid is transformed the profile is computed as:</p> \\[ \\dfrac{P_{500} * P_{0}}{{\\left( r^{\\gamma}\\left( 1 + r^{\\alpha} \\right) \\right)}^{\\dfrac{\\beta - \\gamma}{\\alpha}}} \\] <p>where:</p> \\[ r = c_{500} \\sqrt{x^2 + y^2 + z^2} {\\frac{3m_{500}}{2000 \\pi n_z}}^{-\\frac{1}{3}} \\] \\[ P_{500} = 1.65 \\times 10^{-3} {\\frac{m_{500}*h_{70}}{3 \\times 10^{14}}}^{\\frac{2}{3} + ap}{h_z}^{\\frac{8}{3}}{h_{70}}^2 \\] <p>\\(n_z\\) is the critical density at the cluster redshift and \\(h_z\\) is the Hubble constant at the cluster redshift.</p> <p>Parameters:</p> Name Type Description Default <code>dx</code> <code>float</code> <p>RA of cluster center relative to grid origin. Passed to <code>grid.transform_grid</code>. Units: arcsec</p> required <code>dy</code> <code>float</code> <p>Dec of cluster center relative to grid origin. Passed to <code>grid.transform_grid</code>. Units: arcsec</p> required <code>dz</code> <code>float</code> <p>Line of sight offset of cluster center relative to grid origin. Passed to <code>grid.transform_grid</code>. Units: arcsec</p> required <code>r_1</code> <code>float</code> <p>Amount to scale along x-axis. Units are arbitrary, only ratio of r_1/r_2, r_1/r_3, r_2/r_3 matters Passed to <code>grid.transform_grid</code>. Units: arbitrary</p> required <code>r_2</code> <code>float</code> <p>Amount to scale along y-axis. Passed to <code>grid.transform_grid</code>.</p> required <code>r_3</code> <code>float</code> <p>Amount to scale along z-axis. Passed to <code>grid.transform_grid</code>.</p> required <code>theta</code> <code>float</code> <p>Angle to rotate in xy-plane. Passed to <code>grid.transform_grid</code>. Units: radians</p> required <code>P0</code> <code>float</code> <p>Amplitude of the pressure profile. Units: unitless</p> required <code>c500</code> <code>float</code> <p>Concentration parameter at a density contrast of 500. Units: unitless</p> required <code>m500</code> <code>float</code> <p>Mass at a density contrast of 500. Units: M_solar</p> required <code>gamma</code> <code>float</code> <p>The central slope. Units: unitless</p> required <code>alpha</code> <code>float</code> <p>The intermediate slope. Units: unitless</p> required <code>beta</code> <code>float</code> <p>The outer slope. Units: unitless</p> required <code>z</code> <code>float</code> <p>Redshift of cluster. Units: redshift</p> required <code>xyz</code> <code>tuple[Array, Array, Array, float, float]</code> <p>Coordinte grid to calculate model on. See <code>containers.Model.xyz</code> for details.</p> required <p>Returns:</p> Name Type Description <code>model</code> <code>Array</code> <p>The gnfw model evaluated on the grid.</p> Source code in <code>witch/structure.py</code> <pre><code>@jax.jit\ndef egnfw(\n    dx: float,\n    dy: float,\n    dz: float,\n    r_1: float,\n    r_2: float,\n    r_3: float,\n    theta: float,\n    P0: float,\n    c500: float,\n    m500: float,\n    gamma: float,\n    alpha: float,\n    beta: float,\n    z: float,\n    xyz: tuple[jax.Array, jax.Array, jax.Array, float, float],\n) -&gt; jax.Array:\n    r\"\"\"\n    Elliptical gNFW pressure profile in 3d.\n    This function does not include smoothing or declination stretch\n    which should be applied at the end.\n    TODO: Add units to add parameters!\n\n    Once the grid is transformed the profile is computed as:\n\n    $$\n    \\dfrac{P_{500} * P_{0}}{{\\left( r^{\\gamma}\\left( 1 + r^{\\alpha} \\right) \\right)}^{\\dfrac{\\beta - \\gamma}{\\alpha}}}\n    $$\n\n    where:\n\n    $$\n    r = c_{500} \\sqrt{x^2 + y^2 + z^2} {\\frac{3m_{500}}{2000 \\pi n_z}}^{-\\frac{1}{3}}\n    $$\n\n    $$\n    P_{500} = 1.65 \\times 10^{-3} {\\frac{m_{500}*h_{70}}{3 \\times 10^{14}}}^{\\frac{2}{3} + ap}{h_z}^{\\frac{8}{3}}{h_{70}}^2\n    $$\n\n    $n_z$ is the critical density at the cluster redshift and $h_z$ is the Hubble constant at the cluster redshift.\n\n    Parameters\n    ----------\n    dx : float\n        RA of cluster center relative to grid origin.\n        Passed to `grid.transform_grid`.\n        Units: arcsec\n    dy : float\n        Dec of cluster center relative to grid origin.\n        Passed to `grid.transform_grid`.\n        Units: arcsec\n    dz : float\n        Line of sight offset of cluster center relative to grid origin.\n        Passed to `grid.transform_grid`.\n        Units: arcsec\n    r_1 : float\n        Amount to scale along x-axis.\n        Units are arbitrary, only ratio of r_1/r_2, r_1/r_3, r_2/r_3 matters\n        Passed to `grid.transform_grid`.\n        Units: arbitrary\n    r_2 : float\n        Amount to scale along y-axis.\n        Passed to `grid.transform_grid`.\n    r_3 : float\n        Amount to scale along z-axis.\n        Passed to `grid.transform_grid`.\n    theta : float\n        Angle to rotate in xy-plane.\n        Passed to `grid.transform_grid`.\n        Units: radians\n    P0 : float\n        Amplitude of the pressure profile.\n        Units: unitless\n    c500 : float\n        Concentration parameter at a density contrast of 500.\n        Units: unitless\n    m500 : float\n        Mass at a density contrast of 500.\n        Units: M_solar\n    gamma : float\n        The central slope.\n        Units: unitless\n    alpha : float\n        The intermediate slope.\n        Units: unitless\n    beta : float\n        The outer slope.\n        Units: unitless\n    z : float\n        Redshift of cluster.\n        Units: redshift\n    xyz : tuple[jax.Array, jax.Array, jax.Array, float, float]\n        Coordinte grid to calculate model on.\n        See `containers.Model.xyz` for details.\n\n    Returns\n    -------\n    model : jax.Array\n        The gnfw model evaluated on the grid.\n    \"\"\"\n    nz = get_nz(z)\n    hz = get_hz(z)\n\n    x, y, z, *_ = transform_grid(dx, dy, dz, r_1, r_2, r_3, theta, xyz)\n\n    r500 = (m500 / (4.00 * jnp.pi / 3.00) / 5.00e02 / nz) ** (1.00 / 3.00)\n\n    r = c500 * jnp.sqrt(x**2 + y**2 + z**2) / r500\n    denominator = (r**gamma) * (1 + r**alpha) ** ((beta - gamma) / alpha)\n\n    P500 = (\n        1.65e-03\n        * (m500 / (3.00e14 / h70)) ** (2.00 / 3.00 + ap)\n        * hz ** (8.00 / 3.00)\n        * h70**2\n    )\n\n    return P500 * P0 / denominator\n</code></pre>"},{"location":"reference/structure/#witch.structure.gaussian","title":"<code>gaussian(dx, dy, sigma, amp, xyz)</code>","text":"<p>Standard gaussian profile in 2d. This function does not include smoothing or declination stretch which should be applied at the end. The transform_grid call is awkward and can probably be removed/worked around. Function exists to match existing guassian interfaces.</p> <p>Once the grid is transformed the profile is computed as:</p> \\[ P_{0} e^{-\\frac{x^2 + y^2}{2\\sigma^2}} \\] <p>where \\(P_{0}\\) is <code>amp</code>.</p> <p>Parameters:</p> Name Type Description Default <code>dx</code> <code>float</code> <p>RA of cluster center relative to grid origin. Passed to <code>grid.transform_grid</code>. Units: arcsec</p> required <code>dy</code> <code>float</code> <p>Dec of cluster center relative to grid origin. Passed to <code>grid.transform_grid</code>. Units: arcsec</p> required <code>sigma</code> <code>float</code> <p>Sigma value of gaussian model. Units: arcsec</p> required <code>amp</code> <code>float</code> <p>Amplitude of gaussian model. Units: Jy</p> required <code>xyz</code> <code>tuple[Array, Array, Array, float, float]</code> <p>Coordinte grid to calculate model on. We only care about x and y here. See <code>containers.Model.xyz</code> for details.</p> required <p>Returns:</p> Name Type Description <code>model</code> <code>Array</code> <p>The gaussian model evaluated on only the 2d xy grid.</p> Source code in <code>witch/structure.py</code> <pre><code>@jax.jit\ndef gaussian(\n    dx: float,\n    dy: float,\n    sigma: float,\n    amp: float,\n    xyz: tuple[jax.Array, jax.Array, jax.Array, float, float],\n) -&gt; jax.Array:\n    r\"\"\"\n    Standard gaussian profile in 2d.\n    This function does not include smoothing or declination stretch\n    which should be applied at the end. The transform_grid call is\n    awkward and can probably be removed/worked around. Function exists\n    to match existing guassian interfaces.\n\n    Once the grid is transformed the profile is computed as:\n\n    $$\n    P_{0} e^{-\\frac{x^2 + y^2}{2\\sigma^2}}\n    $$\n\n    where $P_{0}$ is `amp`.\n\n    Parameters\n    ----------\n    dx : float\n        RA of cluster center relative to grid origin.\n        Passed to `grid.transform_grid`.\n        Units: arcsec\n    dy : float\n        Dec of cluster center relative to grid origin.\n        Passed to `grid.transform_grid`.\n        Units: arcsec\n    sigma : float\n        Sigma value of gaussian model.\n        Units: arcsec\n    amp : float\n        Amplitude of gaussian model.\n        Units: Jy\n    xyz : tuple[jax.Array, jax.Array, jax.Array, float, float]\n        Coordinte grid to calculate model on.\n        We only care about x and y here.\n        See `containers.Model.xyz` for details.\n\n    Returns\n    -------\n    model : jax.Array\n        The gaussian model evaluated on only the 2d xy grid.\n    \"\"\"\n    x, y, *_ = transform_grid(dx, dy, 0, 1, 1, 1, 0, xyz)\n    rr = x[..., 0] ** 2 + y[..., 0] ** 2\n    power = -1 * rr / (2 * sigma**2)\n\n    return amp * jnp.exp(power)\n</code></pre>"},{"location":"reference/structure/#witch.structure.gnfw","title":"<code>gnfw(dx, dy, dz, r, P0, c500, m500, gamma, alpha, beta, z, xyz)</code>","text":"<p>Spherical gNFW pressure profile in 3d. This function does not include smoothing or declination stretch which should be applied at the end.</p> <p>Once the grid is transformed the profile is computed as:</p> \\[ \\dfrac{P_{500} * P_{0}}{{\\left( r^{\\gamma}\\left( 1 + r^{\\alpha} \\right) \\right)}^{\\dfrac{\\beta - \\gamma}{\\alpha}}} \\] <p>where:</p> \\[ r = c_{500} \\sqrt{x^2 + y^2 + z^2} {\\frac{3m_{500}}{2000 \\pi n_z}}^{-\\frac{1}{3}} \\] \\[ P_{500} = 1.65 \\times 10^{-3} {\\frac{m_{500}*h_{70}}{3 \\times 10^{14}}}^{\\frac{2}{3} + ap}{h_z}^{\\frac{8}{3}}{h_{70}}^2 \\] <p>\\(n_z\\) is the critical density at the cluster redshift and \\(h_z\\) is the Hubble constant at the cluster redshift.</p> <p>Parameters:</p> Name Type Description Default <code>dx</code> <code>float</code> <p>RA of cluster center relative to grid origin. Passed to <code>grid.transform_grid</code>. Units: arcsec</p> required <code>dy</code> <code>float</code> <p>Dec of cluster center relative to grid origin. Passed to <code>grid.transform_grid</code>. Units: arcsec</p> required <code>dz</code> <code>float</code> <p>Line of sight offset of cluster center relative to grid origin. Passed to <code>grid.transform_grid</code>. Units: arcsec</p> required <code>r</code> <code>float</code> <p>Amount to scale radially Passed to <code>grid.transform_grid</code>. Units: arcmin</p> required <code>P0</code> <code>float</code> <p>Amplitude of the pressure profile. Units: unitless</p> required <code>c500</code> <code>float</code> <p>Concentration parameter at a density contrast of 500. Units: unitless</p> required <code>m500</code> <code>float</code> <p>Mass at a density contrast of 500. Units: M_solar</p> required <code>gamma</code> <code>float</code> <p>The central slope. Units: unitless</p> required <code>alpha</code> <code>float</code> <p>The intermediate slope. Units: unitless</p> required <code>beta</code> <code>float</code> <p>The outer slope. Units: unitless</p> required <code>z</code> <code>float</code> <p>Redshift of cluster. Units: redshift</p> required <code>xyz</code> <code>tuple[Array, Array, Array, float, float]</code> <p>Coordinte grid to calculate model on. See <code>containers.Model.xyz</code> for details.</p> required <p>Returns:</p> Name Type Description <code>model</code> <code>Array</code> <p>The gnfw model evaluated on the grid.</p> Source code in <code>witch/structure.py</code> <pre><code>@jax.jit\ndef gnfw(\n    dx: float,\n    dy: float,\n    dz: float,\n    r: float,\n    P0: float,\n    c500: float,\n    m500: float,\n    gamma: float,\n    alpha: float,\n    beta: float,\n    z: float,\n    xyz: tuple[jax.Array, jax.Array, jax.Array, float, float],\n) -&gt; jax.Array:\n    r\"\"\"\n    Spherical gNFW pressure profile in 3d.\n    This function does not include smoothing or declination stretch\n    which should be applied at the end.\n\n    Once the grid is transformed the profile is computed as:\n\n    $$\n    \\dfrac{P_{500} * P_{0}}{{\\left( r^{\\gamma}\\left( 1 + r^{\\alpha} \\right) \\right)}^{\\dfrac{\\beta - \\gamma}{\\alpha}}}\n    $$\n\n    where:\n\n    $$\n    r = c_{500} \\sqrt{x^2 + y^2 + z^2} {\\frac{3m_{500}}{2000 \\pi n_z}}^{-\\frac{1}{3}}\n    $$\n\n    $$\n    P_{500} = 1.65 \\times 10^{-3} {\\frac{m_{500}*h_{70}}{3 \\times 10^{14}}}^{\\frac{2}{3} + ap}{h_z}^{\\frac{8}{3}}{h_{70}}^2\n    $$\n\n    $n_z$ is the critical density at the cluster redshift and $h_z$ is the Hubble constant at the cluster redshift.\n\n    Parameters\n    ----------\n    dx : float\n        RA of cluster center relative to grid origin.\n        Passed to `grid.transform_grid`.\n        Units: arcsec\n    dy : float\n        Dec of cluster center relative to grid origin.\n        Passed to `grid.transform_grid`.\n        Units: arcsec\n    dz : float\n        Line of sight offset of cluster center relative to grid origin.\n        Passed to `grid.transform_grid`.\n        Units: arcsec\n    r : float\n        Amount to scale radially\n        Passed to `grid.transform_grid`.\n        Units: arcmin\n    P0 : float\n        Amplitude of the pressure profile.\n        Units: unitless\n    c500 : float\n        Concentration parameter at a density contrast of 500.\n        Units: unitless\n    m500 : float\n        Mass at a density contrast of 500.\n        Units: M_solar\n    gamma : float\n        The central slope.\n        Units: unitless\n    alpha : float\n        The intermediate slope.\n        Units: unitless\n    beta : float\n        The outer slope.\n        Units: unitless\n    z : float\n        Redshift of cluster.\n        Units: redshift\n    xyz : tuple[jax.Array, jax.Array, jax.Array, float, float]\n        Coordinte grid to calculate model on.\n        See `containers.Model.xyz` for details.\n\n    Returns\n    -------\n    model : jax.Array\n        The gnfw model evaluated on the grid.\n    \"\"\"\n    nz = get_nz(z)\n    hz = get_hz(z)\n\n    x, y, z, *_ = transform_grid(dx, dy, dz, r, r, r, 0, xyz)\n\n    r500 = (m500 / (4.00 * jnp.pi / 3.00) / 5.00e02 / nz) ** (1.00 / 3.00)\n\n    r = c500 * jnp.sqrt(x**2 + y**2 + z**2) / r500\n    denominator = (r**gamma) * (1 + r**alpha) ** ((beta - gamma) / alpha)\n\n    P500 = (\n        1.65e-03\n        * (m500 / (3.00e14 / h70)) ** (2.00 / 3.00 + ap)\n        * hz ** (8.00 / 3.00)\n        * h70**2\n    )\n\n    return P500 * P0 / denominator\n</code></pre>"},{"location":"reference/structure/#witch.structure.gnfw_rs","title":"<code>gnfw_rs(dx, dy, dz, P0, r_s, gamma, alpha, beta, z, xyz)</code>","text":"<p>Spherical gNFW pressure profile in 3d. Fits for r_s directly instead of m500. This function does not include smoothing or declination stretch which should be applied at the end.</p> <p>Once the grid is transformed the profile is computed as:</p> \\[ \\dfrac{P_{0}}{{\\left( \\left(r/r_{s}\\right)^{\\gamma}\\left( 1 + \\left(r/r_{s}\\right)^{\\alpha} \\right) \\right)}^{\\dfrac{\\beta - \\gamma}{\\alpha}}} \\] <p>where:</p> \\[ r = \\sqrt{x^2 + y^2 + z^2} \\] <p>Parameters:</p> Name Type Description Default <code>dx</code> <code>float</code> <p>RA of cluster center relative to grid origin. Passed to <code>grid.transform_grid</code>. Units: arcsec</p> required <code>dy</code> <code>float</code> <p>Dec of cluster center relative to grid origin. Passed to <code>grid.transform_grid</code>. Units: arcsec</p> required <code>dz</code> <code>float</code> <p>Line of sight offset of cluster center relative to grid origin. Passed to <code>grid.transform_grid</code>. Units: arcsec</p> required <code>P0</code> <code>float</code> <p>Amplitude of the pressure profile. Units: unitless</p> required <code>r_s</code> <code>float</code> <p>Charicteristic scale of the profile. Units: arcsec</p> required <code>gamma</code> <code>float</code> <p>The central slope. Units: unitless</p> required <code>alpha</code> <code>float</code> <p>The intermediate slope. Units: unitless</p> required <code>beta</code> <code>float</code> <p>The outer slope. Units: unitless</p> required <code>z</code> <code>float</code> <p>Redshift of cluster. Units: redshift</p> required <code>xyz</code> <code>tuple[Array, Array, Array, float, float]</code> <p>Coordinte grid to calculate model on. See <code>containers.Model.xyz</code> for details.</p> required <p>Returns:</p> Name Type Description <code>model</code> <code>Array</code> <p>The gnfw model evaluated on the grid.</p> Source code in <code>witch/structure.py</code> <pre><code>@jax.jit\ndef gnfw_rs(\n    dx: float,\n    dy: float,\n    dz: float,\n    P0: float,\n    r_s: float,\n    gamma: float,\n    alpha: float,\n    beta: float,\n    z: float,\n    xyz: tuple[jax.Array, jax.Array, jax.Array, float, float],\n) -&gt; jax.Array:\n    r\"\"\"\n    Spherical gNFW pressure profile in 3d. Fits for r_s directly instead of m500.\n    This function does not include smoothing or declination stretch\n    which should be applied at the end.\n\n    Once the grid is transformed the profile is computed as:\n\n    $$\n    \\dfrac{P_{0}}{{\\left( \\left(r/r_{s}\\right)^{\\gamma}\\left( 1 + \\left(r/r_{s}\\right)^{\\alpha} \\right) \\right)}^{\\dfrac{\\beta - \\gamma}{\\alpha}}}\n    $$\n\n    where:\n\n    $$\n    r = \\sqrt{x^2 + y^2 + z^2}\n    $$\n\n    Parameters\n    ----------\n    dx : float\n        RA of cluster center relative to grid origin.\n        Passed to `grid.transform_grid`.\n        Units: arcsec\n    dy : float\n        Dec of cluster center relative to grid origin.\n        Passed to `grid.transform_grid`.\n        Units: arcsec\n    dz : float\n        Line of sight offset of cluster center relative to grid origin.\n        Passed to `grid.transform_grid`.\n        Units: arcsec\n    P0 : float\n        Amplitude of the pressure profile.\n        Units: unitless\n    r_s : float\n        Charicteristic scale of the profile.\n        Units: arcsec\n    gamma : float\n        The central slope.\n        Units: unitless\n    alpha : float\n        The intermediate slope.\n        Units: unitless\n    beta : float\n        The outer slope.\n        Units: unitless\n    z : float\n        Redshift of cluster.\n        Units: redshift\n    xyz : tuple[jax.Array, jax.Array, jax.Array, float, float]\n        Coordinte grid to calculate model on.\n        See `containers.Model.xyz` for details.\n\n    Returns\n    -------\n    model : jax.Array\n        The gnfw model evaluated on the grid.\n    \"\"\"\n    x, y, z, *_ = transform_grid(dx, dy, dz, 1, 1, 1, 0, xyz)\n\n    r = jnp.sqrt(x**2 + y**2 + z**2)\n    denominator = ((r / r_s) ** gamma) * (1 + (r / r_s) ** alpha) ** (\n        (beta - gamma) / alpha\n    )\n\n    return P0 / denominator\n</code></pre>"},{"location":"reference/structure/#witch.structure.isobeta","title":"<code>isobeta(dx, dy, dz, r_1, r_2, r_3, theta, beta, amp, xyz)</code>","text":"<p>Elliptical isobeta pressure profile in 3d. This function does not include smoothing or declination stretch which should be applied at the end.</p> <p>Once the grid is transformed the profile is computed as:</p> \\[ P_{0}\\left( 1 + x**2 + y**2 + z**2 \\right)^{-1.5\\beta} \\] <p>where \\(P_{0}\\) is <code>amp</code>.</p> <p>Parameters:</p> Name Type Description Default <code>dx</code> <code>float</code> <p>RA of cluster center relative to grid origin. Passed to <code>grid.transform_grid</code>. Units: arcsec</p> required <code>dy</code> <code>float</code> <p>Dec of cluster center relative to grid origin. Passed to <code>grid.transform_grid</code>. Units: arcsec</p> required <code>dz</code> <code>float</code> <p>Line of sight offset of cluster center relative to grid origin. Passed to <code>grid.transform_grid</code>. Units: arcsec</p> required <code>r_1</code> <code>float</code> <p>Amount to scale along x-axis. Units are arbitrary, only ratio of r_1/r_2, r_1/r_3, r_2/r_3 matters Passed to <code>grid.transform_grid</code>. Units: arbitrary</p> required <code>r_2</code> <code>float</code> <p>Amount to scale along y-axis. Passed to <code>grid.transform_grid</code>. Units: arbitrary</p> required <code>r_3</code> <code>float</code> <p>Amount to scale along z-axis. Passed to <code>grid.transform_grid</code>. Units: arbitrary</p> required <code>theta</code> <code>float</code> <p>Angle to rotate in xy-plane. Passed to <code>grid.transform_grid</code>. Units: radians</p> required <code>beta</code> <code>float</code> <p>Beta value of isobeta model. Units: unitless</p> required <code>amp</code> <code>float</code> <p>Amplitude of isobeta model. Units: Matches unit conversion implicitly.</p> required <code>xyz</code> <code>tuple[Array, Array, Array, float, float]</code> <p>Coordinte grid to calculate model on. See <code>containers.Model.xyz</code> for details.</p> required <p>Returns:</p> Name Type Description <code>model</code> <code>Array</code> <p>The jax.isobeta model evaluated on the grid.</p> Source code in <code>witch/structure.py</code> <pre><code>@jax.jit\ndef isobeta(\n    dx: float,\n    dy: float,\n    dz: float,\n    r_1: float,\n    r_2: float,\n    r_3: float,\n    theta: float,\n    beta: float,\n    amp: float,\n    xyz: tuple[jax.Array, jax.Array, jax.Array, float, float],\n) -&gt; jax.Array:\n    r\"\"\"\n    Elliptical isobeta pressure profile in 3d.\n    This function does not include smoothing or declination stretch\n    which should be applied at the end.\n\n    Once the grid is transformed the profile is computed as:\n\n    $$\n    P_{0}\\left( 1 + x**2 + y**2 + z**2 \\right)^{-1.5\\beta}\n    $$\n\n    where $P_{0}$ is `amp`.\n\n    Parameters\n    ----------\n    dx : float\n        RA of cluster center relative to grid origin.\n        Passed to `grid.transform_grid`.\n        Units: arcsec\n    dy : float\n        Dec of cluster center relative to grid origin.\n        Passed to `grid.transform_grid`.\n        Units: arcsec\n    dz : float\n        Line of sight offset of cluster center relative to grid origin.\n        Passed to `grid.transform_grid`.\n        Units: arcsec\n    r_1 : float\n        Amount to scale along x-axis.\n        Units are arbitrary, only ratio of r_1/r_2, r_1/r_3, r_2/r_3 matters\n        Passed to `grid.transform_grid`.\n        Units: arbitrary\n    r_2 : float\n        Amount to scale along y-axis.\n        Passed to `grid.transform_grid`.\n        Units: arbitrary\n    r_3 : float\n        Amount to scale along z-axis.\n        Passed to `grid.transform_grid`.\n        Units: arbitrary\n    theta : float\n        Angle to rotate in xy-plane.\n        Passed to `grid.transform_grid`.\n        Units: radians\n    beta : float\n        Beta value of isobeta model.\n        Units: unitless\n    amp : float\n        Amplitude of isobeta model.\n        Units: Matches unit conversion implicitly.\n    xyz : tuple[jax.Array, jax.Array, jax.Array, float, float]\n        Coordinte grid to calculate model on.\n        See `containers.Model.xyz` for details.\n\n    Returns\n    -------\n    model : Array\n        The jax.isobeta model evaluated on the grid.\n    \"\"\"\n    x, y, z, *_ = transform_grid(dx, dy, dz, r_1, r_2, r_3, theta, xyz)\n\n    rr = 1 + x**2 + y**2 + z**2\n    power = -1.5 * beta\n    rrpow = rr**power\n\n    return amp * rrpow\n</code></pre>"},{"location":"reference/structure/#witch.structure.nonpara_power","title":"<code>nonpara_power(nonpara_rbins, nonpara_amps, nonpara_pows, dx, dy, dz, c, xyz)</code>","text":"<p>Function which computes 3D pressure of segmented power laws</p> Parameters: <p>dx : float     RA of cluster center relative to grid origin.     Passed to <code>grid.transform_grid</code>.     Units: arcsec dy : float     Dec of cluster center relative to grid origin.     Passed to <code>grid.transform_grid</code>.     Units: arcsec dz : float     Line of sight offset of cluster center relative to grid origin.     Passed to <code>grid.transform_grid</code>.     Units: arcsec rbins : jax.Array     Array of bin edges for power laws amps : jax.Array     Amplitudes of power laws pows : jax.Array     Exponents of power laws c : float     Constant offset for powerlaws xyz : tuple[jax.Array, jax.Array, jax.Array, float, float]     Coordinte grid to calculate model on.     See <code>containers.Model.xyz</code> for details.</p> Source code in <code>witch/structure.py</code> <pre><code>@jax.jit\ndef nonpara_power(\n    nonpara_rbins: jax.Array,\n    nonpara_amps: jax.Array,\n    nonpara_pows: jax.Array,\n    dx: float,\n    dy: float,\n    dz: float,\n    c: float,\n    xyz: tuple[jax.Array, jax.Array, jax.Array, float, float],\n) -&gt; jax.Array:\n    \"\"\"\n    Function which computes 3D pressure of segmented power laws\n\n    Parameters:\n    -----------\n    dx : float\n        RA of cluster center relative to grid origin.\n        Passed to `grid.transform_grid`.\n        Units: arcsec\n    dy : float\n        Dec of cluster center relative to grid origin.\n        Passed to `grid.transform_grid`.\n        Units: arcsec\n    dz : float\n        Line of sight offset of cluster center relative to grid origin.\n        Passed to `grid.transform_grid`.\n        Units: arcsec\n    rbins : jax.Array\n        Array of bin edges for power laws\n    amps : jax.Array\n        Amplitudes of power laws\n    pows : jax.Array\n        Exponents of power laws\n    c : float\n        Constant offset for powerlaws\n    xyz : tuple[jax.Array, jax.Array, jax.Array, float, float]\n        Coordinte grid to calculate model on.\n        See `containers.Model.xyz` for details.\n    \"\"\"\n    x, y, z, *_ = transform_grid(dx, dy, dz, 1.0, 1.0, 1.0, 0.0, xyz)\n    r = jnp.sqrt(x**2 + y**2 + z**2)\n    nonpara_rbins = jnp.append(nonpara_rbins, jnp.array([jnp.amax(r)]))\n    mapshape = r.shape\n    r = r.ravel()\n    condlist = [\n        jnp.array((nonpara_rbins[i] &lt;= r) &amp; (r &lt; nonpara_rbins[i + 1]))\n        for i in range(len(nonpara_pows) - 1, -1, -1)\n    ]\n    pressure = broken_power(\n        r, condlist, nonpara_rbins, nonpara_amps, nonpara_pows, c\n    ).reshape(mapshape)\n\n    return pressure\n</code></pre>"},{"location":"reference/utils/","title":"utils","text":"<p>A set of utility functions and constants used for unit conversions and cosmology as well as some generically useful math functions.</p>"},{"location":"reference/utils/#witch.utils.K_CMB2K_RJ","title":"<code>K_CMB2K_RJ(freq)</code>","text":"<p>Convert from K_CMB to K_RJ.</p> <p>Parameters:</p> Name Type Description Default <code>freq</code> <code>float</code> <p>The observing frequency in Hz.</p> required <p>Returns:</p> Name Type Description <code>K_CMB2K_RJ</code> <code>float</code> <p>Conversion factor from K_CMB to K_RJ.</p> Source code in <code>witch/utils.py</code> <pre><code>@partial(jax.jit, static_argnums=(0,))\ndef K_CMB2K_RJ(freq: float) -&gt; float:\n    \"\"\"\n    Convert from K_CMB to K_RJ.\n\n    Parameters\n    ----------\n    freq : float\n        The observing frequency in Hz.\n\n    Returns\n    -------\n    K_CMB2K_RJ : float\n        Conversion factor from K_CMB to K_RJ.\n    \"\"\"\n    x = freq * h / kb / Tcmb\n    return jnp.exp(x) * x * x / jnp.expm1(x) ** 2\n</code></pre>"},{"location":"reference/utils/#witch.utils.beam_double_gauss","title":"<code>beam_double_gauss(dr, fwhm1, amp1, fwhm2, amp2)</code>","text":"<p>Helper function to generate a double gaussian beam.</p> <p>Parameters:</p> Name Type Description Default <code>dr</code> <code>float</code> <p>Pixel size.</p> required <code>fwhm1</code> <code>float</code> <p>Full width half max of the primary gaussian in the same units as <code>dr</code>.</p> required <code>amp1</code> <code>float</code> <p>Amplitude of the primary gaussian.</p> required <code>fwhm2</code> <code>float</code> <p>Full width half max of the secondairy gaussian in the same units as <code>dr</code>.</p> required <code>amp2</code> <code>float</code> <p>Amplitude of the secondairy gaussian.</p> required <p>Returns:</p> Type Description <code>    beam: Double gaussian beam.</code> Source code in <code>witch/utils.py</code> <pre><code>def beam_double_gauss(\n    dr: float, fwhm1: float, amp1: float, fwhm2: float, amp2: float\n) -&gt; jax.Array:\n    \"\"\"\n    Helper function to generate a double gaussian beam.\n\n    Parameters\n    ----------\n    dr : float\n        Pixel size.\n    fwhm1 : float\n        Full width half max of the primary gaussian in the same units as `dr`.\n    amp1 : float\n        Amplitude of the primary gaussian.\n    fwhm2 : float\n        Full width half max of the secondairy gaussian in the same units as `dr`.\n    amp2 : float\n        Amplitude of the secondairy gaussian.\n\n    Returns\n    -------\n        beam: Double gaussian beam.\n    \"\"\"\n    x = jnp.arange(-1.5 * fwhm1 // (dr), 1.5 * fwhm1 // (dr)) * (dr)\n    beam_xx, beam_yy = jnp.meshgrid(x, x)\n    beam_rr = jnp.sqrt(beam_xx**2 + beam_yy**2)\n    beam = amp1 * jnp.exp(-4 * jnp.log(2) * beam_rr**2 / fwhm1**2) + amp2 * jnp.exp(\n        -4 * jnp.log(2) * beam_rr**2 / fwhm2**2\n    )\n    return beam / jnp.sum(beam)\n</code></pre>"},{"location":"reference/utils/#witch.utils.bilinear_interp","title":"<code>bilinear_interp(x, y, xp, yp, fp)</code>","text":"<p>JAX implementation of bilinear interpolation. Out of bounds values are set to 0. Using the repeated linear interpolation method here, see https://en.wikipedia.org/wiki/Bilinear_interpolation#Repeated_linear_interpolation.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>Array</code> <p>X values to return interpolated values at.</p> required <code>y</code> <code>Array</code> <p>Y values to return interpolated values at.</p> required <code>xp</code> <code>Array</code> <p>X values to interpolate with, should be 1D. Assumed to be sorted.</p> required <code>yp</code> <code>Array</code> <p>Y values to interpolate with, should be 1D. Assumed to be sorted.</p> required <code>fp</code> <code>Array</code> <p>Functon values at <code>(xp, yp)</code>, should have shape <code>(len(xp), len(yp))</code>. Note that if you are using meshgrid, we assume <code>'ij'</code> indexing.</p> required <p>Returns:</p> Name Type Description <code>f</code> <code>Array</code> <p>The interpolated values.</p> Source code in <code>witch/utils.py</code> <pre><code>@jax.jit\ndef bilinear_interp(\n    x: jax.Array, y: jax.Array, xp: jax.Array, yp: jax.Array, fp: jax.Array\n) -&gt; jax.Array:\n    \"\"\"\n    JAX implementation of bilinear interpolation.\n    Out of bounds values are set to 0.\n    Using the repeated linear interpolation method here,\n    see https://en.wikipedia.org/wiki/Bilinear_interpolation#Repeated_linear_interpolation.\n\n    Parameters\n    ----------\n    x : jax.Array\n        X values to return interpolated values at.\n    y : jax.Array\n        Y values to return interpolated values at.\n    xp : jax.Array\n        X values to interpolate with, should be 1D.\n        Assumed to be sorted.\n    yp : jax.Array\n        Y values to interpolate with, should be 1D.\n        Assumed to be sorted.\n    fp : jax.Array\n        Functon values at `(xp, yp)`, should have shape `(len(xp), len(yp))`.\n        Note that if you are using meshgrid, we assume `'ij'` indexing.\n\n    Returns\n    -------\n    f : jax.Array\n        The interpolated values.\n    \"\"\"\n    if len(xp.shape) != 1:\n        raise ValueError(\"xp must be 1D\")\n    if len(yp.shape) != 1:\n        raise ValueError(\"yp must be 1D\")\n    if fp.shape != xp.shape + yp.shape:\n        raise ValueError(\n            \"Incompatible shapes for fp, xp, yp: %s, %s, %s\",\n            fp.shape,\n            xp.shape,\n            yp.shape,\n        )\n\n    # Figure out bounds and mapping\n    # This breaks if xp, yp is not sorted\n    ix = jnp.clip(jnp.searchsorted(xp, x, side=\"right\"), 1, len(xp) - 1)\n    iy = jnp.clip(jnp.searchsorted(yp, y, side=\"right\"), 1, len(yp) - 1)\n    q_11 = fp[ix - 1, iy - 1]\n    q_21 = fp[ix, iy - 1]\n    q_12 = fp[ix - 1, iy]\n    q_22 = fp[ix, iy]\n\n    # Interpolate in x to start\n    denom_x = xp[ix] - xp[ix - 1]\n    dx_1 = x - xp[ix - 1]\n    dx_2 = xp[ix] - x\n    f_xy1 = (dx_2 * q_11 + dx_1 * q_21) / denom_x\n    f_xy2 = (dx_2 * q_12 + dx_1 * q_22) / denom_x\n\n    # Now do y as well\n    denom_y = yp[iy] - yp[iy - 1]\n    dy_1 = y - yp[iy - 1]\n    dy_2 = yp[iy] - y\n    f = (dy_2 * f_xy1 + dy_1 * f_xy2) / denom_y\n\n    # Zero out the out of bounds values\n    f = jnp.where((x &lt; xp[0]) + (x &gt; xp[-1]) + (y &lt; yp[0]) + (y &gt; yp[-1]), 0.0, f)\n\n    return f\n</code></pre>"},{"location":"reference/utils/#witch.utils.bin_map","title":"<code>bin_map(data, pixsize)</code>","text":"<p>Bins data radially.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>ArrayLike</code> <p>Data to be radially binned</p> required <code>pixsize</code> <code>float</code> <p>Pixel spacing for data</p> required <p>Returns:</p> Name Type Description <code>rs</code> <code>array</code> <p>Left bin edges</p> <code>bin1d</code> <code>array</code> <p>Mean of pixels in bin</p> <code>var1d</code> <code>array</code> <p>Variance of pixels in bin</p> Source code in <code>witch/utils.py</code> <pre><code>def bin_map(data: ArrayLike, pixsize: float) -&gt; tuple[np.array, np.array, np.array]:\n    \"\"\"\n    Bins data radially.\n\n    Parameters\n    ----------\n    data : ArrayLike\n        Data to be radially binned\n    pixsize : float\n        Pixel spacing for data\n\n    Returns\n    -------\n    rs : np.array\n        Left bin edges\n    bin1d : np.array\n        Mean of pixels in bin\n    var1d : np.array\n        Variance of pixels in bin\n    \"\"\"\n    x = np.linspace(\n        -data.shape[1] / 2 * pixsize, data.shape[1] / 2 * pixsize, data.shape[1]\n    )\n    y = np.linspace(\n        -data.shape[0] / 2 * pixsize, data.shape[0] / 2 * pixsize, data.shape[0]\n    )\n\n    X, Y = np.meshgrid(x, y)\n    R = np.sqrt(X**2 + Y**2)  # TODO: miscentering?\n\n    rs = np.arange(0, np.amax(R), pixsize)\n    rs = np.append(rs, 999999)\n    bin1d = np.zeros(len(rs) - 1)\n    var1d = np.zeros(len(rs) - 1)\n\n    for k in range(len(rs) - 1):\n        pixels = [\n            data[i, j]\n            for i in range(len(y))\n            for j in range(len(x))\n            if rs[k] &lt; R[i, j] &lt;= rs[k + 1]\n        ]\n        if len(pixels) == 0:\n            bin1d[k] = 0\n            var1d[k] = 0\n        else:\n            bin1d[k] = np.mean(pixels)\n            var1d[k] = np.var(pixels)\n    rs = rs[:-1]\n\n    return rs, bin1d, var1d\n</code></pre>"},{"location":"reference/utils/#witch.utils.fft_conv","title":"<code>fft_conv(image, kernel)</code>","text":"<p>Perform a convolution using FFTs for speed with jax.</p> <p>Parameters:</p> Name Type Description Default <code>image</code> <code>ArrayLike</code> <p>Data to be convolved.</p> required <code>kernel</code> <code>ArrayLike</code> <p>Convolution kernel.</p> required <p>Returns:</p> Name Type Description <code>convolved_map</code> <code>Array</code> <p>Image convolved with kernel.</p> Source code in <code>witch/utils.py</code> <pre><code>@jax.jit\ndef fft_conv(image: ArrayLike, kernel: ArrayLike) -&gt; jax.Array:\n    \"\"\"\n    Perform a convolution using FFTs for speed with jax.\n\n    Parameters\n    ----------\n    image : ArrayLike\n        Data to be convolved.\n    kernel : ArrayLike\n        Convolution kernel.\n\n    Returns\n    -------\n    convolved_map : jax.Array\n        Image convolved with kernel.\n    \"\"\"\n    Fmap = jnp.fft.fft2(jnp.fft.fftshift(image))\n    Fkernel = jnp.fft.fft2(jnp.fft.fftshift(kernel))\n    convolved_map = jnp.fft.fftshift(jnp.real(jnp.fft.ifft2(Fmap * Fkernel)))\n\n    return convolved_map\n</code></pre>"},{"location":"reference/utils/#witch.utils.fft_deconv","title":"<code>fft_deconv(image, kernel)</code>","text":"<p>Perform a convolution using FFTs for speed with jax.</p> <p>Parameters:</p> Name Type Description Default <code>image</code> <code>ArrayLike</code> <p>Data to be convolved.</p> required <code>kernel</code> <code>ArrayLike</code> <p>Convolution kernel.</p> required <p>Returns:</p> Name Type Description <code>convolved_map</code> <code>Array</code> <p>Image convolved with kernel.</p> Source code in <code>witch/utils.py</code> <pre><code>@jax.jit\ndef fft_deconv(image: ArrayLike, kernel: ArrayLike) -&gt; jax.Array:\n    \"\"\"\n    Perform a convolution using FFTs for speed with jax.\n\n    Parameters\n    ----------\n    image : ArrayLike\n        Data to be convolved.\n    kernel : ArrayLike\n        Convolution kernel.\n\n    Returns\n    -------\n    convolved_map : jax.Array\n        Image convolved with kernel.\n    \"\"\"\n    Fmap = jnp.fft.fft2(jnp.fft.fftshift(image))\n    Fkernel = jnp.fft.fft2(jnp.fft.fftshift(kernel))\n    convolved_map = jnp.fft.fftshift(jnp.real(jnp.fft.ifft2(Fmap / Fkernel)))\n\n    return convolved_map\n</code></pre>"},{"location":"reference/utils/#witch.utils.get_da","title":"<code>get_da(z)</code>","text":"<p>Get factor to convert from arcseconds to MPc.</p> <p>Parameters:</p> Name Type Description Default <code>z</code> <code>ArrayLike</code> <p>The redshift at which to compute the factor.</p> required <p>Returns:</p> Name Type Description <code>da</code> <code>Array</code> <p>Conversion factor from arcseconds to MPc.</p> Source code in <code>witch/utils.py</code> <pre><code>@jax.jit\ndef get_da(z: ArrayLike) -&gt; jax.Array:\n    \"\"\"\n    Get factor to convert from arcseconds to MPc.\n\n    Parameters\n    ----------\n    z : ArrayLike\n        The redshift at which to compute the factor.\n\n    Returns\n    -------\n    da : jax.Array\n        Conversion factor from arcseconds to MPc.\n    \"\"\"\n    return jnp.interp(z, zline, daline)\n</code></pre>"},{"location":"reference/utils/#witch.utils.get_hz","title":"<code>get_hz(z)</code>","text":"<p>Get the dimensionless hubble constant, h, at a given redshift.</p> <p>Parameters:</p> Name Type Description Default <code>z</code> <code>ArrayLike</code> <p>The redshift at which to compute h.</p> required <p>Returns:</p> Name Type Description <code>hz</code> <code>Array</code> <p>h at the given z.</p> Source code in <code>witch/utils.py</code> <pre><code>@jax.jit\ndef get_hz(z: ArrayLike) -&gt; jax.Array:\n    \"\"\"\n    Get the dimensionless hubble constant, h, at a given redshift.\n\n    Parameters\n    ----------\n    z : ArrayLike\n        The redshift at which to compute h.\n\n    Returns\n    -------\n    hz : jax.Array\n        h at the given z.\n    \"\"\"\n    return jnp.interp(z, zline, hzline)\n</code></pre>"},{"location":"reference/utils/#witch.utils.get_nz","title":"<code>get_nz(z)</code>","text":"<p>Get the critical density at a given redshift.</p> <p>Parameters:</p> Name Type Description Default <code>z</code> <code>ArrayLike</code> <p>The redshift at which to compute the critical density.</p> required <p>Returns:</p> Name Type Description <code>nz</code> <code>Array</code> <p>Critical density at the given z. This is in units of solar masses per cubic Mpc.</p> Source code in <code>witch/utils.py</code> <pre><code>@jax.jit\ndef get_nz(z: ArrayLike) -&gt; jax.Array:\n    \"\"\"\n    Get the critical density at a given redshift.\n\n    Parameters\n    ----------\n    z : ArrayLike\n        The redshift at which to compute the critical density.\n\n    Returns\n    -------\n    nz : jax.Array\n        Critical density at the given z.\n        This is in units of solar masses per cubic Mpc.\n    \"\"\"\n    return jnp.interp(z, zline, nzline)\n</code></pre>"},{"location":"reference/utils/#witch.utils.tod_hi_pass","title":"<code>tod_hi_pass(tod, N_filt)</code>","text":"<p>High pass a tod with a tophat</p> <p>Parameters:</p> Name Type Description Default <code>tod</code> <code>Array</code> <p>TOD to high pass.</p> required <code>N_filt</code> <code>int</code> <p>N_filt of tophat.</p> required <p>Returns:</p> Name Type Description <code>tod_filtered</code> <code>Array</code> <p>High pass filtered TOD</p> Source code in <code>witch/utils.py</code> <pre><code>@partial(jax.jit, static_argnums=(1,))\ndef tod_hi_pass(tod: jax.Array, N_filt: int) -&gt; jax.Array:\n    \"\"\"\n    High pass a tod with a tophat\n\n    Parameters\n    ----------\n    tod : jax.Array\n        TOD to high pass.\n    N_filt : int\n        N_filt of tophat.\n\n    Returns\n    -------\n    tod_filtered : jax.Array\n        High pass filtered TOD\n    \"\"\"\n    mask = jnp.ones(tod.shape)\n    mask = mask.at[..., :N_filt].set(0.0)\n\n    ## apply the filter in fourier space\n    Ftod = jnp.fft.fft(tod)\n    Ftod_filtered = Ftod * mask\n    tod_filtered = jnp.fft.ifft(Ftod_filtered).real\n    return tod_filtered\n</code></pre>"},{"location":"reference/utils/#witch.utils.y2K_CMB","title":"<code>y2K_CMB(freq, Te)</code>","text":"<p>Convert from compton y to K_CMB.</p> <p>Parameters:</p> Name Type Description Default <code>freq</code> <code>float</code> <p>The observing frequency in Hz.</p> required <code>Te</code> <code>float</code> <p>Electron temperature</p> required <p>Returns:</p> Name Type Description <code>y2K_CMB</code> <code>float</code> <p>Conversion factor from compton y to K_CMB.</p> Source code in <code>witch/utils.py</code> <pre><code>@partial(jax.jit, static_argnums=(0, 1))\ndef y2K_CMB(freq: float, Te: float) -&gt; float:\n    \"\"\"\n    Convert from compton y to K_CMB.\n\n    Parameters\n    ----------\n    freq : float\n        The observing frequency in Hz.\n    Te : float\n        Electron temperature\n\n    Returns\n    -------\n    y2K_CMB : float\n        Conversion factor from compton y to K_CMB.\n    \"\"\"\n    x = freq * h / kb / Tcmb\n    xt = x / jnp.tanh(0.5 * x)\n    st = x / jnp.sinh(0.5 * x)\n    # fmt:off\n    Y0 = -4.0 + xt\n    Y1 = (-10.0\n        + ((47.0 / 2.0) + (-(42.0 / 5.0) + (7.0 / 10.0) * xt) * xt) * xt\n        + st * st * (-(21.0 / 5.0) + (7.0 / 5.0) * xt)\n    )\n    Y2 = ((-15.0 / 2.0)\n        + ((1023.0 / 8.0) + ((-868.0 / 5.0) + ((329.0 / 5.0) + ((-44.0 / 5.0) + (11.0 / 30.0) * xt) * xt) * xt) * xt) * xt\n        + ((-434.0 / 5.0) + ((658.0 / 5.0) + ((-242.0 / 5.0) + (143.0 / 30.0) * xt) * xt) * xt\n        + (-(44.0 / 5.0) + (187.0 / 60.0) * xt) * (st * st)) * st * st\n    )\n    Y3 = ((15.0 / 2.0)\n        + ((2505.0 / 8.0) + ((-7098.0 / 5.0) + ((14253.0 / 10.0) + ((-18594.0 / 35.0) \n         + ((12059.0 / 140.0) + ((-128.0 / 21.0) + (16.0 / 105.0) * xt) * xt) * xt) * xt) * xt) * xt) * xt\n        + (((-7098.0 / 10.0) + ((14253.0 / 5.0) + ((-102267.0 / 35.0) + ((156767.0 / 140.0)\n         + ((-1216.0 / 7.0) + (64.0 / 7.0) * xt) * xt) * xt) * xt) * xt)\n         + (((-18594.0 / 35.0) + ((205003.0 / 280.0) + ((-1920.0 / 7.0) + (1024.0 / 35.0) * xt) * xt) * xt)\n          + ((-544.0 / 21.0) + (992.0 / 105.0) * xt) * st * st) * st * st) * st * st\n    )\n    Y4 = ((-135.0 / 32.0)\n        + ((30375.0 / 128.0) + ((-62391.0 / 10.0) + ((614727.0 / 40.0) + ((-124389.0 / 10.0) + ((355703.0 / 80.0) + ((-16568.0 / 21.0)\n         + ((7516.0 / 105.0) + ((-22.0 / 7.0) + (11.0 / 210.0) * xt) * xt) * xt) * xt) * xt) * xt) * xt) * xt) * xt\n        + ((-62391.0 / 20.0) + ((614727.0 / 20.0) + ((-1368279.0 / 20.0) + ((4624139.0 / 80.0) + ((-157396.0 / 7.0) + ((30064.0 / 7.0)\n         + ((-2717.0 / 7.0) + (2761.0 / 210.0) * xt) * xt) * xt) * xt) * xt) * xt) * xt\n         + ((-124389.0 / 10.0)\n          + ((6046951.0 / 160.0) + ((-248520.0 / 7.0) + ((481024.0 / 35.0) + ((-15972.0 / 7.0) + (18689.0 / 140.0) * xt) * xt) * xt) * xt) * xt\n          + ((-70414.0 / 21.0) + ((465992.0 / 105.0) + ((-11792.0 / 7.0) + (19778.0 / 105.0) * xt) * xt) * xt\n           + ((-682.0 / 7.0) + (7601.0 / 210.0) * xt) * st * st) * st * st) * st * st) * st * st\n    )\n    # fmt:on\n    factor = Y0 + (Te / me) * (\n        Y1 + (Te / me) * (Y2 + (Te / me) * (Y3 + (Te / me) * Y4))\n    )\n    return factor * Tcmb\n</code></pre>"},{"location":"reference/utils/#witch.utils.y2K_RJ","title":"<code>y2K_RJ(freq, Te)</code>","text":"<p>Convert from compton y to K_RJ.</p> <p>Parameters:</p> Name Type Description Default <code>freq</code> <code>float</code> <p>The observing frequency in Hz.</p> required <code>Te</code> <code>float</code> <p>Electron temperature</p> required <p>Returns:</p> Name Type Description <code>y2K_RJ</code> <code>float</code> <p>Conversion factor from compton y to K_RJ.</p> Source code in <code>witch/utils.py</code> <pre><code>@partial(jax.jit, static_argnums=(0, 1))\ndef y2K_RJ(freq: float, Te: float) -&gt; float:\n    \"\"\"\n    Convert from compton y to K_RJ.\n\n    Parameters\n    ----------\n    freq : float\n        The observing frequency in Hz.\n    Te : float\n        Electron temperature\n\n    Returns\n    -------\n    y2K_RJ : float\n        Conversion factor from compton y to K_RJ.\n    \"\"\"\n    factor = y2K_CMB(freq, Te)\n    return factor * K_CMB2K_RJ(freq)\n</code></pre>"},{"location":"reference/external/act_map/funcs/","title":"funcs","text":""},{"location":"reference/external/minkasi/funcs/","title":"funcs","text":""},{"location":"reference/external/minkasi/mapmaking/","title":"mapmaking","text":"<p>Functions that wrap useful minkasi recipes</p>"},{"location":"reference/external/minkasi/mapmaking/#witch.external.minkasi.mapmaking.get_grad_prior","title":"<code>get_grad_prior(todvec, mapset, gradmap, *args, **kwargs)</code>","text":"<p>Make a gradient based prior from a map. This helps avoid errors due to sharp features.</p> <p>Parameters:</p> Name Type Description Default <code>todvec</code> <code>TodVec</code> <p>The TODs what we are mapmaking.</p> required <code>mapset</code> <code>Mapset</code> <p>The mapset to compute priors with. We assume that the first element is the map we care about.</p> required <code>gradmap</code> <code>MapType</code> <p>Containter to use as the gradient map.</p> required <code>*args</code> <code>Unpack[tuple]</code> <p>Additional arguments to pass to get_grad_mask_2d.</p> <code>()</code> <code>**kwargs</code> <p>Keyword arguments to pass to get_grad_mask_2d.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>new_mapset</code> <code>Mapset</code> <p>A mapset with the original map and a cleared prior map.</p> Source code in <code>witch/external/minkasi/mapmaking.py</code> <pre><code>def get_grad_prior(\n    todvec: minkasi.tods.TodVec,\n    mapset: minkasi.maps.Mapset,\n    gradmap: minkasi.maps.MapType,\n    *args: Unpack[tuple],\n    **kwargs,\n) -&gt; minkasi.maps.Mapset:\n    \"\"\"\n    Make a gradient based prior from a map.\n    This helps avoid errors due to sharp features.\n\n    Parameters\n    ----------\n    todvec : minkasi.tods.TodVec\n        The TODs what we are mapmaking.\n    mapset : minkasi.maps.Mapset\n        The mapset to compute priors with.\n        We assume that the first element is the map we care about.\n    gradmap : minkasi.maps.MapType\n        Containter to use as the gradient map.\n    *args : Unpack[tuple]\n        Additional arguments to pass to get_grad_mask_2d.\n    **kwargs\n        Keyword arguments to pass to get_grad_mask_2d.\n\n    Returns\n    -------\n    new_mapset : minkasi.maps.Mapset\n        A mapset with the original map and a cleared prior map.\n    \"\"\"\n    gradmap.map[:] = minkasi.mapmaking.noise.get_grad_mask_2d(\n        mapset.maps[0], todvec, *args, **kwargs\n    )\n    prior = minkasi.mapmaking.timestream.tsModel(todvec, minkasi.tods.cuts.CutsCompact)\n    for tod in todvec.tods:\n        prior.data[tod.info[\"fname\"]] = tod.prior_from_skymap(gradmap)\n        print(\n            \"prior on tod \"\n            + tod.info[\"fname\"]\n            + \" length is \"\n            + repr(prior.data[tod.info[\"fname\"]].map.size)\n        )\n\n    new_mapset = minkasi.maps.Mapset()\n    new_mapset.add_map(mapset.maps[0])\n    pp = prior.copy()\n    pp.clear()\n    new_mapset.add_map(pp)\n\n    return new_mapset\n</code></pre>"},{"location":"reference/external/minkasi/mapmaking/#witch.external.minkasi.mapmaking.make_maps","title":"<code>make_maps(todvec, skymap, noise_class, noise_args, noise_kwargs, outdir, npass, dograd, return_maps=False)</code>","text":"<p>Make a minkasi map with multple passes and noise reestimation. Unless you are an expert this will usually be all you need.</p> <p>Parameters:</p> Name Type Description Default <code>todvec</code> <code>TodVec</code> <p>The tods to mapmake.</p> required <code>skymap</code> <code>MapType</code> <p>Map to use as a template. The contents don't matter only the shape and WCS info.</p> required <code>noise_class</code> <code>NoiseModelType</code> <p>The noise model to use on the TODs.</p> required <code>noise_args</code> <code>tuple</code> <p>Arguments to pass to <code>minkasi.tods.Tod.set_noise</code>.</p> required <code>noise_kwargs</code> <code>dict</code> <p>Keyword arguments to pass to <code>minkasi.tods.Tod.set_noise</code>.</p> required <code>outdir</code> <code>str</code> <p>The output directory.</p> required <code>npass</code> <code>int</code> <p>The number of times to mapmake and then reestimate the noise.</p> required <code>dograd</code> <code>bool</code> <p>If True make a map based prior to avoid biases from sharp features.</p> required <code>return_maps</code> <code>bool</code> <p>If True, return the mapset. Default; False</p> <code>False</code> Source code in <code>witch/external/minkasi/mapmaking.py</code> <pre><code>def make_maps(\n    todvec: minkasi.tods.TodVec,\n    skymap: minkasi.maps.MapType,\n    noise_class: minkasi.mapmaking.noise.NoiseModelType,\n    noise_args: tuple,\n    noise_kwargs: dict,\n    outdir: str,\n    npass: int,\n    dograd: bool,\n    return_maps: bool = False,\n):\n    \"\"\"\n    Make a minkasi map with multple passes and noise reestimation.\n    Unless you are an expert this will usually be all you need.\n\n    Parameters\n    ----------\n    todvec : minkasi.tods.TodVec\n        The tods to mapmake.\n    skymap : minkasi.maps.MapType\n        Map to use as a template.\n        The contents don't matter only the shape and WCS info.\n    noise_class : minkasi.mapmaking.noise.NoiseModelType\n        The noise model to use on the TODs.\n    noise_args : tuple\n        Arguments to pass to `minkasi.tods.Tod.set_noise`.\n    noise_kwargs : dict\n        Keyword arguments to pass to `minkasi.tods.Tod.set_noise`.\n    outdir : str\n        The output directory.\n    npass : int\n        The number of times to mapmake and then reestimate the noise.\n    dograd : bool\n        If True make a map based prior to avoid biases from sharp features.\n    return_maps : bool\n        If True, return the mapset. Default; False\n    \"\"\"\n    for tod in todvec.tods:\n        if \"ipix\" not in tod.info:\n            ipix = skymap.get_pix(tod)\n            tod.info[\"ipix\"] = ipix\n        if tod.noise is None:\n            tod.set_noise(\n                noise_class,\n                tod.info[\"dat_calib\"],\n                *noise_args,\n                **noise_kwargs,\n            )\n\n    naive, hits = make_naive(todvec, skymap, outdir)\n\n    # Take 1 over hits map\n    ihits = hits.copy()\n    ihits.invert()\n\n    # Save weights and noise maps\n    _ = make_weights(todvec, skymap, outdir)\n\n    # Setup the mapset\n    # For now just include the naive map so we can use it as the initial guess.\n    mapset = minkasi.maps.Mapset()\n    mapset.add_map(naive)\n\n    # run PCG to solve for a first guess\n    iters = [5, 25, 100]\n    mapset = solve_map(todvec, mapset, ihits, None, 26, iters, outdir, \"initial\")\n\n    # Now we iteratively solve and reestimate the noise\n    for niter in range(npass):\n        maxiter = 26 + 25 * (niter + 1)\n        reestimate_noise_from_map(todvec, mapset, noise_class, noise_args, noise_kwargs)\n\n        # Make a gradient based prior\n        if dograd:\n            mapset = get_grad_prior(todvec, mapset, hits.copy(), thresh=1.8)\n        # Solve\n        mapset = solve_map(\n            todvec, mapset, ihits, None, maxiter, iters, outdir, f\"niter_{niter+1}\"\n        )\n\n    minkasi.barrier()\n\n    if return_maps:\n        return mapset\n</code></pre>"},{"location":"reference/external/minkasi/mapmaking/#witch.external.minkasi.mapmaking.make_naive","title":"<code>make_naive(todvec, skymap, outdir)</code>","text":"<p>Make a naive map where we just bin common mode subtracted TODs.</p> <p>Parameters:</p> Name Type Description Default <code>todvec</code> <code>TodVec</code> <p>The TODs to mapmake.</p> required <code>skymap</code> <code>MapType</code> <p>Map to use as footprint for outputs.</p> required <p>Returns:</p> Name Type Description <code>naive</code> <code>MapType</code> <p>The naive map.</p> <code>hits</code> <code>MapType</code> <p>The hit count map. We use this as a preconditioner which helps small-scale convergence quite a bit.</p> Source code in <code>witch/external/minkasi/mapmaking.py</code> <pre><code>def make_naive(\n    todvec: minkasi.tods.TodVec, skymap: minkasi.maps.MapType, outdir: str\n) -&gt; tuple[minkasi.maps.MapType, minkasi.maps.MapType]:\n    \"\"\"\n    Make a naive map where we just bin common mode subtracted TODs.\n\n    Parameters\n    ----------\n    todvec : minkasi.tods.TodVec\n        The TODs to mapmake.\n    skymap : minkasi.maps.MapType\n        Map to use as footprint for outputs.\n\n    Returns\n    -------\n    naive : minkasi.maps.MapType\n        The naive map.\n    hits : minkasi.maps.MapType\n        The hit count map.\n        We use this as a preconditioner which helps small-scale convergence quite a bit.\n    \"\"\"\n    hits = minkasi.mapmaking.make_hits(todvec, skymap)\n\n    # Make a naive map where we just bin the CM subbed tods\n    naive = skymap.copy()\n    naive.clear()\n    for tod in todvec.tods:\n        tmp = tod.info[\"dat_calib\"].copy()\n        u, s, v = np.linalg.svd(tmp, False)\n        tmp -= np.outer(u[:, 0], s[0] * v[0, :])\n        naive.tod2map(tod, tmp)\n    naive.mpi_reduce()\n    naive.map[hits.map &gt; 0] = naive.map[hits.map &gt; 0] / hits.map[hits.map &gt; 0]\n    if minkasi.myrank == 0:\n        naive.write(os.path.join(outdir, \"naive.fits\"))\n        hits.write(os.path.join(outdir, \"hits.fits\"))\n    naive.clear()\n    return naive, hits\n</code></pre>"},{"location":"reference/external/minkasi/mapmaking/#witch.external.minkasi.mapmaking.make_weights","title":"<code>make_weights(todvec, skymap, outdir)</code>","text":"<p>Make weights and noise map.</p> <p>Parameters:</p> Name Type Description Default <code>todvec</code> <code>TodVec</code> <p>The TODs to mapmake.</p> required <code>skymap</code> <code>MapType</code> <p>Map to use as footprint for outputs.</p> required <p>Returns:</p> Name Type Description <code>weightmap</code> <code>MapType</code> <p>The weights map.</p> <code>noisemap</code> <code>MapType</code> <p>The noise map. This is just 1/sqrt(weights).</p> Source code in <code>witch/external/minkasi/mapmaking.py</code> <pre><code>def make_weights(\n    todvec: minkasi.tods.TodVec, skymap: minkasi.maps.MapType, outdir: str\n) -&gt; tuple[minkasi.maps.MapType, minkasi.maps.MapType]:\n    \"\"\"\n    Make weights and noise map.\n\n    Parameters\n    ----------\n    todvec : minkasi.tods.TodVec\n        The TODs to mapmake.\n    skymap : minkasi.maps.MapType\n        Map to use as footprint for outputs.\n\n    Returns\n    -------\n    weightmap : minkasi.maps.MapType\n        The weights map.\n    noisemap : minkasi.maps.MapType\n        The noise map.\n        This is just 1/sqrt(weights).\n    \"\"\"\n    weightmap = minkasi.mapmaking.make_hits(todvec, skymap, do_weights=True)\n    mask = weightmap.map &gt; 0\n    tmp = weightmap.map.copy()\n    tmp[mask] = 1.0 / np.sqrt(tmp[mask])\n    noisemap = weightmap.copy()\n    noisemap.map[:] = tmp\n    if minkasi.myrank == 0:\n        noisemap.write(os.path.join(outdir, \"noise.fits\"))\n        weightmap.write(os.path.join(outdir, \"weights.fits\"))\n\n    return weightmap, noisemap\n</code></pre>"},{"location":"reference/external/minkasi/mapmaking/#witch.external.minkasi.mapmaking.reestimate_noise_from_map","title":"<code>reestimate_noise_from_map(todvec, mapset, noise_class, noise_args, noise_kwargs)</code>","text":"<p>Use the current guess at the map to reestimate the noise:</p> <p>Parameters:</p> Name Type Description Default <code>todvec</code> <code>TodVec</code> <p>The TODs to reestimate noise for.</p> required <code>mapset</code> <code>Mapset</code> <p>Mapset containing the current map solution.</p> required <code>noise_class</code> <code>NoiseModelType</code> <p>Which noise model to use.</p> required <code>noise_args</code> <code>tuple</code> <p>Additional arguments to pass to <code>minkasi.tods.Tod.set_noise</code>.</p> required <code>noise_kwargs</code> <code>dict</code> <p>Additional keyword arguments to pass to <code>minkasi.tods.Tod.set_noise</code>.</p> required Source code in <code>witch/external/minkasi/mapmaking.py</code> <pre><code>def reestimate_noise_from_map(\n    todvec: minkasi.tods.TodVec,\n    mapset: minkasi.maps.Mapset,\n    noise_class: minkasi.mapmaking.NoiseModelType,\n    noise_args: tuple,\n    noise_kwargs: dict,\n):\n    \"\"\"\n    Use the current guess at the map to reestimate the noise:\n\n    Parameters\n    ----------\n    todvec : minkasi.tods.TodVec\n        The TODs to reestimate noise for.\n    mapset : minkasi.maps.Mapset\n        Mapset containing the current map solution.\n    noise_class : minkasi.mapmaking.NoiseModelType\n        Which noise model to use.\n    noise_args : tuple\n        Additional arguments to pass to `minkasi.tods.Tod.set_noise`.\n    noise_kwargs : dict\n        Additional keyword arguments to pass to `minkasi.tods.Tod.set_noise`.\n    \"\"\"\n    for tod in todvec.tods:\n        mat = 0 * tod.info[\"dat_calib\"]\n        for mm in mapset.maps:\n            mm.map2tod(tod, mat)\n        tod.set_noise(\n            noise_class,\n            dat=tod.info[\"dat_calib\"] - mat,\n            *noise_args,\n            **noise_kwargs,\n        )\n</code></pre>"},{"location":"reference/external/minkasi/mapmaking/#witch.external.minkasi.mapmaking.solve_map","title":"<code>solve_map(todvec, x0, ihits, prior, maxiters, save_iters, outdir, desc_str)</code>","text":"<p>Solve for map with PCG.</p> <p>Parameters:</p> Name Type Description Default <code>todvec</code> <code>TodVec</code> <p>The TODs what we are mapmaking.</p> required <code>x0</code> <code>Mapset</code> <p>The initial guess mapset.</p> required <code>ihits</code> <code>MapType</code> <p>The inverse hits map.</p> required <code>prior</code> <code>Optional[HasPrior]</code> <p>Prior to use when mapmaking, set to None to not use.</p> required <code>maxiters</code> <code>int</code> <p>Maximum PCG iters to use.</p> required <code>save_iters</code> <code>list[int]</code> <p>Which iterations to save the map at.</p> required <code>outdir</code> <code>str</code> <p>The output directory</p> required <code>desc_str</code> <code>str</code> <p>String used to determine outroot.</p> required <p>Returns:</p> Name Type Description <code>mapset</code> <code>Mapset</code> <p>The mapset with the solved map.</p> Source code in <code>witch/external/minkasi/mapmaking.py</code> <pre><code>def solve_map(\n    todvec: minkasi.tods.TodVec,\n    x0: minkasi.maps.Mapset,\n    ihits: minkasi.maps.MapType,\n    prior: Optional[minkasi.mapmaking.pcg.HasPrior],\n    maxiters: int,\n    save_iters: list[int],\n    outdir: str,\n    desc_str: str,\n) -&gt; minkasi.maps.Mapset:\n    \"\"\"\n    Solve for map with PCG.\n\n    Parameters\n    ----------\n    todvec : minkasi.tods.TodVec\n        The TODs what we are mapmaking.\n    x0 : minkasi.maps.Mapset\n        The initial guess mapset.\n    ihits : minkasi.maps.MapType\n        The inverse hits map.\n    prior : Optional[minkasi.mapmaking.pgc.HasPrior]\n        Prior to use when mapmaking, set to None to not use.\n    maxiters : int\n        Maximum PCG iters to use.\n    save_iters : list[int]\n        Which iterations to save the map at.\n    outdir : str\n        The output directory\n    desc_str : str\n        String used to determine outroot.\n\n    Returns\n    -------\n    mapset : minkasi.maps.Mapset\n        The mapset with the solved map.\n    \"\"\"\n    # make A^T N^1 d.  TODs need to understand what to do with maps\n    # but maps don't necessarily need to understand what to do with TODs,\n    # hence putting make_rhs in the vector of TODs.\n    # Again, make_rhs is MPI-aware, so this should do the right thing\n    # if you run with many processes.\n    rhs = x0.copy()\n    todvec.make_rhs(rhs)\n\n    # Preconditioner is 1/ hit count map.\n    # Helps a lot for convergence.\n    precon = x0.copy()\n    precon.maps[0].map[:] = ihits.map[:]\n\n    # run PCG to solve\n    # Supressing print here, probably want a verbosity setting on the minkasi side...\n    with open(os.devnull, \"w\") as f, contextlib.redirect_stdout(f):\n        mapset = minkasi.mapmaking.run_pcg_wprior(\n            rhs,\n            x0,\n            todvec,\n            prior,\n            precon,\n            maxiter=maxiters,\n            outroot=os.path.join(outdir, desc_str),\n            save_iters=save_iters,\n        )\n\n    if minkasi.myrank == 0:\n        mapset.maps[0].write(\n            os.path.join(outdir, f\"{desc_str}.fits\")\n        )  # and write out the map as a FITS file\n\n    return mapset\n</code></pre>"},{"location":"reference/external/minkasi/utils/","title":"utils","text":""}]}