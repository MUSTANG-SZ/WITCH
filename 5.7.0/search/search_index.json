{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"WITCH (WHERE IS THAT CLUSTER HIDING)","text":"<p>This repository contains tools for modeling and fitting SZ data of galaxy clusters. While this code was originally written for MUSTANG-2 it is largely generic enough to work with data for other telescopes.</p>"},{"location":"#the-witch-library","title":"The <code>WITCH</code> Library","text":"<p>The core of this repository is the <code>WITCH</code> library. While the name contains <code>minkasi</code> it does not actually require the <code>minkasi</code> mapmaker to be used; rather, it produces models of galaxy clusters and their gradients in a format that can be consumed by <code>minkasi</code>'s fitting code.</p> <p>The core concept of <code>WITCH</code> is to model the cluster as a 3D pressure profile and then apply modifications to that profile to represent substructure. For example, a cavity can be modeled as a multiplicative suppression of the pressure within a certain region. The profile is then integrated along the line of sight to produce a signal like we would observe via the SZ effect. To produce gradients of the clusters and JIT expensive computations we employ <code>jax</code>.</p> <p>This framework makes it very easy to add new types of models, see the Contributing section for more.</p>"},{"location":"#the-fitterpy-script","title":"The <code>fitter.py</code> Script","text":"<p>The other main part of this repository is the <code>fitter.py</code> script. It is generically a script to perform fit models and make maps using <code>minkasi</code>, but there are a two key points that make it nice to use:</p> <ol> <li>A flexible configuration system that allows the user to control mapmaking and fitting parameters, model specification, IO, etc. via yaml files.</li> <li>First class support for models from the <code>WITCH</code> library.</li> </ol> <p>For the most part the config files are easy to make by using one of the files in the <code>configs</code> folder as a base. However there are some subtleties and advanced configurations that will eventually get documented properly.</p>"},{"location":"#installation","title":"Installation","text":"<p>To install the <code>WITCH</code> library first clone this repository and from within it run:</p> <pre><code>pip install .\n</code></pre> <p>Note that this will only install <code>WITCH</code> and its dependencies, to also install dependencies for <code>fitter.py</code> do:</p> <pre><code>pip install .[fitter]\n</code></pre> <p>If you are going to be actively working on the <code>WITCH</code> library you probably want to include the <code>-e</code> flag.</p> <p>All the dependencies should be installed by <code>pip</code> with the one exception being <code>minkasi</code> itself (only needed for <code>fitter.py</code>). Instructions on installing <code>minkasi</code> can be found here.</p>"},{"location":"#contributing","title":"Contributing","text":"<p>All are welcome to contribute to this repository, be it code or config files. In general contributions other than minor changes should follow the branch/fork -&gt; PR -&gt; merge workflow. If you are going to contribute regularly, contact one of us to get push access to the repository.</p>"},{"location":"#style-and-standards","title":"Style and Standards","text":"<p>In general contributions should be PEP8 with commits in the conventional commits format. This library follows semantic versioning, so changes that bump the version should do so by editing <code>pyproject.toml</code>.</p> <p>In order to make following these rules easier this repository is setup to work with commitizen and pre-commit. It is recommended that you make use of these tools to save time.</p>"},{"location":"#getting-started","title":"Getting Started","text":"<ol> <li>Install both tools with <code>pip install commitizen pre-commit</code>.</li> <li><code>cd</code> into the <code>WITCH</code> repository it you aren't already in it.</li> <li>(Optional) Setup <code>commitizen</code> to automatically run when you run <code>git commit</code>. Follow instruction here.</li> <li>Make sure the <code>pre-commit</code> hook is installed by running <code>pre-commit install</code>.</li> </ol>"},{"location":"#example-workflow","title":"Example Workflow","text":"<ol> <li>Make a branch for the edits you want to make.</li> <li>Code.</li> <li>Commit your code with a conventional commit message.</li> <li><code>cz c</code> gives you a wizard that will do this for you, if you followed Step 3 above then <code>git commit</code> will also do this (but not <code>git commit -m</code>).</li> <li>Repeat step 3 and 4 until the goal if your branch has been completed.</li> <li>Put in a PR.</li> <li>Once the PR is merged the repo version and tag will update automatically.</li> </ol>"},{"location":"#adding-new-models","title":"Adding New Models","text":"<p>When adding new models to <code>WITCH</code>, be they profiles or substructure, there are some changes that need to be made to <code>core.py</code> to expose them properly.</p> <ol> <li>A variable <code>N_PAR_{MODEL}</code> needs to be defined with the number of fittable parameters in the model. Do not include parameters like the grid here.</li> <li>A parameter <code>n_{model}</code> needs to be added to the functions <code>helper</code>, <code>model</code>, and <code>model_grad</code>. Remember to update the <code>static_argnums</code> for <code>model</code> and <code>model_grad</code>. In <code>helper</code> set a default value of <code>0</code> for backwards compatibility.</li> <li>A block grabbing the parameters for the model needs to be added to <code>model</code>. This can largely be copied from the other models, just remember to swap out the relevant variables.</li> <li>A block applying model needs to be added to <code>model</code>. Pressure profiles should come first then substructure. This can largely be copied from the other models, just remember to swap out the relevant variables.</li> </ol> <p>Adding a new model also (usually) means you should bump the minor version in the version number.</p>"},{"location":"#profiling-code","title":"Profiling Code","text":"<p>The script <code>scratch/profile.py</code> uses <code>jax</code> profiling tools to benchmark the library. It outputs a trace file understandable perfetto as well as a text file containing metadata about the software and hardware used while profiling. To use non default settings use <code>python profile.py --help</code> but in most cases the default settings are fine.</p> <p>The profiling script has some additional dependencies. To install them run:</p> <pre><code>pip install .[profile]\n</code></pre>"},{"location":"reference/SUMMARY/","title":"SUMMARY","text":"<ul> <li>containers</li> <li>core</li> <li>fitter</li> <li>forward_modeling</li> <li>mapmaking</li> <li>plotting</li> <li>structure</li> <li>utils</li> </ul>"},{"location":"reference/containers/","title":"containers","text":"<p>Data classes for describing models in a structured way.</p>"},{"location":"reference/containers/#witch.containers.Model","title":"<code>Model</code>  <code>dataclass</code>","text":"<p>Dataclass to describe a model. This includes some caching features that improve performance when fitting. Note that because of the caching dynamically modifying what structures compose the model may not work as intended so beware.</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>str</code> <p>The name of the model. This is used for display purposes only.</p> <code>structures</code> <code>list[Structure]</code> <p>The structures that compose the model. Will be sorted to match <code>core.ORDER</code> once initialized.</p> <code>xyz</code> <code>tuple[Array, Array, Array, float, float]</code> <p>Defines the grid used by model computation. The first three elements are a sparse 3D grid in arcseconds, with the first two elements being RA and Dec respectively and the third element being the LOS. The last two elements are the model center in Ra and Dec (also in arcseconds). The structure functions use this as the coordinate to reference <code>dx</code> and <code>dy</code> to.</p> <code>dz</code> <code>float</code> <p>The LOS integration factor. Should minimally be the pixel size in arcseconds along the LOS, but can also include additional factors for performing unit conversions.</p> <code>beam</code> <code>Array</code> <p>The beam to convolve the model with.</p> <code>n_rounds</code> <code>int</code> <p>How many rounds of fitting to perform.</p> <code>pix_size</code> <code>float | None</code> <p>Pix size of corresponding map</p> <code>lims</code> <code>tuple[float, float, float, float] | None</code> <p>List of ra_min, ra_max, dec_min, dec_max for map model was fit to</p> <code>cur_round</code> <code>int, default: 0</code> <p>Which round of fitting we are currently in, rounds are 0 indexed.</p> <code>chisq</code> <code>float, default: np.inf</code> <p>The chi-squared of this model relative to some data. Used when fitting.</p> <code>original_order</code> <code>list[int]</code> <p>The original order than the structures in <code>structures</code> were inputted.</p> Source code in <code>witch/containers.py</code> <pre><code>@dataclass\nclass Model:\n    \"\"\"\n    Dataclass to describe a model.\n    This includes some caching features that improve performance when fitting.\n    Note that because of the caching dynamically modifying what structures compose\n    the model may not work as intended so beware.\n\n    Attributes\n    ----------\n    name : str\n        The name of the model.\n        This is used for display purposes only.\n    structures : list[Structure]\n        The structures that compose the model.\n        Will be sorted to match `core.ORDER` once initialized.\n    xyz : tuple[jax.Array, jax.Array, jax.Array, float, float]\n        Defines the grid used by model computation.\n        The first three elements are a sparse 3D grid in arcseconds,\n        with the first two elements being RA and Dec respectively and the third\n        element being the LOS. The last two elements are the model center in Ra and Dec\n        (also in arcseconds). The structure functions use this as the coordinate to reference\n        `dx` and `dy` to.\n    dz : float\n        The LOS integration factor.\n        Should minimally be the pixel size in arcseconds along the LOS,\n        but can also include additional factors for performing unit conversions.\n    beam : jax.Array\n        The beam to convolve the model with.\n    n_rounds : int\n        How many rounds of fitting to perform.\n    pix_size : float | None\n        Pix size of corresponding map\n    lims : tuple[float, float, float, float] | None\n        List of ra_min, ra_max, dec_min, dec_max for map model was fit to\n    cur_round : int, default: 0\n        Which round of fitting we are currently in,\n        rounds are 0 indexed.\n    chisq : float, default: np.inf\n        The chi-squared of this model relative to some data.\n        Used when fitting.\n    original_order : list[int]\n        The original order than the structures in `structures` were inputted.\n    \"\"\"\n\n    name: str\n    structures: list[Structure]\n    xyz: tuple[jax.Array, jax.Array, jax.Array, float, float]  # arcseconds\n    dz: float  # arcseconds * unknown\n    beam: jax.Array\n    n_rounds: int\n    pix_size: Optional[float] = None\n    lims: Optional[tuple[float, float, float, float]] = None\n    cur_round: int = 0\n    chisq: float = np.inf\n    original_order: list[int] = field(init=False)\n\n    def __post_init__(self):\n        # Make sure the structure is in the order that core expects\n        structure_idx = np.argsort(\n            [core.ORDER.index(structure.structure) for structure in self.structures]\n        )\n        self.structures = [self.structures[i] for i in structure_idx]\n        self.original_order = list(np.sort(structure_idx))\n\n    def __set_attr__(self, name, value):\n        if name == \"cur_round\":\n            self.__dict__.pop(\"model_grad\", None)\n            self.__dict__.pop(\"model\", None)\n        return super().__setattr__(name, value)\n\n    def __repr__(self) -&gt; str:\n        rep = self.name + \":\\n\"\n        rep += f\"Round {self.cur_round + 1} out of {self.n_rounds}\\n\"\n        for i in self.original_order:\n            struct = self.structures[i]\n            rep += \"\\t\" + struct.name + \":\\n\"\n            for par in struct.parameters:\n                rep += (\n                    \"\\t\\t\"\n                    + par.name\n                    + \"*\" * par.fit[self.cur_round]\n                    + str(par.prior) * (par.prior is not None)\n                    + \" = \"\n                    + str(par.val)\n                    + \" \u00b1 \"\n                    + str(par.err)\n                    + \"\\n\"\n                )\n        rep += f\"chisq is {self.chisq}\"\n        return rep\n\n    @cached_property\n    def n_struct(self) -&gt; list[int]:\n        \"\"\"\n        Number of each type of structures in the model.\n        Note that this is cached.\n\n        Returns\n        -------\n        n_struct : list[int]\n            `n_struct[i]` is the number of `core.ORDER[i]`\n            structures in this model.\n        \"\"\"\n        n_struct = [0] * len(core.ORDER)\n        for structure in self.structures:\n            idx = core.ORDER.index(structure.structure)\n            n_struct[idx] += 1\n        return n_struct\n\n    @property\n    def pars(self) -&gt; list[float]:\n        \"\"\"\n        Get the current parameter values.\n\n        Returns\n        -------\n        pars : list[float]\n            The parameter values in the order expected by `core.model`.\n        \"\"\"\n        pars = []\n        for structure in self.structures:\n            pars += [parameter.val for parameter in structure.parameters]\n        return pars\n\n    @cached_property\n    def par_names(self) -&gt; list[str]:\n        \"\"\"\n        Get the names of all parameters.\n        Note that this is cached.\n\n        Returns\n        -------\n        par_names : list[str]\n            Parameter names in the same order as `pars`.\n        \"\"\"\n        par_names = []\n        for structure in self.structures:\n            par_names += [parameter.name for parameter in structure.parameters]\n        return par_names\n\n    @property\n    def errs(self) -&gt; list[float]:\n        \"\"\"\n        Get the current parameter errors.\n\n        Returns\n        -------\n        errs : list[float]\n            The errors in the same order as vals.\n        \"\"\"\n        errs = []\n        for structure in self.structures:\n            errs += [parameter.err for parameter in structure.parameters]\n        return errs\n\n    @cached_property\n    def priors(self) -&gt; list[Optional[tuple[float, float]]]:\n        \"\"\"\n        Get the priors for all parameters.\n        Note that this is cached.\n\n        Returns\n        -------\n        priors : list[Optional[tuple[float, float]]]\n            Parameter priors in the same order as `pars`.\n        \"\"\"\n        priors = []\n        for structure in self.structures:\n            priors += [parameter.prior for parameter in structure.parameters]\n        return priors\n\n    @property\n    def to_fit(self) -&gt; list[bool]:\n        \"\"\"\n        Get which parameters we want to fit for the current round.\n\n        Returns\n        -------\n        to_fit : list[bool]\n            `to_fit[i]` is True if we want to fit the `i`'th parameter\n            in the current round.\n            This is in the same order as `pars`.\n        \"\"\"\n        to_fit = []\n        for structure in self.structures:\n            to_fit += [\n                parameter.fit[self.cur_round] for parameter in structure.parameters\n            ]\n        return to_fit\n\n    @cached_property\n    def to_fit_ever(self) -&gt; list[bool]:\n        \"\"\"\n        Check which parameters we ever fit.\n        Note that this is cached.\n\n        Returns\n        -------\n        to_fit_ever : list[bool]\n            `to_fit[i]` is True if we ever want to fit the `i`'th parameter.\n            This is in the same order as `pars`.\n        \"\"\"\n        to_fit = []\n        for structure in self.structures:\n            to_fit += [parameter.fit_ever for parameter in structure.parameters]\n        return to_fit\n\n    @cached_property\n    def model(self) -&gt; jax.Array:\n        \"\"\"\n        The evaluated model, see `core.model` for details.\n        Note that this is cached, but is automatically reset whenever\n        `update` is called or `cur_round` changes.\n\n        Returns\n        -------\n        model : jax.Array\n            The model evaluted on `xyz` with the current values of `pars`.\n        \"\"\"\n        return core.model(\n            self.xyz,\n            tuple(self.n_struct),\n            self.dz,\n            self.beam,\n            *self.pars,\n        )\n\n    @cached_property\n    def model_grad(self) -&gt; tuple[jax.Array, jax.Array]:\n        \"\"\"\n        The evaluated model and its gradient, see `core.model_grad` for details.\n        Note that this is cached, but is automatically reset whenever\n        `update` is called or `cur_round` changes.\n\n        Returns\n        -------\n        model : jax.Array\n            The model evaluted on `xyz` with the current values of `pars`.\n        grad : jax.Array\n            The gradient evaluted on `xyz` with the current values of `pars`.\n            Has shape `(len(pars),) + model.shape`.\n        \"\"\"\n        argnums = tuple(np.where(self.to_fit)[0] + core.ARGNUM_SHIFT)\n        return core.model_grad(\n            self.xyz,\n            tuple(self.n_struct),\n            self.dz,\n            self.beam,\n            argnums,\n            *self.pars,\n        )\n\n    def to_tod(self, dx: ArrayLike, dy: ArrayLike) -&gt; jax.Array:\n        \"\"\"\n        Project the model into a TOD.\n\n        Parameters\n        ----------\n        dx : ArrayLike\n            The RA TOD in arcseconds.\n        dy : ArrayLike\n            The Dec TOD in arcseconds.\n\n        Returns\n        -------\n        tod : jax.Array\n            The model as a TOD.\n            Same shape as dx.\n        \"\"\"\n        return wu.bilinear_interp(\n            dx, dy, self.xyz[0].ravel(), self.xyz[1].ravel(), self.model\n        )\n\n    def to_tod_grad(self, dx: ArrayLike, dy: ArrayLike) -&gt; tuple[jax.Array, jax.Array]:\n        \"\"\"\n        Project the model and gradint into a TOD.\n\n        Parameters\n        ----------\n        dx : ArrayLike\n            The RA TOD in arcseconds.\n        dy : ArrayLike\n            The Dec TOD in arcseconds.\n\n        Returns\n        -------\n        tod : jax.Array\n            The model as a TOD.\n            Same shape as dx.\n        grad_tod : jax.Array\n            The gradient as a TOD.\n            Has shape `(len(pars),) + dx.shape`.\n        \"\"\"\n        model, grad = self.model_grad\n        tod = wu.bilinear_interp(\n            dx, dy, self.xyz[0].ravel(), self.xyz[1].ravel(), model\n        )\n        grad_tod = jnp.array(\n            [\n                (\n                    wu.bilinear_interp(\n                        dx, dy, self.xyz[0].ravel(), self.xyz[1].ravel(), _grad\n                    )\n                    if _fit\n                    else jnp.zeros_like(tod)\n                )\n                for _grad, _fit in zip(grad, self.to_fit)\n            ]\n        )\n\n        return tod, grad_tod\n\n    def update(self, vals: Sequence[float], errs: Sequence[float], chisq: float):\n        \"\"\"\n        Update the parameter values and errors as well as the model chi-squared.\n        This also resets the cache on `model` and `model_tod`.\n\n        Parameters\n        ----------\n        vals : Sequence[float]\n            The new parameter values.\n            Should be in the same order as `pars`.\n        errs : Sequence[float]\n            The new parameter errors.\n            Should be in the same order as `pars`.\n        chisq : float\n            The new chi-squared.\n        \"\"\"\n        if not np.array_equal(self.pars, vals):\n            self.__dict__.pop(\"model\", None)\n            self.__dict__.pop(\"model_grad\", None)\n        n = 0\n        for struct in self.structures:\n            for par in struct.parameters:\n                par.val = vals[n]\n                par.err = errs[n]\n                n += 1\n        self.chisq = chisq\n\n    def minkasi_helper(\n        self, params: NDArray[np.floating], tod: Tod\n    ) -&gt; tuple[NDArray[np.floating], NDArray[np.floating]]:\n        \"\"\"\n        Helper function to work with minkasi fitting routines.\n        You should never need to touch this yourself, just pass it to\n        `minkasi.fitting.fit_timestreams_with_derivs_manyfun`.\n\n        Parameters\n        ----------\n        params : NDArray[np.floating]\n            Array of model parameters.\n            Should be in the same order as `pars`\n        tod : Tod\n            A minkasi tod instance.\n            'dx' and 'dy' must be in tod.info and be in radians.\n\n        Returns\n        -------\n        grad : NDArray[np.floating]\n            The gradient of the model with respect to the model parameters.\n        pred : NDArray[np.floating]\n            The model with the specified substructure.\n        \"\"\"\n        self.update(list(params), self.errs, self.chisq)\n        dx = tod.info[\"dx\"] * wu.rad_to_arcsec\n        dy = tod.info[\"dy\"] * wu.rad_to_arcsec\n\n        pred_tod, grad_tod = self.to_tod_grad(dx, dy)\n        pred_tod = jax.device_get(pred_tod)\n        grad_tod = jax.device_get(grad_tod)\n\n        return grad_tod, pred_tod\n\n    def remove_struct(self, struct_name: str):\n        \"\"\"\n        Remove structure by name.\n\n        Parameters\n        ----------\n        struct_name : str\n            Name of struct to be removed.\n        \"\"\"\n        n = None\n        for i, structure in enumerate(self.structures):\n            if str(structure.name) == str(struct_name):\n                n = i\n        if type(n) == int:\n            self.structures.pop(n)\n        else:\n            raise ValueError(\"Error: {} not in structure names\".format(struct_name))\n\n        self.__dict__.pop(\"to_fit_ever\")\n        self.__dict__.pop(\"n_struct\")\n        self.__dict__.pop(\"priors\")\n        self.__dict__.pop(\"par_names\")\n        self.__dict__.pop(\"model\")\n        self.__post_init__()\n\n    def save(self, path: str):\n        \"\"\"\n        Serialize the model to a file with dill.\n\n        Parameters\n        ----------\n        path : str\n            The file to save to.\n            Does not check to see if the path is valid.\n        \"\"\"\n        with open(path, \"wb\") as f:\n            dill.dump(self, f)\n\n    @classmethod\n    def load(cls, path: str) -&gt; Self:\n        \"\"\"\n        Load the model from a file with dill.\n\n        Parameters\n        ----------\n        path : str\n            The path to the saved model.\n            Does not check to see if the path is valid.\n\n        Returns\n        -------\n        model : Model\n            The loaded model.\n        \"\"\"\n        with open(path, \"rb\") as f:\n            return dill.load(f)\n\n    @classmethod\n    def from_cfg(\n        cls,\n        cfg: dict,\n        pix_size: Optional[float] = None,\n        lims: Optional[tuple[float, float, float, float]] = None,\n    ) -&gt; Self:\n        \"\"\"\n        Create an instance of model from a witcher config.\n\n        Parameters\n        ----------\n        cfg : dict\n            The config loaded into a dict.\n        pix_size : float | None\n            Pix size of corresponding map\n        lims : tuple[float, float, float, float] | None\n            List of ra_min, ra_max, dec_min, dec_max for map model was fit to\n\n        Returns\n        -------\n        model : Model\n            The model described by the config.\n        \"\"\"\n        # Do imports\n        for module, name in cfg.get(\"imports\", {}).items():\n            mod = import_module(module)\n            if isinstance(name, str):\n                locals()[name] = mod\n            elif isinstance(name, list):\n                for n in name:\n                    locals()[n] = getattr(mod, n)\n            else:\n                raise TypeError(\"Expect import name to be a string or a list\")\n\n        # Load constants\n        constants = {\n            name: eval(str(const)) for name, const in cfg.get(\"constants\", {}).items()\n        }  # pyright: ignore [reportUnusedVariable]\n\n        # Get jax device\n        dev_id = cfg.get(\"jax_device\", 0)\n        device = jax.devices()[dev_id]\n\n        # Setup coordindate stuff\n        r_map = eval(str(cfg[\"coords\"][\"r_map\"]))\n        dr = eval(str(cfg[\"coords\"][\"dr\"]))\n        dz = eval(str(cfg[\"coords\"].get(\"dz\", dr)))\n        x0 = eval(str(cfg[\"coords\"][\"x0\"]))\n        y0 = eval(str(cfg[\"coords\"][\"y0\"]))\n\n        xyz_host = wu.make_grid(\n            r_map, dr, dr, dz, x0 * wu.rad_to_arcsec, y0 * wu.rad_to_arcsec\n        )\n        xyz = jax.device_put(xyz_host, device)\n        xyz[0].block_until_ready()\n        xyz[1].block_until_ready()\n        xyz[2].block_until_ready()\n\n        # Make beam\n        beam = wu.beam_double_gauss(\n            dr,\n            eval(str(cfg[\"beam\"][\"fwhm1\"])),\n            eval(str(cfg[\"beam\"][\"amp1\"])),\n            eval(str(cfg[\"beam\"][\"fwhm2\"])),\n            eval(str(cfg[\"beam\"][\"amp2\"])),\n        )\n        beam = jax.device_put(beam, device)\n\n        n_rounds = cfg.get(\"n_rounds\", 1)\n        dz = dz * eval(str(cfg[\"model\"][\"unit_conversion\"]))\n\n        structures = []\n        for name, structure in cfg[\"model\"][\"structures\"].items():\n            parameters = []\n            for par_name, param in structure[\"parameters\"].items():\n                val = eval(str(param[\"value\"]))\n                fit = param.get(\"to_fit\", [False] * n_rounds)\n                if isinstance(fit, bool):\n                    fit = [fit] * n_rounds\n                if len(fit) != n_rounds:\n                    raise ValueError(\n                        f\"to_fit has {len(fit)} entries but we only have {n_rounds} rounds\"\n                    )\n                priors = param.get(\"priors\", None)\n                if priors is not None:\n                    priors = eval(str(priors))\n                parameters.append(Parameter(par_name, fit, val, 0.0, priors))\n            structures.append(Structure(name, structure[\"structure\"], parameters))\n        name = cfg[\"model\"].get(\n            \"name\", \"-\".join([structure.name for structure in structures])\n        )\n\n        return cls(name, structures, xyz, dz, beam, n_rounds, pix_size, lims)\n</code></pre>"},{"location":"reference/containers/#witch.containers.Model.errs","title":"<code>errs: list[float]</code>  <code>property</code>","text":"<p>Get the current parameter errors.</p> <p>Returns:</p> Name Type Description <code>errs</code> <code>list[float]</code> <p>The errors in the same order as vals.</p>"},{"location":"reference/containers/#witch.containers.Model.model","title":"<code>model: jax.Array</code>  <code>cached</code> <code>property</code>","text":"<p>The evaluated model, see <code>core.model</code> for details. Note that this is cached, but is automatically reset whenever <code>update</code> is called or <code>cur_round</code> changes.</p> <p>Returns:</p> Name Type Description <code>model</code> <code>Array</code> <p>The model evaluted on <code>xyz</code> with the current values of <code>pars</code>.</p>"},{"location":"reference/containers/#witch.containers.Model.model_grad","title":"<code>model_grad: tuple[jax.Array, jax.Array]</code>  <code>cached</code> <code>property</code>","text":"<p>The evaluated model and its gradient, see <code>core.model_grad</code> for details. Note that this is cached, but is automatically reset whenever <code>update</code> is called or <code>cur_round</code> changes.</p> <p>Returns:</p> Name Type Description <code>model</code> <code>Array</code> <p>The model evaluted on <code>xyz</code> with the current values of <code>pars</code>.</p> <code>grad</code> <code>Array</code> <p>The gradient evaluted on <code>xyz</code> with the current values of <code>pars</code>. Has shape <code>(len(pars),) + model.shape</code>.</p>"},{"location":"reference/containers/#witch.containers.Model.n_struct","title":"<code>n_struct: list[int]</code>  <code>cached</code> <code>property</code>","text":"<p>Number of each type of structures in the model. Note that this is cached.</p> <p>Returns:</p> Name Type Description <code>n_struct</code> <code>list[int]</code> <p><code>n_struct[i]</code> is the number of <code>core.ORDER[i]</code> structures in this model.</p>"},{"location":"reference/containers/#witch.containers.Model.par_names","title":"<code>par_names: list[str]</code>  <code>cached</code> <code>property</code>","text":"<p>Get the names of all parameters. Note that this is cached.</p> <p>Returns:</p> Name Type Description <code>par_names</code> <code>list[str]</code> <p>Parameter names in the same order as <code>pars</code>.</p>"},{"location":"reference/containers/#witch.containers.Model.pars","title":"<code>pars: list[float]</code>  <code>property</code>","text":"<p>Get the current parameter values.</p> <p>Returns:</p> Name Type Description <code>pars</code> <code>list[float]</code> <p>The parameter values in the order expected by <code>core.model</code>.</p>"},{"location":"reference/containers/#witch.containers.Model.priors","title":"<code>priors: list[Optional[tuple[float, float]]]</code>  <code>cached</code> <code>property</code>","text":"<p>Get the priors for all parameters. Note that this is cached.</p> <p>Returns:</p> Name Type Description <code>priors</code> <code>list[Optional[tuple[float, float]]]</code> <p>Parameter priors in the same order as <code>pars</code>.</p>"},{"location":"reference/containers/#witch.containers.Model.to_fit","title":"<code>to_fit: list[bool]</code>  <code>property</code>","text":"<p>Get which parameters we want to fit for the current round.</p> <p>Returns:</p> Name Type Description <code>to_fit</code> <code>list[bool]</code> <p><code>to_fit[i]</code> is True if we want to fit the <code>i</code>'th parameter in the current round. This is in the same order as <code>pars</code>.</p>"},{"location":"reference/containers/#witch.containers.Model.to_fit_ever","title":"<code>to_fit_ever: list[bool]</code>  <code>cached</code> <code>property</code>","text":"<p>Check which parameters we ever fit. Note that this is cached.</p> <p>Returns:</p> Name Type Description <code>to_fit_ever</code> <code>list[bool]</code> <p><code>to_fit[i]</code> is True if we ever want to fit the <code>i</code>'th parameter. This is in the same order as <code>pars</code>.</p>"},{"location":"reference/containers/#witch.containers.Model.from_cfg","title":"<code>from_cfg(cfg, pix_size=None, lims=None)</code>  <code>classmethod</code>","text":"<p>Create an instance of model from a witcher config.</p> <p>Parameters:</p> Name Type Description Default <code>cfg</code> <code>dict</code> <p>The config loaded into a dict.</p> required <code>pix_size</code> <code>float | None</code> <p>Pix size of corresponding map</p> <code>None</code> <code>lims</code> <code>tuple[float, float, float, float] | None</code> <p>List of ra_min, ra_max, dec_min, dec_max for map model was fit to</p> <code>None</code> <p>Returns:</p> Name Type Description <code>model</code> <code>Model</code> <p>The model described by the config.</p> Source code in <code>witch/containers.py</code> <pre><code>@classmethod\ndef from_cfg(\n    cls,\n    cfg: dict,\n    pix_size: Optional[float] = None,\n    lims: Optional[tuple[float, float, float, float]] = None,\n) -&gt; Self:\n    \"\"\"\n    Create an instance of model from a witcher config.\n\n    Parameters\n    ----------\n    cfg : dict\n        The config loaded into a dict.\n    pix_size : float | None\n        Pix size of corresponding map\n    lims : tuple[float, float, float, float] | None\n        List of ra_min, ra_max, dec_min, dec_max for map model was fit to\n\n    Returns\n    -------\n    model : Model\n        The model described by the config.\n    \"\"\"\n    # Do imports\n    for module, name in cfg.get(\"imports\", {}).items():\n        mod = import_module(module)\n        if isinstance(name, str):\n            locals()[name] = mod\n        elif isinstance(name, list):\n            for n in name:\n                locals()[n] = getattr(mod, n)\n        else:\n            raise TypeError(\"Expect import name to be a string or a list\")\n\n    # Load constants\n    constants = {\n        name: eval(str(const)) for name, const in cfg.get(\"constants\", {}).items()\n    }  # pyright: ignore [reportUnusedVariable]\n\n    # Get jax device\n    dev_id = cfg.get(\"jax_device\", 0)\n    device = jax.devices()[dev_id]\n\n    # Setup coordindate stuff\n    r_map = eval(str(cfg[\"coords\"][\"r_map\"]))\n    dr = eval(str(cfg[\"coords\"][\"dr\"]))\n    dz = eval(str(cfg[\"coords\"].get(\"dz\", dr)))\n    x0 = eval(str(cfg[\"coords\"][\"x0\"]))\n    y0 = eval(str(cfg[\"coords\"][\"y0\"]))\n\n    xyz_host = wu.make_grid(\n        r_map, dr, dr, dz, x0 * wu.rad_to_arcsec, y0 * wu.rad_to_arcsec\n    )\n    xyz = jax.device_put(xyz_host, device)\n    xyz[0].block_until_ready()\n    xyz[1].block_until_ready()\n    xyz[2].block_until_ready()\n\n    # Make beam\n    beam = wu.beam_double_gauss(\n        dr,\n        eval(str(cfg[\"beam\"][\"fwhm1\"])),\n        eval(str(cfg[\"beam\"][\"amp1\"])),\n        eval(str(cfg[\"beam\"][\"fwhm2\"])),\n        eval(str(cfg[\"beam\"][\"amp2\"])),\n    )\n    beam = jax.device_put(beam, device)\n\n    n_rounds = cfg.get(\"n_rounds\", 1)\n    dz = dz * eval(str(cfg[\"model\"][\"unit_conversion\"]))\n\n    structures = []\n    for name, structure in cfg[\"model\"][\"structures\"].items():\n        parameters = []\n        for par_name, param in structure[\"parameters\"].items():\n            val = eval(str(param[\"value\"]))\n            fit = param.get(\"to_fit\", [False] * n_rounds)\n            if isinstance(fit, bool):\n                fit = [fit] * n_rounds\n            if len(fit) != n_rounds:\n                raise ValueError(\n                    f\"to_fit has {len(fit)} entries but we only have {n_rounds} rounds\"\n                )\n            priors = param.get(\"priors\", None)\n            if priors is not None:\n                priors = eval(str(priors))\n            parameters.append(Parameter(par_name, fit, val, 0.0, priors))\n        structures.append(Structure(name, structure[\"structure\"], parameters))\n    name = cfg[\"model\"].get(\n        \"name\", \"-\".join([structure.name for structure in structures])\n    )\n\n    return cls(name, structures, xyz, dz, beam, n_rounds, pix_size, lims)\n</code></pre>"},{"location":"reference/containers/#witch.containers.Model.load","title":"<code>load(path)</code>  <code>classmethod</code>","text":"<p>Load the model from a file with dill.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>The path to the saved model. Does not check to see if the path is valid.</p> required <p>Returns:</p> Name Type Description <code>model</code> <code>Model</code> <p>The loaded model.</p> Source code in <code>witch/containers.py</code> <pre><code>@classmethod\ndef load(cls, path: str) -&gt; Self:\n    \"\"\"\n    Load the model from a file with dill.\n\n    Parameters\n    ----------\n    path : str\n        The path to the saved model.\n        Does not check to see if the path is valid.\n\n    Returns\n    -------\n    model : Model\n        The loaded model.\n    \"\"\"\n    with open(path, \"rb\") as f:\n        return dill.load(f)\n</code></pre>"},{"location":"reference/containers/#witch.containers.Model.minkasi_helper","title":"<code>minkasi_helper(params, tod)</code>","text":"<p>Helper function to work with minkasi fitting routines. You should never need to touch this yourself, just pass it to <code>minkasi.fitting.fit_timestreams_with_derivs_manyfun</code>.</p> <p>Parameters:</p> Name Type Description Default <code>params</code> <code>NDArray[floating]</code> <p>Array of model parameters. Should be in the same order as <code>pars</code></p> required <code>tod</code> <code>Tod</code> <p>A minkasi tod instance. 'dx' and 'dy' must be in tod.info and be in radians.</p> required <p>Returns:</p> Name Type Description <code>grad</code> <code>NDArray[floating]</code> <p>The gradient of the model with respect to the model parameters.</p> <code>pred</code> <code>NDArray[floating]</code> <p>The model with the specified substructure.</p> Source code in <code>witch/containers.py</code> <pre><code>def minkasi_helper(\n    self, params: NDArray[np.floating], tod: Tod\n) -&gt; tuple[NDArray[np.floating], NDArray[np.floating]]:\n    \"\"\"\n    Helper function to work with minkasi fitting routines.\n    You should never need to touch this yourself, just pass it to\n    `minkasi.fitting.fit_timestreams_with_derivs_manyfun`.\n\n    Parameters\n    ----------\n    params : NDArray[np.floating]\n        Array of model parameters.\n        Should be in the same order as `pars`\n    tod : Tod\n        A minkasi tod instance.\n        'dx' and 'dy' must be in tod.info and be in radians.\n\n    Returns\n    -------\n    grad : NDArray[np.floating]\n        The gradient of the model with respect to the model parameters.\n    pred : NDArray[np.floating]\n        The model with the specified substructure.\n    \"\"\"\n    self.update(list(params), self.errs, self.chisq)\n    dx = tod.info[\"dx\"] * wu.rad_to_arcsec\n    dy = tod.info[\"dy\"] * wu.rad_to_arcsec\n\n    pred_tod, grad_tod = self.to_tod_grad(dx, dy)\n    pred_tod = jax.device_get(pred_tod)\n    grad_tod = jax.device_get(grad_tod)\n\n    return grad_tod, pred_tod\n</code></pre>"},{"location":"reference/containers/#witch.containers.Model.remove_struct","title":"<code>remove_struct(struct_name)</code>","text":"<p>Remove structure by name.</p> <p>Parameters:</p> Name Type Description Default <code>struct_name</code> <code>str</code> <p>Name of struct to be removed.</p> required Source code in <code>witch/containers.py</code> <pre><code>def remove_struct(self, struct_name: str):\n    \"\"\"\n    Remove structure by name.\n\n    Parameters\n    ----------\n    struct_name : str\n        Name of struct to be removed.\n    \"\"\"\n    n = None\n    for i, structure in enumerate(self.structures):\n        if str(structure.name) == str(struct_name):\n            n = i\n    if type(n) == int:\n        self.structures.pop(n)\n    else:\n        raise ValueError(\"Error: {} not in structure names\".format(struct_name))\n\n    self.__dict__.pop(\"to_fit_ever\")\n    self.__dict__.pop(\"n_struct\")\n    self.__dict__.pop(\"priors\")\n    self.__dict__.pop(\"par_names\")\n    self.__dict__.pop(\"model\")\n    self.__post_init__()\n</code></pre>"},{"location":"reference/containers/#witch.containers.Model.save","title":"<code>save(path)</code>","text":"<p>Serialize the model to a file with dill.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>The file to save to. Does not check to see if the path is valid.</p> required Source code in <code>witch/containers.py</code> <pre><code>def save(self, path: str):\n    \"\"\"\n    Serialize the model to a file with dill.\n\n    Parameters\n    ----------\n    path : str\n        The file to save to.\n        Does not check to see if the path is valid.\n    \"\"\"\n    with open(path, \"wb\") as f:\n        dill.dump(self, f)\n</code></pre>"},{"location":"reference/containers/#witch.containers.Model.to_tod","title":"<code>to_tod(dx, dy)</code>","text":"<p>Project the model into a TOD.</p> <p>Parameters:</p> Name Type Description Default <code>dx</code> <code>ArrayLike</code> <p>The RA TOD in arcseconds.</p> required <code>dy</code> <code>ArrayLike</code> <p>The Dec TOD in arcseconds.</p> required <p>Returns:</p> Name Type Description <code>tod</code> <code>Array</code> <p>The model as a TOD. Same shape as dx.</p> Source code in <code>witch/containers.py</code> <pre><code>def to_tod(self, dx: ArrayLike, dy: ArrayLike) -&gt; jax.Array:\n    \"\"\"\n    Project the model into a TOD.\n\n    Parameters\n    ----------\n    dx : ArrayLike\n        The RA TOD in arcseconds.\n    dy : ArrayLike\n        The Dec TOD in arcseconds.\n\n    Returns\n    -------\n    tod : jax.Array\n        The model as a TOD.\n        Same shape as dx.\n    \"\"\"\n    return wu.bilinear_interp(\n        dx, dy, self.xyz[0].ravel(), self.xyz[1].ravel(), self.model\n    )\n</code></pre>"},{"location":"reference/containers/#witch.containers.Model.to_tod_grad","title":"<code>to_tod_grad(dx, dy)</code>","text":"<p>Project the model and gradint into a TOD.</p> <p>Parameters:</p> Name Type Description Default <code>dx</code> <code>ArrayLike</code> <p>The RA TOD in arcseconds.</p> required <code>dy</code> <code>ArrayLike</code> <p>The Dec TOD in arcseconds.</p> required <p>Returns:</p> Name Type Description <code>tod</code> <code>Array</code> <p>The model as a TOD. Same shape as dx.</p> <code>grad_tod</code> <code>Array</code> <p>The gradient as a TOD. Has shape <code>(len(pars),) + dx.shape</code>.</p> Source code in <code>witch/containers.py</code> <pre><code>def to_tod_grad(self, dx: ArrayLike, dy: ArrayLike) -&gt; tuple[jax.Array, jax.Array]:\n    \"\"\"\n    Project the model and gradint into a TOD.\n\n    Parameters\n    ----------\n    dx : ArrayLike\n        The RA TOD in arcseconds.\n    dy : ArrayLike\n        The Dec TOD in arcseconds.\n\n    Returns\n    -------\n    tod : jax.Array\n        The model as a TOD.\n        Same shape as dx.\n    grad_tod : jax.Array\n        The gradient as a TOD.\n        Has shape `(len(pars),) + dx.shape`.\n    \"\"\"\n    model, grad = self.model_grad\n    tod = wu.bilinear_interp(\n        dx, dy, self.xyz[0].ravel(), self.xyz[1].ravel(), model\n    )\n    grad_tod = jnp.array(\n        [\n            (\n                wu.bilinear_interp(\n                    dx, dy, self.xyz[0].ravel(), self.xyz[1].ravel(), _grad\n                )\n                if _fit\n                else jnp.zeros_like(tod)\n            )\n            for _grad, _fit in zip(grad, self.to_fit)\n        ]\n    )\n\n    return tod, grad_tod\n</code></pre>"},{"location":"reference/containers/#witch.containers.Model.update","title":"<code>update(vals, errs, chisq)</code>","text":"<p>Update the parameter values and errors as well as the model chi-squared. This also resets the cache on <code>model</code> and <code>model_tod</code>.</p> <p>Parameters:</p> Name Type Description Default <code>vals</code> <code>Sequence[float]</code> <p>The new parameter values. Should be in the same order as <code>pars</code>.</p> required <code>errs</code> <code>Sequence[float]</code> <p>The new parameter errors. Should be in the same order as <code>pars</code>.</p> required <code>chisq</code> <code>float</code> <p>The new chi-squared.</p> required Source code in <code>witch/containers.py</code> <pre><code>def update(self, vals: Sequence[float], errs: Sequence[float], chisq: float):\n    \"\"\"\n    Update the parameter values and errors as well as the model chi-squared.\n    This also resets the cache on `model` and `model_tod`.\n\n    Parameters\n    ----------\n    vals : Sequence[float]\n        The new parameter values.\n        Should be in the same order as `pars`.\n    errs : Sequence[float]\n        The new parameter errors.\n        Should be in the same order as `pars`.\n    chisq : float\n        The new chi-squared.\n    \"\"\"\n    if not np.array_equal(self.pars, vals):\n        self.__dict__.pop(\"model\", None)\n        self.__dict__.pop(\"model_grad\", None)\n    n = 0\n    for struct in self.structures:\n        for par in struct.parameters:\n            par.val = vals[n]\n            par.err = errs[n]\n            n += 1\n    self.chisq = chisq\n</code></pre>"},{"location":"reference/containers/#witch.containers.Parameter","title":"<code>Parameter</code>  <code>dataclass</code>","text":"<p>Dataclass to represent a single parameter of a model.</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>str</code> <p>The name of the parameter. This is used only for display purposes.</p> <code>fit</code> <code>list[bool]</code> <p>Should be a a list with length <code>Model.n_rounds</code>. <code>fit[i]</code> is True if we want to fit this parameter in the <code>i</code>'th round.</p> <code>val</code> <code>float</code> <p>The value of the parameter.</p> <code>err</code> <code>float, default: 0</code> <p>The error on the parameter value.</p> <code>prior</code> <code>Optional[tuple[float, float]], default: None</code> <p>The prior on this parameter. Set to None to have to prior, otherwise should be the tuple <code>(lower_bound, upper_bound)</code>.</p> Source code in <code>witch/containers.py</code> <pre><code>@dataclass\nclass Parameter:\n    \"\"\"\n    Dataclass to represent a single parameter of a model.\n\n    Attributes\n    ----------\n    name : str\n        The name of the parameter.\n        This is used only for display purposes.\n    fit : list[bool]\n        Should be a a list with length `Model.n_rounds`.\n        `fit[i]` is True if we want to fit this parameter in the `i`'th round.\n    val : float\n        The value of the parameter.\n    err : float, default: 0\n        The error on the parameter value.\n    prior : Optional[tuple[float, float]], default: None\n        The prior on this parameter.\n        Set to None to have to prior,\n        otherwise should be the tuple `(lower_bound, upper_bound)`.\n    \"\"\"\n\n    name: str\n    fit: list[bool]\n    val: float\n    err: float = 0\n    prior: Optional[tuple[float, float]] = None  # Only flat for now\n\n    def __post_init__(self):\n        # If this isn't a float autograd breaks\n        self.val = float(self.val)\n\n    @property\n    def fit_ever(self) -&gt; bool:\n        \"\"\"\n        Check if this parameter is set to ever be fit.\n\n        Returns\n        -------\n        fit_ever : bool\n            True if this parameter is ever fit.\n        \"\"\"\n        return bool(np.any(self.fit))\n</code></pre>"},{"location":"reference/containers/#witch.containers.Parameter.fit_ever","title":"<code>fit_ever: bool</code>  <code>property</code>","text":"<p>Check if this parameter is set to ever be fit.</p> <p>Returns:</p> Name Type Description <code>fit_ever</code> <code>bool</code> <p>True if this parameter is ever fit.</p>"},{"location":"reference/containers/#witch.containers.Structure","title":"<code>Structure</code>  <code>dataclass</code>","text":"<p>Dataclass to represent a structure within the model.</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>str</code> <p>The name of the structure. This is used only for display purposes.</p> <code>structure</code> <code>str</code> <p>The type of structure that this is an instance of. Should be a string that appears in <code>core.ORDER</code></p> <code>parameters</code> <code>list[Parameter]</code> <p>The model parameters for this structure.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If <code>structure</code> is not a valid structure. If we have the wrong number of parameters.</p> Source code in <code>witch/containers.py</code> <pre><code>@dataclass\nclass Structure:\n    \"\"\"\n    Dataclass to represent a structure within the model.\n\n    Attributes\n    ----------\n    name : str\n        The name of the structure.\n        This is used only for display purposes.\n    structure : str\n        The type of structure that this is an instance of.\n        Should be a string that appears in `core.ORDER`\n    parameters : list[Parameter]\n        The model parameters for this structure.\n\n    Raises\n    ------\n    ValueError\n        If `structure` is not a valid structure.\n        If we have the wrong number of parameters.\n    \"\"\"\n\n    name: str\n    structure: str\n    parameters: list[Parameter]\n\n    def __post_init__(self):\n        self.structure = self.structure.lower()\n        # Check that this is a valid structure\n        if self.structure not in STRUCT_N_PAR.keys():\n            raise ValueError(f\"{self.name} has invalid structure: {self.structure}\")\n        # Check that we have the correct number of params\n        if len(self.parameters) != STRUCT_N_PAR[self.structure]:\n            raise ValueError(\n                f\"{self.name} has incorrect number of parameters, expected {STRUCT_N_PAR[self.structure]} for {self.structure} but was given {len(self.parameters)}\"\n            )\n</code></pre>"},{"location":"reference/core/","title":"core","text":"<p>Core module for generating models and their gradients.</p>"},{"location":"reference/core/#witch.core.model","title":"<code>model = jax.jit(model, static_argnums=model_static)</code>  <code>module-attribute</code>","text":"<p>Generically create models with substructure.</p> <p>Parameters:</p> Name Type Description Default <code>xyz</code> <code>tuple[Array, Array, Array, float, float]</code> <p>Grid to compute model on. See <code>containers.Model.xyz</code> for details.</p> required <code>n_structs</code> <code>tuple[int, ...]</code> <p>Number of each structure to use. Should be in the same order as <code>order</code>.</p> required <code>dz</code> <code>float</code> <p>Factor to scale by while integrating. Should at least include the pixel size along the LOS.</p> required <code>beam</code> <code>Array</code> <p>Beam to convolve by, should be a 2d array.</p> required <code>*pars</code> <code>Unpack[tuple[float, ...]]</code> <p>1D container of model parameters.</p> required <p>Returns:</p> Name Type Description <code>model</code> <code>Array</code> <p>The model with the specified substructure evaluated on the grid.</p>"},{"location":"reference/core/#witch.core.model_grad","title":"<code>model_grad = jax.jit(model_grad, static_argnums=model_grad_static)</code>  <code>module-attribute</code>","text":"<p>A wrapper around model that also returns the gradients of the model. Only the additional arguments are described here, see <code>model</code> for the others. Note that the additional arguments are passed before the *params argument.</p> <p>Parameters:</p> Name Type Description Default <code>argnums</code> <code>tuple[int, ...]</code> <p>The indices of the arguments to evaluate the gradient at.</p> required <p>Returns:</p> Name Type Description <code>model</code> <code>Array</code> <p>The model with the specified substructure evaluated on the grid.</p> <code>grad</code> <code>Array</code> <p>The gradient of the model with respect to the model parameters. Has shape <code>(len(pars),) + model.shape)</code>.</p>"},{"location":"reference/core/#witch.core.stage2_model","title":"<code>stage2_model(xyz, n_structs, dz, beam, *pars)</code>","text":"<p>Only returns the second stage of the model. Used for visualizing shocks, etc. that can otherwise be hard to see in a model plot</p> <p>Parameters:</p> Name Type Description Default <code>xyz</code> <code>tuple[Array, Array, Array, float, float]</code> <p>Grid to compute model on. See <code>containers.Model.xyz</code> for details.</p> required <code>n_structs</code> <code>tuple[int, ...]</code> <p>Number of each structure to use. Should be in the same order as <code>order</code>.</p> required <code>dz</code> <code>float</code> <p>Factor to scale by while integrating. Should at least include the pixel size along the LOS.</p> required <code>beam</code> <code>Array</code> <p>Beam to convolve by, should be a 2d array.</p> required <code>*pars</code> <code>Unpack[tuple[float, ...]]</code> <p>1D container of model parameters.</p> <code>()</code> <p>Returns:</p> Name Type Description <code>model</code> <code>Array</code> <p>The model with the specified substructure evaluated on the grid. No stage 3 structures are included.</p> Source code in <code>witch/core.py</code> <pre><code>def stage2_model(\n    xyz: tuple[jax.Array, jax.Array, jax.Array, float, float],\n    n_structs: tuple[int, ...],\n    dz: float,\n    beam: jax.Array,\n    *pars: Unpack[tuple[float, ...]],\n):\n    \"\"\"\n    Only returns the second stage of the model. Used for visualizing shocks, etc.\n    that can otherwise be hard to see in a model plot\n\n    Parameters\n    ----------\n    xyz : tuple[jax.Array, jax.Array, jax.Array, float, float]\n        Grid to compute model on.\n        See `containers.Model.xyz` for details.\n    n_structs : tuple[int, ...]\n        Number of each structure to use.\n        Should be in the same order as `order`.\n    dz : float\n        Factor to scale by while integrating.\n        Should at least include the pixel size along the LOS.\n    beam : jax.Array\n        Beam to convolve by, should be a 2d array.\n    *pars : Unpack[tuple[float,...]]\n        1D container of model parameters.\n\n    Returns\n    -------\n    model : jax.Array\n        The model with the specified substructure evaluated on the grid.\n        No stage 3 structures are included.\n    \"\"\"\n    params = jnp.array(pars)\n    params = jnp.ravel(params)  # Fixes strange bug with params having dim (1,n)\n\n    pressure = jnp.ones((xyz[0].shape[0], xyz[1].shape[1], xyz[2].shape[2]))\n    start = 0\n\n    # Stage 0, track delta but don't add anything\n    for n_struct, struct in zip(n_structs, ORDER):\n        if STRUCT_STAGE[struct] != 0:\n            continue\n        if not n_struct:\n            continue\n        delta = n_struct * STRUCT_N_PAR[struct]\n        struct_pars = params[start : start + delta].reshape(\n            (n_struct, STRUCT_N_PAR[struct])\n        )\n        start += delta\n\n    # Stage 1, modify the 3d grid\n    for n_struct, struct in zip(n_structs, ORDER):\n        if STRUCT_STAGE[struct] != 1:\n            continue\n        if not n_struct:\n            continue\n\n        delta = n_struct * STRUCT_N_PAR[struct]\n        struct_pars = params[start : start + delta].reshape(\n            (n_struct, STRUCT_N_PAR[struct])\n        )\n\n        start += delta\n        for i in range(n_struct):\n            pressure = STRUCT_FUNCS[struct](pressure, xyz, *struct_pars[i])\n\n    # Integrate along line of site\n    ip = trapz(pressure, dx=dz, axis=-1)\n\n    bound0, bound1 = int((ip.shape[0] - beam.shape[0]) / 2), int(\n        (ip.shape[1] - beam.shape[1]) / 2\n    )\n    beam = jnp.pad(\n        beam,\n        (\n            (bound0, ip.shape[0] - beam.shape[0] - bound0),\n            (bound1, ip.shape[1] - beam.shape[1] - bound1),\n        ),\n    )\n\n    ip = fft_conv(ip, beam)\n\n    return ip\n</code></pre>"},{"location":"reference/fitter/","title":"fitter","text":"<p>Master fitting and map making script. You typically want to run the <code>witcher</code> command instead of this.</p>"},{"location":"reference/fitter/#witch.fitter.deep_merge","title":"<code>deep_merge(a, b)</code>","text":"<p>Based on https://gist.github.com/angstwad/bf22d1822c38a92ec0a9?permalink_comment_id=3517209</p> Source code in <code>witch/fitter.py</code> <pre><code>def deep_merge(a: dict, b: dict) -&gt; dict:\n    \"\"\"\n    Based on https://gist.github.com/angstwad/bf22d1822c38a92ec0a9?permalink_comment_id=3517209\n    \"\"\"\n    result = deepcopy(a)\n    for bk, bv in b.items():\n        av = result.get(bk)\n        if isinstance(av, dict) and isinstance(bv, dict):\n            result[bk] = deep_merge(av, bv)\n        else:\n            result[bk] = deepcopy(bv)\n    return result\n</code></pre>"},{"location":"reference/fitter/#witch.fitter.load_config","title":"<code>load_config(start_cfg, cfg_path)</code>","text":"<p>We want to load a config and if it has the key \"base\", load that as well and merge them. We only want to take things from base that are not in the original config so we merge the original into the newly loaded one.</p> Source code in <code>witch/fitter.py</code> <pre><code>def load_config(start_cfg, cfg_path):\n    \"\"\"\n    We want to load a config and if it has the key \"base\",\n    load that as well and merge them.\n    We only want to take things from base that are not in the original config\n    so we merge the original into the newly loaded one.\n    \"\"\"\n    with open(cfg_path) as file:\n        new_cfg = yaml.safe_load(file)\n    cfg = deep_merge(new_cfg, start_cfg)\n    if \"base\" in new_cfg:\n        base_path = new_cfg[\"base\"]\n        if not os.path.isabs(base_path):\n            base_path = os.path.join(os.path.dirname(cfg_path), base_path)\n        return load_config(cfg, base_path)\n    return cfg\n</code></pre>"},{"location":"reference/fitter/#witch.fitter.print_once","title":"<code>print_once(*args)</code>","text":"<p>Helper function to print only once when running with MPI. Only the rank 0 process will print.</p> <p>Parameters:</p> Name Type Description Default <code>*args</code> <code>Unpack[tuple[Any, ...]]</code> <p>Arguments to pass to print.</p> <code>()</code> Source code in <code>witch/fitter.py</code> <pre><code>def print_once(*args: Unpack[tuple[Any, ...]]):\n    \"\"\"\n    Helper function to print only once when running with MPI.\n    Only the rank 0 process will print.\n\n    Parameters\n    ----------\n    *args : Unpack[tuple[Any, ...]]\n        Arguments to pass to print.\n    \"\"\"\n    if minkasi.myrank == 0:\n        print(*args)\n        sys.stdout.flush()\n</code></pre>"},{"location":"reference/forward_modeling/","title":"forward_modeling","text":"<p>Functions for performing forward modeling</p>"},{"location":"reference/forward_modeling/#witch.forward_modeling.get_chis","title":"<code>get_chis(m, idx, idy, rhs, v, weight, dd=None)</code>","text":"<p>A faster, but more importantly much less memory intensive, way to get chis. The idea is \\({\\chi}^{2} = (d-Am)^T N^{-1} (d-Am)\\). Previously we would calculate the residuals \\(d-Am\\) and calculate directly. However \\(d-Am\\) has shape [ndet, nsamp], which is very big. \\(m\\) has shape [nx, ny], much smaller. \\(A\\), the pointing reconstruction, can be encapsulated into a few pars. Therefore if we can do everthing in map shape, we save a lot on the ammount of stuff we need to put on the GPU. We can expand \\({\\chi}^{2}\\) as</p> \\[ d^T N^{-1} d -2d^T N^{-1} A m + m^T A^T N^{-1} A m = dd - 2(m \\cdot rhs) + mm \\] <p>the first term only has to do with the data. If we care about the absolute value of \\({\\chi}^2\\), which we do at the end, then we can include it in calculation. For MCMC however, we only care about the relative delta chi2 between models. So we can drop that term. For the other terms</p> \\[ mm = m^T A^T N^{-1} A m \\] <p>This term is essentially what we've been doing before, except that m is now in map shape, whereas before m was in tod shape so we essentially had \\(Am\\). So we need to do \\(Am\\), but this is in general fast and Jon has a very fast way of doing it. Finally rhs need only be computed once, and while it is an additional thing to put on the gpu it is small, map shape.</p> <p>Parameters:</p> Name Type Description Default <code>m</code> <code>NDArray[floating]</code> <p>The model evaluated at all the map pixels</p> required <code>idx</code> <code>NDArray[floating]</code> <p>tod.info[\"model_idx\"], the x index output by tod_to_index</p> required <code>idy</code> <code>NDArray[floating]</code> <p>tod.info[\"model_idy\"], the y index output by tod_to_index</p> required <code>rhs</code> <code>NDArray[floating]</code> <p>The map output of todvec.make_rhs. Note this is how the data enters into the chi2 calc.</p> required <code>v</code> <code>NDArray[floating]</code> <p>The right singular vectors for the noise SVD. These rotate the data into the basis of the SVD.</p> required <code>weight</code> <code>NDArray[floating]</code> <p>The noise weights, in fourier space, SVD decomposed.</p> required <code>dd</code> <code>None | floating</code> <p>Optional chi2 from dd. Not necessary for MCMC but is important for evaluating goodness of fit.</p> <code>None</code> Outputs <p>chi2 : np.floating     The chi2 of the model m to the data.</p> Source code in <code>witch/forward_modeling.py</code> <pre><code>@jax.jit\ndef get_chis(m, idx, idy, rhs, v, weight, dd=None):\n    r\"\"\"\n    A faster, but more importantly much less memory intensive, way to get chis.\n    The idea is ${\\chi}^{2} = (d-Am)^T N^{-1} (d-Am)$. Previously we would calculate the residuals $d-Am$\n    and calculate directly. However $d-Am$ has shape [ndet, nsamp], which is very big. $m$ has shape\n    [nx, ny], much smaller. $A$, the pointing reconstruction, can be encapsulated into a few pars.\n    Therefore if we can do everthing in map shape, we save a lot on the ammount of stuff we\n    need to put on the GPU. We can expand ${\\chi}^{2}$ as\n\n    $$\n    d^T N^{-1} d -2d^T N^{-1} A m + m^T A^T N^{-1} A m = dd - 2(m \\cdot rhs) + mm\n    $$\n\n    the first term only has to do with the data. If we care about the absolute value of ${\\chi}^2$,\n    which we do at the end, then we can include it in calculation. For MCMC however, we only\n    care about the relative delta chi2 between models. So we can drop that term. For the other\n    terms\n\n    $$\n    mm = m^T A^T N^{-1} A m\n    $$\n\n    This term is essentially what we've been doing before, except that m is now in map shape,\n    whereas before m was in tod shape so we essentially had $Am$. So we need to do $Am$, but this is\n    in general fast and Jon has a very fast way of doing it. Finally rhs need only be computed\n    once, and while it is an additional thing to put on the gpu it is small, map shape.\n\n    Parameters\n    ----------\n    m : NDArray[np.floating]\n        The model evaluated at all the map pixels\n    idx : NDArray[np.floating]\n        tod.info[\"model_idx\"], the x index output by tod_to_index\n    idy : NDArray[np.floating]\n        tod.info[\"model_idy\"], the y index output by tod_to_index\n    rhs : NDArray[np.floating]\n        The map output of todvec.make_rhs. Note this is how the data enters into the chi2 calc.\n    v : NDArray[np.floating]\n        The right singular vectors for the noise SVD. These rotate the data into the basis of\n        the SVD.\n    weight : NDArray[np.floating]\n        The noise weights, in fourier space, SVD decomposed.\n    dd : None | np.floating\n        Optional chi2 from dd. Not necessary for MCMC but is important for evaluating goodness\n        of fit.\n\n    Outputs\n    -------\n    chi2 : np.floating\n        The chi2 of the model m to the data.\n    \"\"\"\n\n    model = m.at[idy.astype(int), idx.astype(int)].get(mode=\"fill\", fill_value=0)\n\n    # model = model.at[:,0].set((jnp.sqrt(0.5)*model)[:,0]) #This doesn't actually do anything\n    # model = model.at[:,-1].set((jnp.sqrt(0.5)*model)[:,-1])\n    model_rot = jnp.dot(v, model)\n    tmp = jnp.hstack(\n        [model_rot, jnp.fliplr(model_rot[:, 1:-1])]\n    )  # mirror pred so we can do dct of first kind\n    predft = jnp.real(jnp.fft.rfft(tmp, axis=1))\n    nn = predft.shape[1]\n\n    chisq = (\n        jnp.sum(weight[:, :nn] * predft**2) - 2 * jnp.dot(rhs.ravel(), m.ravel()) / 2\n    )  # Man IDK about this factor of 2\n\n    return chisq\n</code></pre>"},{"location":"reference/forward_modeling/#witch.forward_modeling.sample","title":"<code>sample(model_params, xyz, beam, params, tods)</code>","text":"<p>Generate a model realization and compute the chis of that model to data.</p> <p>Arguements:</p> <pre><code>tods: Array of tod parameters. See prep tods\n\nparams: model parameters\n\nmodel_params: number of each model componant\n\nxyz: grid to evaluate model at\n\nbeam: Beam to smooth by\n</code></pre> <p>Returns:</p> <pre><code>chi2: the chi2 difference of the model to the tods\n</code></pre> Source code in <code>witch/forward_modeling.py</code> <pre><code>def sample(model_params, xyz, beam, params, tods):  # , model_params, xyz, beam):\n    \"\"\"\n    Generate a model realization and compute the chis of that model to data.\n\n    Arguements:\n\n        tods: Array of tod parameters. See prep tods\n\n        params: model parameters\n\n        model_params: number of each model componant\n\n        xyz: grid to evaluate model at\n\n        beam: Beam to smooth by\n\n    Returns:\n\n        chi2: the chi2 difference of the model to the tods\n\n    \"\"\"\n    log_like = 0\n    n_iso, n_gnfw, n_gauss, n_egauss, n_uni, n_expo, n_power, n_power_cos = model_params\n\n    m = model(\n        xyz,\n        n_iso,\n        n_gnfw,\n        n_gauss,\n        n_egauss,\n        n_uni,\n        n_expo,\n        n_power,\n        n_power_cos,\n        -2.5e-05,\n        beam,\n        params,\n    )\n\n    for i, tod in enumerate(tods):\n        x, y, rhs, v, weight, norm = tod  # unravel tod\n\n        log_like += jget_chis(m, x, y, rhs, v, weight) / norm\n\n    return log_like\n</code></pre>"},{"location":"reference/mapmaking/","title":"mapmaking","text":"<p>Functions that wrap useful minkasi recipes</p>"},{"location":"reference/mapmaking/#witch.mapmaking.get_grad_prior","title":"<code>get_grad_prior(todvec, mapset, gradmap, *args, **kwargs)</code>","text":"<p>Make a gradient based prior from a map. This helps avoid errors due to sharp features.</p> <p>Parameters:</p> Name Type Description Default <code>todvec</code> <code>TodVec</code> <p>The TODs what we are mapmaking.</p> required <code>mapset</code> <code>Mapset</code> <p>The mapset to compute priors with. We assume that the first element is the map we care about.</p> required <code>gradmap</code> <code>MapType</code> <p>Containter to use as the gradient map.</p> required <code>*args</code> <code>Unpack[tuple]</code> <p>Additional arguments to pass to get_grad_mask_2d.</p> <code>()</code> <code>**kwargs</code> <p>Keyword arguments to pass to get_grad_mask_2d.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>new_mapset</code> <code>Mapset</code> <p>A mapset with the original map and a cleared prior map.</p> Source code in <code>witch/mapmaking.py</code> <pre><code>def get_grad_prior(\n    todvec: minkasi.tods.TodVec,\n    mapset: minkasi.maps.Mapset,\n    gradmap: minkasi.maps.MapType,\n    *args: Unpack[tuple],\n    **kwargs,\n) -&gt; minkasi.maps.Mapset:\n    \"\"\"\n    Make a gradient based prior from a map.\n    This helps avoid errors due to sharp features.\n\n    Parameters\n    ----------\n    todvec : minkasi.tods.TodVec\n        The TODs what we are mapmaking.\n    mapset : minkasi.maps.Mapset\n        The mapset to compute priors with.\n        We assume that the first element is the map we care about.\n    gradmap : minkasi.maps.MapType\n        Containter to use as the gradient map.\n    *args : Unpack[tuple]\n        Additional arguments to pass to get_grad_mask_2d.\n    **kwargs\n        Keyword arguments to pass to get_grad_mask_2d.\n\n    Returns\n    -------\n    new_mapset : minkasi.maps.Mapset\n        A mapset with the original map and a cleared prior map.\n    \"\"\"\n    gradmap.map[:] = minkasi.mapmaking.noise.get_grad_mask_2d(\n        mapset.maps[0], todvec, *args, **kwargs\n    )\n    prior = minkasi.mapmaking.timestream.tsModel(todvec, minkasi.tods.cuts.CutsCompact)\n    for tod in todvec.tods:\n        prior.data[tod.info[\"fname\"]] = tod.prior_from_skymap(gradmap)\n        print(\n            \"prior on tod \"\n            + tod.info[\"fname\"]\n            + \" length is \"\n            + repr(prior.data[tod.info[\"fname\"]].map.size)\n        )\n\n    new_mapset = minkasi.maps.Mapset()\n    new_mapset.add_map(mapset.maps[0])\n    pp = prior.copy()\n    pp.clear()\n    new_mapset.add_map(pp)\n\n    return new_mapset\n</code></pre>"},{"location":"reference/mapmaking/#witch.mapmaking.make_maps","title":"<code>make_maps(todvec, skymap, noise_class, noise_args, noise_kwargs, outdir, npass, dograd)</code>","text":"<p>Make a minkasi map with multple passes and noise reestimation. Unless you are an expert this will usually be all you need.</p> <p>Parameters:</p> Name Type Description Default <code>todvec</code> <code>TodVec</code> <p>The tods to mapmake.</p> required <code>skymap</code> <code>MapType</code> <p>Map to use as a template. The contents don't matter only the shape and WCS info.</p> required <code>noise_class</code> <code>NoiseModelType</code> <p>The noise model to use on the TODs.</p> required <code>noise_args</code> <code>tuple</code> <p>Arguments to pass to <code>minkasi.tods.Tod.set_noise</code>.</p> required <code>noise_kwargs</code> <code>dict</code> <p>Keyword arguments to pass to <code>minkasi.tods.Tod.set_noise</code>.</p> required <code>outdir</code> <code>str</code> <p>The output directory.</p> required <code>npass</code> <code>int</code> <p>The number of times to mapmake and then reestimate the noise.</p> required <code>dograd</code> <code>bool</code> <p>If True make a map based prior to avoid biases from sharp features.</p> required Source code in <code>witch/mapmaking.py</code> <pre><code>def make_maps(\n    todvec: minkasi.tods.TodVec,\n    skymap: minkasi.maps.MapType,\n    noise_class: minkasi.mapmaking.noise.NoiseModelType,\n    noise_args: tuple,\n    noise_kwargs: dict,\n    outdir: str,\n    npass: int,\n    dograd: bool,\n):\n    \"\"\"\n    Make a minkasi map with multple passes and noise reestimation.\n    Unless you are an expert this will usually be all you need.\n\n    Parameters\n    ----------\n    todvec : minkasi.tods.TodVec\n        The tods to mapmake.\n    skymap : minkasi.maps.MapType\n        Map to use as a template.\n        The contents don't matter only the shape and WCS info.\n    noise_class : minkasi.mapmaking.noise.NoiseModelType\n        The noise model to use on the TODs.\n    noise_args : tuple\n        Arguments to pass to `minkasi.tods.Tod.set_noise`.\n    noise_kwargs : dict\n        Keyword arguments to pass to `minkasi.tods.Tod.set_noise`.\n    outdir : str\n        The output directory.\n    npass : int\n        The number of times to mapmake and then reestimate the noise.\n    dograd : bool\n        If True make a map based prior to avoid biases from sharp features.\n    \"\"\"\n    naive, hits = make_naive(todvec, skymap, outdir)\n\n    # Take 1 over hits map\n    ihits = hits.copy()\n    ihits.invert()\n\n    # Save weights and noise maps\n    _ = make_weights(todvec, skymap, outdir)\n\n    # Setup the mapset\n    # For now just include the naive map so we can use it as the initial guess.\n    mapset = minkasi.maps.Mapset()\n    mapset.add_map(naive)\n\n    # run PCG to solve for a first guess\n    iters = [5, 25, 100]\n    mapset = solve_map(todvec, mapset, ihits, None, 26, iters, outdir, \"initial\")\n\n    # Now we iteratively solve and reestimate the noise\n    for niter in range(npass):\n        maxiter = 26 + 25 * (niter + 1)\n        reestimate_noise_from_map(todvec, mapset, noise_class, noise_args, noise_kwargs)\n\n        # Make a gradient based prior\n        if dograd:\n            mapset = get_grad_prior(todvec, mapset, hits.copy(), thresh=1.8)\n        # Solve\n        mapset = solve_map(\n            todvec, mapset, ihits, None, maxiter, iters, outdir, f\"niter_{niter+1}\"\n        )\n\n    minkasi.barrier()\n</code></pre>"},{"location":"reference/mapmaking/#witch.mapmaking.make_naive","title":"<code>make_naive(todvec, skymap, outdir)</code>","text":"<p>Make a naive map where we just bin common mode subtracted TODs.</p> <p>Parameters:</p> Name Type Description Default <code>todvec</code> <code>TodVec</code> <p>The TODs to mapmake.</p> required <code>skymap</code> <code>MapType</code> <p>Map to use as footprint for outputs.</p> required <p>Returns:</p> Name Type Description <code>naive</code> <code>MapType</code> <p>The naive map.</p> <code>hits</code> <code>MapType</code> <p>The hit count map. We use this as a preconditioner which helps small-scale convergence quite a bit.</p> Source code in <code>witch/mapmaking.py</code> <pre><code>def make_naive(\n    todvec: minkasi.tods.TodVec, skymap: minkasi.maps.MapType, outdir: str\n) -&gt; tuple[minkasi.maps.MapType, minkasi.maps.MapType]:\n    \"\"\"\n    Make a naive map where we just bin common mode subtracted TODs.\n\n    Parameters\n    ----------\n    todvec : minkasi.tods.TodVec\n        The TODs to mapmake.\n    skymap : minkasi.maps.MapType\n        Map to use as footprint for outputs.\n\n    Returns\n    -------\n    naive : minkasi.maps.MapType\n        The naive map.\n    hits : minkasi.maps.MapType\n        The hit count map.\n        We use this as a preconditioner which helps small-scale convergence quite a bit.\n    \"\"\"\n    hits = minkasi.mapmaking.make_hits(todvec, skymap)\n\n    # Make a naive map where we just bin the CM subbed tods\n    naive = skymap.copy()\n    naive.clear()\n    for tod in todvec.tods:\n        tmp = tod.info[\"dat_calib\"].copy()\n        u, s, v = np.linalg.svd(tmp, False)\n        tmp -= np.outer(u[:, 0], s[0] * v[0, :])\n        naive.tod2map(tod, tmp)\n    naive.mpi_reduce()\n    naive.map[hits.map &gt; 0] = naive.map[hits.map &gt; 0] / hits.map[hits.map &gt; 0]\n    if minkasi.myrank == 0:\n        naive.write(os.path.join(outdir, \"naive.fits\"))\n        hits.write(os.path.join(outdir, \"hits.fits\"))\n    naive.clear()\n    return naive, hits\n</code></pre>"},{"location":"reference/mapmaking/#witch.mapmaking.make_weights","title":"<code>make_weights(todvec, skymap, outdir)</code>","text":"<p>Make weights and noise map.</p> <p>Parameters:</p> Name Type Description Default <code>todvec</code> <code>TodVec</code> <p>The TODs to mapmake.</p> required <code>skymap</code> <code>MapType</code> <p>Map to use as footprint for outputs.</p> required <p>Returns:</p> Name Type Description <code>weightmap</code> <code>MapType</code> <p>The weights map.</p> <code>noisemap</code> <code>MapType</code> <p>The noise map. This is just 1/sqrt(weights).</p> Source code in <code>witch/mapmaking.py</code> <pre><code>def make_weights(\n    todvec: minkasi.tods.TodVec, skymap: minkasi.maps.MapType, outdir: str\n) -&gt; tuple[minkasi.maps.MapType, minkasi.maps.MapType]:\n    \"\"\"\n    Make weights and noise map.\n\n    Parameters\n    ----------\n    todvec : minkasi.tods.TodVec\n        The TODs to mapmake.\n    skymap : minkasi.maps.MapType\n        Map to use as footprint for outputs.\n\n    Returns\n    -------\n    weightmap : minkasi.maps.MapType\n        The weights map.\n    noisemap : minkasi.maps.MapType\n        The noise map.\n        This is just 1/sqrt(weights).\n    \"\"\"\n    weightmap = minkasi.mapmaking.make_hits(todvec, skymap, do_weights=True)\n    mask = weightmap.map &gt; 0\n    tmp = weightmap.map.copy()\n    tmp[mask] = 1.0 / np.sqrt(tmp[mask])\n    noisemap = weightmap.copy()\n    noisemap.map[:] = tmp\n    if minkasi.myrank == 0:\n        noisemap.write(os.path.join(outdir, \"noise.fits\"))\n        weightmap.write(os.path.join(outdir, \"weights.fits\"))\n\n    return weightmap, noisemap\n</code></pre>"},{"location":"reference/mapmaking/#witch.mapmaking.reestimate_noise_from_map","title":"<code>reestimate_noise_from_map(todvec, mapset, noise_class, noise_args, noise_kwargs)</code>","text":"<p>Use the current guess at the map to reestimate the noise:</p> <p>Parameters:</p> Name Type Description Default <code>todvec</code> <code>TodVec</code> <p>The TODs to reestimate noise for.</p> required <code>mapset</code> <code>Mapset</code> <p>Mapset containing the current map solution.</p> required <code>noise_class</code> <code>NoiseModelType</code> <p>Which noise model to use.</p> required <code>noise_args</code> <code>tuple</code> <p>Additional arguments to pass to <code>minkasi.tods.Tod.set_noise</code>.</p> required <code>noise_kwargs</code> <code>dict</code> <p>Additional keyword arguments to pass to <code>minkasi.tods.Tod.set_noise</code>.</p> required Source code in <code>witch/mapmaking.py</code> <pre><code>def reestimate_noise_from_map(\n    todvec: minkasi.tods.TodVec,\n    mapset: minkasi.maps.Mapset,\n    noise_class: minkasi.mapmaking.NoiseModelType,\n    noise_args: tuple,\n    noise_kwargs: dict,\n):\n    \"\"\"\n    Use the current guess at the map to reestimate the noise:\n\n    Parameters\n    ----------\n    todvec : minkasi.tods.TodVec\n        The TODs to reestimate noise for.\n    mapset : minkasi.maps.Mapset\n        Mapset containing the current map solution.\n    noise_class : minkasi.mapmaking.NoiseModelType\n        Which noise model to use.\n    noise_args : tuple\n        Additional arguments to pass to `minkasi.tods.Tod.set_noise`.\n    noise_kwargs : dict\n        Additional keyword arguments to pass to `minkasi.tods.Tod.set_noise`.\n    \"\"\"\n    for tod in todvec.tods:\n        mat = 0 * tod.info[\"dat_calib\"]\n        for mm in mapset.maps:\n            mm.map2tod(tod, mat)\n        tod.set_noise(\n            noise_class,\n            dat=tod.info[\"dat_calib\"] - mat,\n            *noise_args,\n            **noise_kwargs,\n        )\n</code></pre>"},{"location":"reference/mapmaking/#witch.mapmaking.solve_map","title":"<code>solve_map(todvec, x0, ihits, prior, maxiters, save_iters, outdir, desc_str)</code>","text":"<p>Solve for map with PCG.</p> <p>Parameters:</p> Name Type Description Default <code>todvec</code> <code>TodVec</code> <p>The TODs what we are mapmaking.</p> required <code>x0</code> <code>Mapset</code> <p>The initial guess mapset.</p> required <code>ihits</code> <code>MapType</code> <p>The inverse hits map.</p> required <code>prior</code> <code>Optional[HasPrior]</code> <p>Prior to use when mapmaking, set to None to not use.</p> required <code>maxiters</code> <code>int</code> <p>Maximum PCG iters to use.</p> required <code>save_iters</code> <code>list[int]</code> <p>Which iterations to save the map at.</p> required <code>outdir</code> <code>str</code> <p>The output directory</p> required <code>desc_str</code> <code>str</code> <p>String used to determine outroot.</p> required <p>Returns:</p> Name Type Description <code>mapset</code> <code>Mapset</code> <p>The mapset with the solved map.</p> Source code in <code>witch/mapmaking.py</code> <pre><code>def solve_map(\n    todvec: minkasi.tods.TodVec,\n    x0: minkasi.maps.Mapset,\n    ihits: minkasi.maps.MapType,\n    prior: Optional[minkasi.mapmaking.pcg.HasPrior],\n    maxiters: int,\n    save_iters: list[int],\n    outdir: str,\n    desc_str: str,\n) -&gt; minkasi.maps.Mapset:\n    \"\"\"\n    Solve for map with PCG.\n\n    Parameters\n    ----------\n    todvec : minkasi.tods.TodVec\n        The TODs what we are mapmaking.\n    x0 : minkasi.maps.Mapset\n        The initial guess mapset.\n    ihits : minkasi.maps.MapType\n        The inverse hits map.\n    prior : Optional[minkasi.mapmaking.pgc.HasPrior]\n        Prior to use when mapmaking, set to None to not use.\n    maxiters : int\n        Maximum PCG iters to use.\n    save_iters : list[int]\n        Which iterations to save the map at.\n    outdir : str\n        The output directory\n    desc_str : str\n        String used to determine outroot.\n\n    Returns\n    -------\n    mapset : minkasi.maps.Mapset\n        The mapset with the solved map.\n    \"\"\"\n    # make A^T N^1 d.  TODs need to understand what to do with maps\n    # but maps don't necessarily need to understand what to do with TODs,\n    # hence putting make_rhs in the vector of TODs.\n    # Again, make_rhs is MPI-aware, so this should do the right thing\n    # if you run with many processes.\n    rhs = x0.copy()\n    todvec.make_rhs(rhs)\n\n    # Preconditioner is 1/ hit count map.\n    # Helps a lot for convergence.\n    precon = x0.copy()\n    precon.maps[0].map[:] = ihits.map[:]\n\n    # run PCG to solve\n    # Supressing print here, probably want a verbosity setting on the minkasi side...\n    with open(os.devnull, \"w\") as f, contextlib.redirect_stdout(f):\n        mapset = minkasi.mapmaking.run_pcg_wprior(\n            rhs,\n            x0,\n            todvec,\n            prior,\n            precon,\n            maxiter=maxiters,\n            outroot=os.path.join(outdir, desc_str),\n            save_iters=save_iters,\n        )\n\n    if minkasi.myrank == 0:\n        mapset.maps[0].write(\n            os.path.join(outdir, f\"{desc_str}.fits\")\n        )  # and write out the map as a FITS file\n\n    return mapset\n</code></pre>"},{"location":"reference/plotting/","title":"plotting","text":""},{"location":"reference/plotting/#witch.plotting.plot_cluster","title":"<code>plot_cluster(name, fits_path, root=None, pix_size=None, ra=None, dec=None, units='mJy', bound=None, radius=2.0, plot_r=True, figsize=(5, 5), ncontours=0, hdu=0, downsample=1, smooth=9.0, convention='calabretta')</code>","text":"<p>Function for doing core plotting. TODO: This function could probably use an args/kwargs, but there are an enourmous number of keyword args within so that might be difficult.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>name of the cluster</p> required <code>fits_path</code> <code>str</code> <p>Path to the fits file to be plotted.</p> required <code>root</code> <code>None | str</code> <p>Path to the output root. If none, then it will assume WITCH output formating.</p> <code>None</code> <code>pix_size</code> <code>None | float</code> <p>Pixel size. If None, then will be computed from results file.</p> <code>None</code> <code>ra</code> <code>None | float</code> <p>RA of center of plot, in degrees. If none, will be taken from config</p> <code>None</code> <code>dec</code> <code>None | float, dfault: None</code> <p>Dec of center of plot, in degrees. If none, will be taken from config</p> <code>None</code> <code>units</code> <code>str</code> <p>String to be used as units. If snr, then it will autoformat to sigma</p> <code>mJy</code> <code>bound</code> <code>None | float</code> <p>Bounds for the colormap. If none, reasonable bounds will be computed.</p> <code>None</code> <code>radius</code> <code>float</code> <p>Radius, in arcmin, of figure</p> <code>2.0</code> <code>plot_r</code> <code>bool | str</code> <p>If true, plot r500. If a str, plot a related critical radius</p> <code>True</code> <code>figsize</code> <code>tuple[float, float]</code> <p>Width and height of plot in inches.</p> <code>(5,5)</code> <code>ncontours</code> <code>int</code> <p>Number of countours to be plotted</p> <code>= 0</code> <code>hdu</code> <code>int</code> <p>Fits hdu corresponding to the image to be plotted</p> <code>0</code> <code>downsample</code> <code>int</code> <p>Factor by which to downsample the image.</p> <code>1</code> <code>smooth</code> <code>float</code> <p>Scale, in arcminutes, at which to smooth the image.</p> <code>9.0</code> <code>convention</code> <code>str</code> <p>Determines interpretation of abigious fits headers. See aplpy.FITSFigure documentation</p> <code>calabretta</code> <p>Returns:</p> Name Type Description <code>img</code> <code>FITSFigure</code> <p>FITSFigure plot of the cluster</p> Source code in <code>witch/plotting.py</code> <pre><code>def plot_cluster(\n    name: str,\n    fits_path: str,\n    root: Optional[str] = None,\n    pix_size: Optional[float] = None,\n    ra: Optional[float] = None,\n    dec: Optional[float] = None,\n    units: str = \"mJy\",\n    bound: Optional[float] = None,\n    radius: float = 2.0,\n    plot_r: bool | str = True,\n    figsize: tuple[float, float] = (5, 5),\n    ncontours: int = 0,\n    hdu: int = 0,\n    downsample: int = 1,\n    smooth: float = 9.0,\n    convention: str = \"calabretta\",\n):\n    \"\"\"\n    Function for doing core plotting.\n    TODO: This function could probably use an args/kwargs, but there are an enourmous number of keyword args within so that might be difficult.\n\n    Parameters\n    ----------\n    name : str\n        name of the cluster\n    fits_path : str\n        Path to the fits file to be plotted.\n    root : None | str, default: None\n        Path to the output root. If none, then it will assume WITCH output formating.\n    pix_size : None | float, default: None\n        Pixel size. If None, then will be computed from results file.\n    ra : None | float, default: None\n        RA of center of plot, in degrees. If none, will be taken from config\n    dec : None | float, dfault: None\n        Dec of center of plot, in degrees. If none, will be taken from config\n    units : str, default: mJy\n        String to be used as units. If snr, then it will autoformat to sigma\n    bound : None | float, default: None\n        Bounds for the colormap. If none, reasonable bounds will be computed.\n    radius : float, default: 2.0\n        Radius, in arcmin, of figure\n    plot_r : bool | str, default: True\n        If true, plot r500. If a str, plot a related critical radius\n    figsize : tuple[float, float], default: (5,5)\n        Width and height of plot in inches.\n    ncontours : int, default = 0\n        Number of countours to be plotted\n    hdu : int, default: 0\n        Fits hdu corresponding to the image to be plotted\n    downsample : int, default: 1\n        Factor by which to downsample the image.\n    smooth : float, default: 9.0\n        Scale, in arcminutes, at which to smooth the image.\n    convention : str, default: calabretta\n        Determines interpretation of abigious fits headers. See aplpy.FITSFigure documentation\n\n    Returns\n    -------\n    img: aplpy.FITSFigure\n        FITSFigure plot of the cluster\n    \"\"\"\n    fits_path = os.path.abspath(fits_path)\n    if root is None:\n        root = os.path.split(os.path.split(fits_path)[0])[0]\n\n    if pix_size is None:\n        res_path = (\n            root\n            + \"/\"\n            + str(sorted([file for file in os.listdir(root) if \".dill\" in file])[-1])\n        )\n        with open(res_path, \"rb\") as f:\n            results = pk.load(f)\n        pix_size = results.pix_size * rad_to_arcsec\n\n    if ra is None or dec is None:\n        cfg_path = root + \"/\" + \"config.yaml\"\n        cfg = load_config({}, cfg_path)\n        ra = eval(cfg[\"coords\"][\"x0\"])\n        dec = eval(cfg[\"coords\"][\"y0\"])\n        ra, dec = np.rad2deg(\n            [ra, dec]\n        )  # TODO: Currently center on config center, which is fine but should probably be fit center\n\n    smooth = max(\n        1, int(smooth / pix_size)\n    )  # FITSfigure smoothing is in pixels, so convert arcsec to pixels\n\n    kernel = Gaussian2DKernel(x_stddev=smooth * 5)\n\n    fig = plt.figure(figsize=figsize)\n    img = aplpy.FITSFigure(\n        fits_path,\n        hdu=hdu,\n        figure=fig,\n        downsample=downsample,\n        smooth=False,\n        convention=convention,\n    )  # Smooth here does something whack\n    img.set_theme(\"publication\")\n\n    if units is not None:\n        if units == \"snr\":\n            cbar_label = r\"$\\sigma$\"\n        elif units == \"uK_cmb\":\n            img._data /= 1.28\n            img._data *= 1e6\n            cbar_label = r\"$uK_{CMB}$\"\n        elif units == \"uK_RJ\":\n            img._data *= 1e6\n            cbar_label = r\"$uK_{RJ}\"\n        else:\n            cbar_label = str(units)\n\n    ## make and register a divergent blue-orange colormap:\n    cmap = \"mymap\"\n    try:\n        matplotlib.colormaps.get_cmap(\n            cmap\n        )  # Stops these anoying messages if you've already registered mymap\n\n    except:\n        mymap = matplotlib.colors.LinearSegmentedColormap.from_list(\n            cmap, [\"Blue\", \"White\", \"Red\"]\n        )\n        matplotlib.colormaps.register(cmap=mymap)\n\n    if bound is None:\n        nx, ny = img._data.shape\n        lims = int(radius * 60 / pix_size)\n        xmin = int(nx / 2 - lims)\n        xmax = int(nx / 2 + lims)\n        ymin = int(ny / 2 - lims)\n        ymax = int(ny / 2 + lims)\n        bound = np.amax(np.abs(img._data[xmin:xmax, ymin:ymax]))\n        order = int(np.floor(np.log10(bound)))\n        bound = np.round(bound, -1 * order) / 2\n\n    img.show_colorscale(cmap=cmap, stretch=\"linear\", vmin=-bound, vmax=bound, smooth=3)\n    img.recenter(ra, dec, radius=radius / 60.0)\n    img.ax.tick_params(axis=\"both\", which=\"both\", direction=\"in\")\n\n    matplotlib.rcParams[\"lines.linewidth\"] = 3.0\n    img.add_scalebar(\n        0.5 / 60.0, '30\"', color=\"black\"\n    )  # Adds a 30 arcsec scalebar to the image\n\n    matplotlib.rcParams[\"lines.linewidth\"] = 2.0\n\n    img.add_beam(\n        major=9.0 / 3600.0, minor=9.0 / 3600.0, angle=0\n    )  # TODO: For now hard-coded to M2 beam but may want some flexibility later\n    img.beam.set_color(\"white\")\n    img.beam.set_edgecolor(\"green\")\n    img.beam.set_facecolor(\"white\")\n    img.beam.set_corner(\"bottom left\")\n\n    img.show_markers(\n        ra,\n        dec,\n        facecolor=\"black\",\n        edgecolor=None,\n        marker=\"+\",\n        s=50,\n        linewidths=2,\n        alpha=0.5,\n    )\n    if units is not None:\n        img.add_colorbar(\"right\")\n        img.colorbar.set_width(0.12)\n        img.colorbar.set_axis_label_text(cbar_label)\n\n    if ncontours:\n        matplotlib.rcParams[\"lines.linewidth\"] = 0.5\n        clevels = np.linspace(-bound, bound, ncontours)\n        img.show_contour(\n            fits_path,\n            colors=\"gray\",\n            levels=clevels,\n            returnlevels=True,\n            convention=\"calabretta\",\n            smooth=3,\n        )\n\n    if plot_r:  # TODO: Allow passing of r500 values, make this a subfunction\n        if \"a10\" in cfg[\"model\"][\"structures\"].keys():\n            mod_type = \"a10\"\n        elif \"ea10\" in cfg[\"model\"][\"structures\"].keys():\n            mod_type = \"ea10\"\n        else:\n            raise ModelError(\"For R500, must have structure type A10 or EA10\")\n\n        for i in range(len(results.structures)):\n            if str(results.structures[i].name) == mod_type:\n                break\n\n        for parameter in results.structures[i].parameters:\n            if str(parameter.name.lower()) == \"m500\":\n                m500 = parameter.val\n                break\n\n        z = float(cfg[\"constants\"][\"z\"])\n        nz = get_nz(z)\n\n        r500 = (m500 / (4.00 * np.pi / 3.00) / 5.00e02 / nz) ** (1.00 / 3.00)\n        da = get_da(z)\n        r500 /= da\n        if plot_r == \"rs\":\n            r500 /= float(\n                cfg[\"model\"][\"structures\"][mod_type][\"parameters\"][\"c500\"][\"value\"]\n            )  # Convert to rs\n        img.show_circles(\n            ra, dec, radius=r500 / 3600, coords_frame=\"world\", color=\"green\"\n        )\n\n    return img\n</code></pre>"},{"location":"reference/plotting/#witch.plotting.plot_cluster_act","title":"<code>plot_cluster_act(name, fits_path, cfg_path=None, ra=None, dec=None, units='mJy', bound=None, radius=2.0, plot_r=True, figsize=(5, 5), ncontours=0, hdu=0, downsample=1, smooth=60.0, convention='calabretta')</code>","text":"<p>Function for doing core plotting. TODO: This function could probably use an args/kwargs, but there are an enourmous number of keyword args within so that might be difficult.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of the cluster</p> required <code>fits_path</code> <code>str</code> <p>Path to the fits file to be plotted.</p> required <code>cfg_path</code> <code>None | str</code> <p>Path to WITCH config file corresponding to same cluster</p> <code>None</code> <code>ra</code> <code>None | float</code> <p>RA of center of plot, in degrees. If none, will be taken from config</p> <code>None</code> <code>dec</code> <code>None | float, dfault: None</code> <p>Dec of center of plot, in degrees. If none, will be taken from config</p> <code>None</code> <code>units</code> <code>str</code> <p>String to be used as units. If snr, then it will autoformat to sigma</p> <code>mJy</code> <code>bound</code> <code>None | float</code> <p>Bounds for the colormap. If none, reasonable bounds will be computed.</p> <code>None</code> <code>radius</code> <code>float</code> <p>Radius, in arcmin, of figure</p> <code>2.0</code> <code>plot_r</code> <code>bool | str</code> <p>If true, plot r500. If a str, plot a related critical radius</p> <code>True</code> <code>figsize</code> <code>tuple[float, float]</code> <p>Width and height of plot in inches.</p> <code>(5,5)</code> <code>ncontours</code> <code>int</code> <p>Number of countours to be plotted</p> <code>= 0</code> <code>hdu</code> <code>int</code> <p>Fits hdu corresponding to the image to be plotted</p> <code>0</code> <code>downsample</code> <code>int</code> <p>Factor by which to downsample the image.</p> <code>1</code> <code>smooth</code> <code>float</code> <p>Scale, in arcminutes, at which to smooth the image.</p> <code>60.0</code> <code>convention</code> <code>str</code> <p>Determines interpretation of abigious fits headers. See aplpy.FITSFigure documentation</p> <code>calabretta</code> <p>Returns:</p> Name Type Description <code>img</code> <code>FITSFigure</code> <p>FITSFigure plot of the cluster</p> Source code in <code>witch/plotting.py</code> <pre><code>def plot_cluster_act(\n    name: str,\n    fits_path: str,\n    cfg_path: Optional[str] = None,\n    ra: Optional[float] = None,\n    dec: Optional[float] = None,\n    units: str = \"mJy\",\n    bound: Optional[float] = None,\n    radius: float = 2.0,\n    plot_r: bool | str = True,\n    figsize: tuple[float, float] = (5, 5),\n    ncontours: int = 0,\n    hdu: int = 0,\n    downsample: int = 1,\n    smooth: float = 60.0,\n    convention: str = \"calabretta\",\n):\n    \"\"\"\n    Function for doing core plotting.\n    TODO: This function could probably use an args/kwargs, but there are an enourmous number of keyword args within so that might be difficult.\n\n    Parameters\n    ----------\n    name : str\n        Name of the cluster\n    fits_path : str\n        Path to the fits file to be plotted.\n    cfg_path : None | str, default: None\n        Path to WITCH config file corresponding to same cluster\n    ra : None | float, default: None\n        RA of center of plot, in degrees. If none, will be taken from config\n    dec : None | float, dfault: None\n        Dec of center of plot, in degrees. If none, will be taken from config\n    units : str, default: mJy\n        String to be used as units. If snr, then it will autoformat to sigma\n    bound : None | float, default: None\n        Bounds for the colormap. If none, reasonable bounds will be computed.\n    radius : float, default: 2.0\n        Radius, in arcmin, of figure\n    plot_r : bool | str, default: True\n        If true, plot r500. If a str, plot a related critical radius\n    figsize : tuple[float, float], default: (5,5)\n        Width and height of plot in inches.\n    ncontours : int, default = 0\n        Number of countours to be plotted\n    hdu : int, default: 0\n        Fits hdu corresponding to the image to be plotted\n    downsample : int, default: 1\n        Factor by which to downsample the image.\n    smooth : float, default: 60.0\n        Scale, in arcminutes, at which to smooth the image.\n    convention : str, default: calabretta\n        Determines interpretation of abigious fits headers. See aplpy.FITSFigure documentation\n\n    Returns\n    -------\n    img: aplpy.FITSFigure\n        FITSFigure plot of the cluster\n    \"\"\"\n    if cfg_path is not None:\n        cfg = load_config({}, cfg_path)\n        ra = eval(cfg[\"coords\"][\"x0\"])\n        dec = eval(cfg[\"coords\"][\"y0\"])\n        ra, dec = np.rad2deg(\n            [ra, dec]\n        )  # TODO: Currently center on config center, which is fine but should probably be fit center\n    elif ra is None or dec is None:\n        raise ValueError(\"Either cfg_path or both ra and dec must be specified.\")\n    cur_hdu = fits.open(fits_path)\n    pix_size = cur_hdu[0].header[\"CDELT1\"] * 3600\n\n    smooth = max(\n        1, int(smooth / pix_size)\n    )  # FITSfigure smoothing is in pixels, so convert arcsec to pixels\n\n    kernel = Gaussian2DKernel(x_stddev=smooth * 5)\n\n    fig = plt.figure(figsize=figsize)\n    img = aplpy.FITSFigure(\n        fits_path,\n        hdu=hdu,\n        figure=fig,\n        downsample=downsample,\n        smooth=False,\n        convention=convention,\n    )  # Smooth here does something whack\n    img.set_theme(\"publication\")\n\n    beam_fwhm = 2.2\n    fwhm_to_sigma = 1.0 / (8 * np.log(2)) ** 0.5\n    beam_sigma = beam_fwhm * fwhm_to_sigma\n    omega_B = 2 * np.pi * beam_sigma**2\n\n    if units == \"snr\":\n        cbar_label = r\"$\\sigma$\"\n    elif units == \"uK\":\n        img._data *= np.sqrt(omega_B)\n        cbar_label = r\"$uK_{CMB}$\"\n    else:\n        cbar_label = str(units)\n\n    cmap = \"mymap\"\n    try:\n        cm.get_cmap(\n            cmap\n        )  # Stops these anoying messages if you've already registered mymap\n\n    except:\n        bottom = cm.get_cmap(\"Oranges\", 128)\n        top = cm.get_cmap(\"Blues_r\", 128)\n        newcolors = np.vstack(\n            (top(np.linspace(0, 1, 128)), bottom(np.linspace(0, 1, 128)))\n        )\n        cm.register_cmap(cmap, cmap=ListedColormap(newcolors))\n\n    if bound is None:\n        nx, ny = img._data.shape\n        lims = int(radius * 60 / pix_size)\n        xmin = int(nx / 2 - lims)\n        xmax = int(nx / 2 + lims)\n        ymin = int(ny / 2 - lims)\n        ymax = int(ny / 2 + lims)\n        bound = np.amax(np.abs(img._data[xmin:xmax, ymin:ymax]))\n        order = int(np.floor(np.log10(bound)))\n        bound = np.round(bound, -1 * order) / 2\n\n    img.show_colorscale(cmap=cmap, stretch=\"linear\", vmin=-bound, vmax=bound, smooth=1)\n\n    img.recenter(ra, dec, radius=radius / 60.0)\n    img.ax.tick_params(axis=\"both\", which=\"both\", direction=\"in\")\n\n    matplotlib.rcParams[\"lines.linewidth\"] = 3.0\n    img.add_scalebar(\n        0.5 / 60.0, '30\"', color=\"black\"\n    )  # Adds a 30 arcsec scalebar to the image\n\n    matplotlib.rcParams[\"lines.linewidth\"] = 2.0\n\n    img.add_beam(\n        major=120.0 / 3600.0, minor=120.0 / 3600.0, angle=0\n    )  # TODO: For now hard-coded to M2 beam but may want some flexibility later\n    img.beam.set_color(\"white\")\n    img.beam.set_edgecolor(\"green\")\n    img.beam.set_facecolor(\"white\")\n    img.beam.set_corner(\"bottom left\")\n\n    img.show_markers(\n        ra,\n        dec,\n        facecolor=\"black\",\n        edgecolor=None,\n        marker=\"+\",\n        s=50,\n        linewidths=2,\n        alpha=0.5,\n    )\n\n    img.add_colorbar(\"right\")\n    img.colorbar.set_width(0.12)\n    img.colorbar.set_axis_label_text(cbar_label)\n\n    if ncontours:\n        matplotlib.rcParams[\"lines.linewidth\"] = 0.5\n        clevels = np.linspace(-bound, bound, ncontours)\n        img.show_contour(\n            fits_path,\n            colors=\"gray\",\n            levels=clevels,\n            returnlevels=True,\n            convention=\"calabretta\",\n            smooth=3,\n        )\n\n    if plot_r:  # TODO: Allow passing of r500 values, make this a subfunction\n        if \"a10\" in cfg[\"model\"][\"structures\"].keys():\n            mod_type = \"a10\"\n        elif \"ea10\" in cfg[\"model\"][\"structures\"].keys():\n            mod_type = \"ea10\"\n        else:\n            raise ModelError(\"For R500, must have structure type A10 or EA10\")\n\n        for i in range(len(results.structures)):\n            if str(results.structures[i].name) == mod_type:\n                break\n\n        for parameter in results.structures[i].parameters:\n            if str(parameter.name.lower()) == \"m500\":\n                m500 = parameter.val\n                break\n\n        z = float(cfg[\"constants\"][\"z\"])\n        nz = get_nz(z)\n\n        r500 = (m500 / (4.00 * np.pi / 3.00) / 5.00e02 / nz) ** (1.00 / 3.00)\n        da = get_da(z)\n        r500 /= da\n        if plot_r == \"rs\":\n            r500 /= float(\n                cfg[\"model\"][\"structures\"][mod_type][\"parameters\"][\"c500\"][\"value\"]\n            )  # Convert to rs\n        img.show_circles(\n            ra, dec, radius=r500 / 3600, coords_frame=\"world\", color=\"green\"\n        )\n\n    return img\n</code></pre>"},{"location":"reference/structure/","title":"structure","text":"<p>Functions for generating structure. This includes both cluster profiles and substructure.</p>"},{"location":"reference/structure/#witch.structure.a10","title":"<code>a10(dx, dy, dz, theta, P0, c500, m500, gamma, alpha, beta, z, xyz)</code>","text":"<p>gNFW pressure profile in 3d based on Arnaud2010. Compared to the function gnfw, this function fixes r1/r2/r3 to r500. This function does not include smoothing or declination stretch which should be applied at the end.</p> <p>See the docstring for <code>gnfw</code> for more details.</p> <p>Parameters:</p> Name Type Description Default <code>dx</code> <code>float</code> <p>RA of cluster center relative to grid origin. Passed to <code>utils.transform_grid</code>.</p> required <code>dy</code> <code>float</code> <p>Dec of cluster center relative to grid origin. Passed to <code>utils.transform_grid</code>.</p> required <code>dz</code> <code>float</code> <p>Line of sight offset of cluster center relative to grid origin. Passed to <code>utils.transform_grid</code>.</p> required <code>theta</code> <code>float</code> <p>Angle to rotate in xy-plane. Passed to <code>utils.transform_grid</code>.</p> required <code>P0</code> <code>float</code> <p>Amplitude of the pressure profile</p> required <code>c500</code> <code>float</code> <p>Concentration parameter at a density contrast of 500</p> required <code>m500</code> <code>float</code> <p>Mass at a density contrast of 500</p> required <code>gamma</code> <code>float</code> <p>The central slope</p> required <code>alpha</code> <code>float</code> <p>The intermediate slope</p> required <code>beta</code> <code>float</code> <p>The outer slope</p> required <code>z</code> <code>float</code> <p>Redshift of cluster</p> required <code>xyz</code> <code>tuple[Array, Array, Array, float, float]</code> <p>Coordinte grid to calculate model on. See <code>containers.Model.xyz</code> for details.</p> required <p>Returns:</p> Name Type Description <code>model</code> <code>Array</code> <p>The gnfw model evaluated on the grid.</p> Source code in <code>witch/structure.py</code> <pre><code>@jax.jit\ndef a10(\n    dx: float,\n    dy: float,\n    dz: float,\n    theta: float,\n    P0: float,\n    c500: float,\n    m500: float,\n    gamma: float,\n    alpha: float,\n    beta: float,\n    z: float,\n    xyz: tuple[jax.Array, jax.Array, jax.Array, float, float],\n) -&gt; jax.Array:\n    r\"\"\"\n    gNFW pressure profile in 3d based on [Arnaud2010](https://ui.adsabs.harvard.edu/abs/2010A%26A...517A..92A/).\n    Compared to the function gnfw, this function fixes r1/r2/r3 to r500.\n    This function does not include smoothing or declination stretch\n    which should be applied at the end.\n\n    See the docstring for `gnfw` for more details.\n\n    Parameters\n    ----------\n    dx : float\n        RA of cluster center relative to grid origin.\n        Passed to `utils.transform_grid`.\n    dy : float\n        Dec of cluster center relative to grid origin.\n        Passed to `utils.transform_grid`.\n    dz : float\n        Line of sight offset of cluster center relative to grid origin.\n        Passed to `utils.transform_grid`.\n    theta : float\n        Angle to rotate in xy-plane.\n        Passed to `utils.transform_grid`.\n    P0 : float\n        Amplitude of the pressure profile\n    c500 : float\n        Concentration parameter at a density contrast of 500\n    m500 : float\n        Mass at a density contrast of 500\n    gamma : float\n        The central slope\n    alpha : float\n        The intermediate slope\n    beta : float\n        The outer slope\n    z : float\n        Redshift of cluster\n    xyz : tuple[jax.Array, jax.Array, jax.Array, float, float]\n        Coordinte grid to calculate model on.\n        See `containers.Model.xyz` for details.\n\n    Returns\n    -------\n    model : jax.Array\n        The gnfw model evaluated on the grid.\n    \"\"\"\n\n    nz = get_nz(z)\n    hz = get_hz(z)\n    da = get_da(z)  # TODO pass these arguments rather than recompute them everytime???\n\n    r500 = (m500 / (4.00 * jnp.pi / 3.00) / 5.00e02 / nz) ** (1.00 / 3.00)\n    r_1, r_2, r_3 = r500 / da, r500 / da, r500 / da\n\n    x, y, z = transform_grid(dx, dy, dz, r_1, r_2, r_3, theta, xyz)\n\n    r = c500 * jnp.sqrt(x**2 + y**2 + z**2)\n    denominator = (r**gamma) * (1 + r**alpha) ** ((beta - gamma) / alpha)\n\n    P500 = (\n        1.65e-03\n        * (m500 / (3.00e14 / h70)) ** (2.00 / 3.00 + ap)\n        * hz ** (8.00 / 3.00)\n        * h70**2\n    )\n\n    return P500 * P0 / denominator\n</code></pre>"},{"location":"reference/structure/#witch.structure.add_exponential","title":"<code>add_exponential(pressure, xyz, dx, dy, dz, r_1, r_2, r_3, theta, amp, xk, x0, yk, y0, zk, z0)</code>","text":"<p>Add ellipsoid with exponential structure to 3d pressure profile.</p> <p>After transforming the grid the region where \\(\\sqrt{x^2 + y^2 + z^2} \\leq 1\\) will be multiplied by a factor of \\(1 + P_{0} e^{x_k(x-x_0) + y_k(y-y_0) + z_k(z-z_0)}\\) where \\(P_{0}\\) is <code>amp</code>.</p> <p>Parameters:</p> Name Type Description Default <code>pressure</code> <code>Array</code> <p>The pressure profile to modify with this ellipsoid. Should be evaluated on the same grid as <code>xyz</code>.</p> required <code>xyz</code> <code>tuple[Array, Array, Array, float, float]</code> <p>Coordinte grid to calculate model on. See <code>containers.Model.xyz</code> for details.</p> required <code>dx</code> <code>float</code> <p>RA of cluster center relative to grid origin. Passed to <code>utils.transform_grid</code>.</p> required <code>dy</code> <code>float</code> <p>Dec of cluster center relative to grid origin. Passed to <code>utils.transform_grid</code>.</p> required <code>dz</code> <code>float</code> <p>Line of sight offset of cluster center relative to grid origin. Passed to <code>utils.transform_grid</code>.</p> required <code>r_1</code> <code>float</code> <p>Amount to scale along x-axis. Passed to <code>utils.transform_grid</code>.</p> required <code>r_2</code> <code>float</code> <p>Amount to scale along y-axis. Passed to <code>utils.transform_grid</code>.</p> required <code>r_3</code> <code>float</code> <p>Amount to scale along z-axis. Passed to <code>utils.transform_grid</code>.</p> required <code>theta</code> <code>float</code> <p>Angle to rotate in xy-plane. Passed to <code>utils.transform_grid</code>.</p> required <code>amp</code> <code>float</code> <p>Factor by which pressure is enhanced at the peak of ellipsoid.</p> required <code>xk</code> <code>float</code> <p>Power of exponential in RA direction</p> required <code>x0</code> <code>float</code> <p>RA offset of exponential. Note that this is in transformed coordinates so x0=1 is at xs + sr_1.</p> required <code>yk</code> <code>float</code> <p>Power of exponential in Dec direction</p> required <code>y0</code> <code>float</code> <p>Dec offset of exponential. Note that this is in transformed coordinates so y0=1 is at ys + sr_2.</p> required <code>zk</code> <code>float</code> <p>Power of exponential along the line of sight</p> required <code>z0</code> <code>float</code> <p>Line of sight offset of exponential. Note that this is in transformed coordinates so z0=1 is at zs + sr_3.</p> required <p>Returns:</p> Name Type Description <code>new_pressure</code> <code>Array</code> <p>Pressure profile with ellipsoid added.</p> Source code in <code>witch/structure.py</code> <pre><code>@jax.jit\ndef add_exponential(\n    pressure: jax.Array,\n    xyz: tuple[jax.Array, jax.Array, jax.Array, float, float],\n    dx: float,\n    dy: float,\n    dz: float,\n    r_1: float,\n    r_2: float,\n    r_3: float,\n    theta: float,\n    amp: float,\n    xk: float,\n    x0: float,\n    yk: float,\n    y0: float,\n    zk: float,\n    z0: float,\n) -&gt; jax.Array:\n    r\"\"\"\n    Add ellipsoid with exponential structure to 3d pressure profile.\n\n    After transforming the grid the region where $\\sqrt{x^2 + y^2 + z^2} \\leq 1$\n    will be multiplied by a factor of $1 + P_{0} e^{x_k(x-x_0) + y_k(y-y_0) + z_k(z-z_0)}$\n    where $P_{0}$ is `amp`.\n\n    Parameters\n    ----------\n    pressure : jax.Array\n        The pressure profile to modify with this ellipsoid.\n        Should be evaluated on the same grid as `xyz`.\n    xyz : tuple[jax.Array, jax.Array, jax.Array, float, float]\n        Coordinte grid to calculate model on.\n        See `containers.Model.xyz` for details.\n    dx : float\n        RA of cluster center relative to grid origin.\n        Passed to `utils.transform_grid`.\n    dy : float\n        Dec of cluster center relative to grid origin.\n        Passed to `utils.transform_grid`.\n    dz : float\n        Line of sight offset of cluster center relative to grid origin.\n        Passed to `utils.transform_grid`.\n    r_1 : float\n        Amount to scale along x-axis.\n        Passed to `utils.transform_grid`.\n    r_2 : float\n        Amount to scale along y-axis.\n        Passed to `utils.transform_grid`.\n    r_3 : float\n        Amount to scale along z-axis.\n        Passed to `utils.transform_grid`.\n    theta : float\n        Angle to rotate in xy-plane.\n        Passed to `utils.transform_grid`.\n    amp : float\n        Factor by which pressure is enhanced at the peak of ellipsoid.\n    xk : float\n        Power of exponential in RA direction\n    x0 : float\n        RA offset of exponential.\n        Note that this is in transformed coordinates so x0=1 is at xs + sr_1.\n    yk : float\n        Power of exponential in Dec direction\n    y0 : float\n        Dec offset of exponential.\n        Note that this is in transformed coordinates so y0=1 is at ys + sr_2.\n    zk : float\n        Power of exponential along the line of sight\n    z0 : float\n        Line of sight offset of exponential.\n        Note that this is in transformed coordinates so z0=1 is at zs + sr_3.\n\n    Returns\n    -------\n    new_pressure : Array\n        Pressure profile with ellipsoid added.\n    \"\"\"\n    x, y, z = transform_grid(dx, dy, dz, r_1, r_2, r_3, theta, xyz)\n\n    exponential = amp * jnp.exp(((x - x0) * xk) + ((y - y0) * yk) + ((z - z0) * zk))\n\n    new_pressure = jnp.where(\n        jnp.sqrt(x**2 + y**2 + z**2) &gt; 1, pressure, (1 + exponential) * pressure\n    )\n    return new_pressure\n</code></pre>"},{"location":"reference/structure/#witch.structure.add_powerlaw","title":"<code>add_powerlaw(pressure, xyz, dx, dy, dz, r_1, r_2, r_3, theta, amp, phi0, k_r, k_phi)</code>","text":"<p>Add ellipsoid with power law structure to 3d pressure profile.</p> <p>After transforming the grid the region where \\(\\sqrt{x^2 + y^2 + z^2} \\leq 1\\) will be multiplied by a factor of \\(1 + P_{0}(1 - {1 + r}^{-k_r})(1 - {1 + \\phi}^{-k_{\\phi}})\\). Where \\(r\\) and \\(\\phi\\) are the usual polar coordinates and \\(P_{0}\\) is <code>amp</code>.</p> <p>Parameters:</p> Name Type Description Default <code>pressure</code> <code>Array</code> <p>The pressure profile to modify with this ellipsoid. Should be evaluated on the same grid as <code>xyz</code>.</p> required <code>xyz</code> <code>tuple[Array, Array, Array, float, float]</code> <p>Coordinte grid to calculate model on. See <code>containers.Model.xyz</code> for details.</p> required <code>dx</code> <code>float</code> <p>RA of cluster center relative to grid origin. Passed to <code>utils.transform_grid</code>.</p> required <code>dy</code> <code>float</code> <p>Dec of cluster center relative to grid origin. Passed to <code>utils.transform_grid</code>.</p> required <code>dz</code> <code>float</code> <p>Line of sight offset of cluster center relative to grid origin. Passed to <code>utils.transform_grid</code>.</p> required <code>r_1</code> <code>float</code> <p>Amount to scale along x-axis. Passed to <code>utils.transform_grid</code>.</p> required <code>r_2</code> <code>float</code> <p>Amount to scale along y-axis. Passed to <code>utils.transform_grid</code>.</p> required <code>r_3</code> <code>float</code> <p>Amount to scale along z-axis. Passed to <code>utils.transform_grid</code>.</p> required <code>theta</code> <code>float</code> <p>Angle to rotate in xy-plane. Passed to <code>utils.transform_grid</code>.</p> required <code>amp</code> <code>float</code> <p>Factor by which pressure is enhanced within the ellipsoid.</p> required <code>phi0</code> <code>float</code> <p>Polar angle of nose of power law.</p> required <code>k_r</code> <code>float</code> <p>Slope of power law in radial direction.</p> required <code>k_phi</code> <code>float</code> <p>Slope of power law in polar direction.</p> required <p>Returns:</p> Name Type Description <code>new_pressure</code> <code>Array</code> <p>Pressure profile with ellipsoid added.</p> Source code in <code>witch/structure.py</code> <pre><code>@jax.jit\ndef add_powerlaw(\n    pressure: jax.Array,\n    xyz: tuple[jax.Array, jax.Array, jax.Array, float, float],\n    dx: float,\n    dy: float,\n    dz: float,\n    r_1: float,\n    r_2: float,\n    r_3: float,\n    theta: float,\n    amp: float,\n    phi0: float,\n    k_r: float,\n    k_phi: float,\n) -&gt; jax.Array:\n    r\"\"\"\n    Add ellipsoid with power law structure to 3d pressure profile.\n\n    After transforming the grid the region where $\\sqrt{x^2 + y^2 + z^2} \\leq 1$\n    will be multiplied by a factor of $1 + P_{0}(1 - {1 + r}^{-k_r})(1 - {1 + \\phi}^{-k_{\\phi}})$.\n    Where $r$ and $\\phi$ are the usual polar coordinates and $P_{0}$ is `amp`.\n\n    Parameters\n    ----------\n    pressure : jax.Array\n        The pressure profile to modify with this ellipsoid.\n        Should be evaluated on the same grid as `xyz`.\n    xyz : tuple[jax.Array, jax.Array, jax.Array, float, float]\n        Coordinte grid to calculate model on.\n        See `containers.Model.xyz` for details.\n    dx : float\n        RA of cluster center relative to grid origin.\n        Passed to `utils.transform_grid`.\n    dy : float\n        Dec of cluster center relative to grid origin.\n        Passed to `utils.transform_grid`.\n    dz : float\n        Line of sight offset of cluster center relative to grid origin.\n        Passed to `utils.transform_grid`.\n    r_1 : float\n        Amount to scale along x-axis.\n        Passed to `utils.transform_grid`.\n    r_2 : float\n        Amount to scale along y-axis.\n        Passed to `utils.transform_grid`.\n    r_3 : float\n        Amount to scale along z-axis.\n        Passed to `utils.transform_grid`.\n    theta : float\n        Angle to rotate in xy-plane.\n        Passed to `utils.transform_grid`.\n    amp : float\n        Factor by which pressure is enhanced within the ellipsoid.\n    phi0 : float\n        Polar angle of nose of power law.\n    k_r : float\n        Slope of power law in radial direction.\n    k_phi : float\n        Slope of power law in polar direction.\n\n    Returns\n    -------\n    new_pressure : Array\n        Pressure profile with ellipsoid added.\n    \"\"\"\n    x, y, z = transform_grid(dx, dy, dz, r_1, r_2, r_3, theta, xyz)\n    r = jnp.sqrt(x**2 + y**2 + z**2)\n    phi = abs((jnp.arctan2(y, x) - phi0) % (2 * jnp.pi) - jnp.pi) / jnp.pi\n\n    powerlaw = (\n        amp\n        * (1 - jnp.float_power(1 + r, -1.0 * k_r))\n        * (1 - jnp.float_power(1 + phi, -1 * k_phi))\n    )\n    new_pressure = jnp.where(r &gt; 1, pressure, (1 + powerlaw) * pressure)\n    return new_pressure\n</code></pre>"},{"location":"reference/structure/#witch.structure.add_powerlaw_cos","title":"<code>add_powerlaw_cos(pressure, xyz, dx, dy, dz, r_1, r_2, r_3, theta, amp, phi0, k_r, omega)</code>","text":"<p>Add ellipsoid with radial power law and angular cosine dependant structure to 3d pressure profile.</p> <p>After transforming the grid the region where \\(\\sqrt{x^2 + y^2 + z^2} \\leq 1\\) will be multiplied by a factor of \\(1 + P_{0} ({1 + r}^{-k_r}) \\left| cos(\\omega\\\\phi) \\right|\\). Where \\(r\\) and \\(\\phi\\) are the usual polar coordinates and \\(P_{0}\\) is <code>amp</code>.</p> <p>Parameters:</p> Name Type Description Default <code>pressure</code> <code>Array</code> <p>The pressure profile to modify with this ellipsoid. Should be evaluated on the same grid as <code>xyz</code>.</p> required <code>xyz</code> <code>tuple[Array, Array, Array, float, float]</code> <p>Coordinte grid to calculate model on. See <code>containers.Model.xyz</code> for details.</p> required <code>dx</code> <code>float</code> <p>RA of cluster center relative to grid origin. Passed to <code>utils.transform_grid</code>.</p> required <code>dy</code> <code>float</code> <p>Dec of cluster center relative to grid origin. Passed to <code>utils.transform_grid</code>.</p> required <code>dz</code> <code>float</code> <p>Line of sight offset of cluster center relative to grid origin. Passed to <code>utils.transform_grid</code>.</p> required <code>r_1</code> <code>float</code> <p>Amount to scale along x-axis. Passed to <code>utils.transform_grid</code>.</p> required <code>r_2</code> <code>float</code> <p>Amount to scale along y-axis. Passed to <code>utils.transform_grid</code>.</p> required <code>r_3</code> <code>float</code> <p>Amount to scale along z-axis. Passed to <code>utils.transform_grid</code>.</p> required <code>theta</code> <code>float</code> <p>Angle to rotate in xy-plane. Passed to <code>utils.transform_grid</code>.</p> required <code>amp</code> <code>float</code> <p>Factor by which pressure is enhanced within the ellipsoid.</p> required <code>phi0</code> <code>float</code> <p>Polar angle of nose of power law.</p> required <code>k_r</code> <code>float</code> <p>Slope of power law in radial direction.</p> required <code>omega</code> <code>float</code> <p>Angular freqency of the cosine term.</p> required <p>Returns:</p> Name Type Description <code>new_pressure</code> <code>Array</code> <p>Pressure profile with ellipsoid added.</p> Source code in <code>witch/structure.py</code> <pre><code>@jax.jit\ndef add_powerlaw_cos(\n    pressure: jax.Array,\n    xyz: tuple[jax.Array, jax.Array, jax.Array, float, float],\n    dx: float,\n    dy: float,\n    dz: float,\n    r_1: float,\n    r_2: float,\n    r_3: float,\n    theta: float,\n    amp: float,\n    phi0: float,\n    k_r: float,\n    omega: float,\n) -&gt; jax.Array:\n    r\"\"\"\n    Add ellipsoid with radial power law and angular cosine dependant structure to 3d pressure profile.\n\n    After transforming the grid the region where $\\sqrt{x^2 + y^2 + z^2} \\leq 1$\n    will be multiplied by a factor of $1 + P_{0} ({1 + r}^{-k_r}) \\left| cos(\\omega\\\\phi) \\right|$.\n    Where $r$ and $\\phi$ are the usual polar coordinates and $P_{0}$ is `amp`.\n\n    Parameters\n    ----------\n    pressure : jax.Array\n        The pressure profile to modify with this ellipsoid.\n        Should be evaluated on the same grid as `xyz`.\n    xyz : tuple[jax.Array, jax.Array, jax.Array, float, float]\n        Coordinte grid to calculate model on.\n        See `containers.Model.xyz` for details.\n    dx : float\n        RA of cluster center relative to grid origin.\n        Passed to `utils.transform_grid`.\n    dy : float\n        Dec of cluster center relative to grid origin.\n        Passed to `utils.transform_grid`.\n    dz : float\n        Line of sight offset of cluster center relative to grid origin.\n        Passed to `utils.transform_grid`.\n    r_1 : float\n        Amount to scale along x-axis.\n        Passed to `utils.transform_grid`.\n    r_2 : float\n        Amount to scale along y-axis.\n        Passed to `utils.transform_grid`.\n    r_3 : float\n        Amount to scale along z-axis.\n        Passed to `utils.transform_grid`.\n    theta : float\n        Angle to rotate in xy-plane.\n        Passed to `utils.transform_grid`.\n    amp : float\n        Factor by which pressure is enhanced within the ellipsoid.\n    phi0 : float\n        Polar angle of nose of power law.\n    k_r : float\n        Slope of power law in radial direction.\n    omega : float\n        Angular freqency of the cosine term.\n\n    Returns\n    -------\n    new_pressure : Array\n        Pressure profile with ellipsoid added.\n    \"\"\"\n    x, y, z = transform_grid(dx, dy, dz, r_1, r_2, r_3, theta, xyz)\n    r = jnp.sqrt(x**2 + y**2 + z**2)\n    phi = (jnp.arctan2(y, x) - phi0) % (2 * jnp.pi)\n\n    powerlaw = amp * jnp.abs(jnp.cos(omega * phi)) * jnp.float_power(r, k_r)\n    new_pressure = jnp.where(r &gt; 1, pressure, (1 + powerlaw) * pressure)\n    return new_pressure\n</code></pre>"},{"location":"reference/structure/#witch.structure.add_uniform","title":"<code>add_uniform(pressure, xyz, dx, dy, dz, r_1, r_2, r_3, theta, amp)</code>","text":"<p>Add ellipsoid with uniform structure to 3d pressure profile.</p> <p>After transforming the grid the region where \\(\\sqrt{x^2 + y^2 + z^2} \\leq 1\\) will be multiplied by a factor of \\(1 + P_{0}\\) where \\(P_{0}\\) is <code>amp</code>.</p> <p>Parameters:</p> Name Type Description Default <code>pressure</code> <code>Array</code> <p>The pressure profile to modify with this ellipsoid. Should be evaluated on the same grid as <code>xyz</code>.</p> required <code>xyz</code> <code>tuple[Array, Array, Array, float, float]</code> <p>Coordinte grid to calculate model on. See <code>containers.Model.xyz</code> for details.</p> required <code>dx</code> <code>float</code> <p>RA of cluster center relative to grid origin. Passed to <code>utils.transform_grid</code>.</p> required <code>dy</code> <code>float</code> <p>Dec of cluster center relative to grid origin. Passed to <code>utils.transform_grid</code>.</p> required <code>dz</code> <code>float</code> <p>Line of sight offset of cluster center relative to grid origin. Passed to <code>utils.transform_grid</code>.</p> required <code>r_1</code> <code>float</code> <p>Amount to scale along x-axis. Passed to <code>utils.transform_grid</code>.</p> required <code>r_2</code> <code>float</code> <p>Amount to scale along y-axis. Passed to <code>utils.transform_grid</code>.</p> required <code>r_3</code> <code>float</code> <p>Amount to scale along z-axis. Passed to <code>utils.transform_grid</code>.</p> required <code>theta</code> <code>float</code> <p>Angle to rotate in xy-plane. Passed to <code>utils.transform_grid</code>.</p> required <code>amp</code> <code>float</code> <p>Factor by which pressure is enhanced within the ellipsoid.</p> required <p>Returns:</p> Name Type Description <code>new_pressure</code> <code>Array</code> <p>Pressure profile with ellipsoid added.</p> Source code in <code>witch/structure.py</code> <pre><code>@jax.jit\ndef add_uniform(\n    pressure: jax.Array,\n    xyz: tuple[jax.Array, jax.Array, jax.Array, float, float],\n    dx: float,\n    dy: float,\n    dz: float,\n    r_1: float,\n    r_2: float,\n    r_3: float,\n    theta: float,\n    amp: float,\n) -&gt; jax.Array:\n    r\"\"\"\n    Add ellipsoid with uniform structure to 3d pressure profile.\n\n    After transforming the grid the region where $\\sqrt{x^2 + y^2 + z^2} \\leq 1$\n    will be multiplied by a factor of $1 + P_{0}$ where $P_{0}$ is `amp`.\n\n    Parameters\n    ----------\n    pressure : jax.Array\n        The pressure profile to modify with this ellipsoid.\n        Should be evaluated on the same grid as `xyz`.\n    xyz : tuple[jax.Array, jax.Array, jax.Array, float, float]\n        Coordinte grid to calculate model on.\n        See `containers.Model.xyz` for details.\n    dx : float\n        RA of cluster center relative to grid origin.\n        Passed to `utils.transform_grid`.\n    dy : float\n        Dec of cluster center relative to grid origin.\n        Passed to `utils.transform_grid`.\n    dz : float\n        Line of sight offset of cluster center relative to grid origin.\n        Passed to `utils.transform_grid`.\n    r_1 : float\n        Amount to scale along x-axis.\n        Passed to `utils.transform_grid`.\n    r_2 : float\n        Amount to scale along y-axis.\n        Passed to `utils.transform_grid`.\n    r_3 : float\n        Amount to scale along z-axis.\n        Passed to `utils.transform_grid`.\n    theta : float\n        Angle to rotate in xy-plane.\n        Passed to `utils.transform_grid`.\n    amp : float\n        Factor by which pressure is enhanced within the ellipsoid.\n\n    Returns\n    -------\n    new_pressure : Array\n        Pressure profile with ellipsoid added.\n    \"\"\"\n    x, y, z = transform_grid(dx, dy, dz, r_1, r_2, r_3, theta, xyz)\n\n    new_pressure = jnp.where(\n        jnp.sqrt(x**2 + y**2 + z**2) &gt; 1, pressure, (1 + amp) * pressure\n    )\n    return new_pressure\n</code></pre>"},{"location":"reference/structure/#witch.structure.cylindrical_beta","title":"<code>cylindrical_beta(dx, dy, dz, L, theta, P0, r_c, beta, xyz)</code>","text":"<p>This function does not include smoothing or declination stretch which should be applied at the end.</p> <p>Once the grid is transformed the profile is computed as:</p> \\[ P_{0}\\left( 1 + \\frac{y^2 + z^2}{{r_c}^2} \\right)^{-1.5\\beta} \\] <p>Parameters:</p> Name Type Description Default <code>dx</code> <code>float</code> <p>RA of cluster center relative to grid origin. Passed to <code>utils.transform_grid</code>.</p> required <code>dy</code> <code>float</code> <p>Dec of cluster center relative to grid origin. Passed to <code>utils.transform_grid</code>.</p> required <code>dz</code> <code>float</code> <p>Line of sight offset of cluster center relative to grid origin. Passed to <code>utils.transform_grid</code>.</p> required <code>L</code> <code>float</code> <p>Length of the cylinder. Aligned with the x-axis. Note that we consider anything where \\(\\left| x \\right| \\\\leq L\\) to be in the profile, so the actual length is \\(2L\\).</p> required <code>theta</code> <code>float</code> <p>Angle to rotate in xy-plane. Passed to <code>utils.transform_grid</code>.</p> required <code>P0</code> <code>float</code> <p>Amplitude of the pressure profile.</p> required <code>r_c</code> <code>float</code> <p>The critical radius of the cylindrical profile.</p> required <code>beta</code> <code>float</code> <p>Beta value of isobeta model.</p> required <code>xyz</code> <code>tuple[Array, Array, Array, float, float]</code> <p>Coordinte grid to calculate model on. See <code>containers.Model.xyz</code> for details.</p> required <p>Returns:</p> Name Type Description <code>model</code> <code>Array</code> <p>The cylindrical beta model evaluated on the grid.</p> Source code in <code>witch/structure.py</code> <pre><code>@jax.jit\ndef cylindrical_beta(\n    dx: float,\n    dy: float,\n    dz: float,\n    L: float,\n    theta: float,\n    P0: float,\n    r_c: float,\n    beta: float,\n    xyz: tuple[jax.Array, jax.Array, jax.Array, float, float],\n) -&gt; jax.Array:\n    r\"\"\"\n\n    This function does not include smoothing or declination stretch\n    which should be applied at the end.\n\n    Once the grid is transformed the profile is computed as:\n\n    $$\n    P_{0}\\left( 1 + \\frac{y^2 + z^2}{{r_c}^2} \\right)^{-1.5\\beta}\n    $$\n\n    Parameters\n    ----------\n    dx : float\n        RA of cluster center relative to grid origin.\n        Passed to `utils.transform_grid`.\n    dy : float\n        Dec of cluster center relative to grid origin.\n        Passed to `utils.transform_grid`.\n    dz : float\n        Line of sight offset of cluster center relative to grid origin.\n        Passed to `utils.transform_grid`.\n    L : float\n        Length of the cylinder.\n        Aligned with the x-axis.\n        Note that we consider anything where $\\left| x \\right| \\\\leq L$\n        to be in the profile, so the actual length is $2L$.\n    theta : float\n        Angle to rotate in xy-plane.\n        Passed to `utils.transform_grid`.\n    P0 : float\n        Amplitude of the pressure profile.\n    r_c : float\n        The critical radius of the cylindrical profile.\n    beta : float\n        Beta value of isobeta model.\n    xyz : tuple[jax.Array, jax.Array, jax.Array, float, float]\n        Coordinte grid to calculate model on.\n        See `containers.Model.xyz` for details.\n\n    Returns\n    -------\n    model : jax.Array\n        The cylindrical beta model evaluated on the grid.\n    \"\"\"\n    x, y, z = transform_grid(dx, dy, dz, 1.0, 1.0, 1.0, theta, xyz)\n    r = jnp.sqrt(y**2 + z**2)\n    powerlaw = P0 / (1.0 + (r / r_c) ** 2) ** (3.0 / 2.0 * beta)\n\n    pressure = jnp.where(jnp.abs(x) &gt;= L / 2.0, 0, powerlaw)\n\n    return pressure\n</code></pre>"},{"location":"reference/structure/#witch.structure.ea10","title":"<code>ea10(dx, dy, dz, r_1, r_2, r_3, theta, P0, c500, m500, gamma, alpha, beta, z, xyz)</code>","text":"<p>Eliptical gNFW pressure profile in 3d based on Arnaud2010. r_ell is computed in the usual way for an a10 profile, then the axes are scaled according to r_1, r_2, r_3, with a normalization applied. This function does not include smoothing or declination stretch which should be applied at the end.</p> <p>See the docstring for <code>gnfw</code> for more details.</p> <p>Parameters:</p> Name Type Description Default <code>dx</code> <code>float</code> <p>RA of cluster center relative to grid origin. Passed to <code>utils.transform_grid</code>.</p> required <code>dy</code> <code>float</code> <p>Dec of cluster center relative to grid origin. Passed to <code>utils.transform_grid</code>.</p> required <code>dz</code> <code>float</code> <p>Line of sight offset of cluster center relative to grid origin. Passed to <code>utils.transform_grid</code>.</p> required <code>r_1</code> <code>float</code> <p>Amount to scale along x-axis. Units are arbitrary, only ratio of r_1/r_2, r_1/r_3, r_2/r_3 matters Passed to <code>utils.transform_grid</code>.</p> required <code>r_2</code> <code>float</code> <p>Amount to scale along y-axis. Passed to <code>utils.transform_grid</code>.</p> required <code>r_3</code> <code>float</code> <p>Amount to scale along z-axis. Passed to <code>utils.transform_grid</code>.</p> required <code>theta</code> <code>float</code> <p>Angle to rotate in xy-plane. Passed to <code>utils.transform_grid</code>.</p> required <code>P0</code> <code>float</code> <p>Amplitude of the pressure profile</p> required <code>c500</code> <code>float</code> <p>Concentration parameter at a density contrast of 500</p> required <code>m500</code> <code>float</code> <p>Mass at a density contrast of 500</p> required <code>gamma</code> <code>float</code> <p>The central slope</p> required <code>alpha</code> <code>float</code> <p>The intermediate slope</p> required <code>beta</code> <code>float</code> <p>The outer slope</p> required <code>z</code> <code>float</code> <p>Redshift of cluster</p> required <code>xyz</code> <code>tuple[Array, Array, Array, float, float]</code> <p>Coordinte grid to calculate model on. See <code>containers.Model.xyz</code> for details.</p> required <p>Returns:</p> Name Type Description <code>model</code> <code>Array</code> <p>The gnfw model evaluated on the grid.</p> Source code in <code>witch/structure.py</code> <pre><code>@jax.jit\ndef ea10(\n    dx: float,\n    dy: float,\n    dz: float,\n    r_1: float,\n    r_2: float,\n    r_3: float,\n    theta: float,\n    P0: float,\n    c500: float,\n    m500: float,\n    gamma: float,\n    alpha: float,\n    beta: float,\n    z: float,\n    xyz: tuple[jax.Array, jax.Array, jax.Array, float, float],\n) -&gt; jax.Array:\n    r\"\"\"\n    Eliptical gNFW pressure profile in 3d based on Arnaud2010.\n    r_ell is computed in the usual way for an a10 profile, then the axes are\n    scaled according to r_1, r_2, r_3, with a normalization applied.\n    This function does not include smoothing or declination stretch\n    which should be applied at the end.\n\n    See the docstring for `gnfw` for more details.\n\n    Parameters\n    ----------\n    dx : float\n        RA of cluster center relative to grid origin.\n        Passed to `utils.transform_grid`.\n    dy : float\n        Dec of cluster center relative to grid origin.\n        Passed to `utils.transform_grid`.\n    dz : float\n        Line of sight offset of cluster center relative to grid origin.\n        Passed to `utils.transform_grid`.\n    r_1 : float\n        Amount to scale along x-axis.\n        Units are arbitrary, only ratio of r_1/r_2, r_1/r_3, r_2/r_3 matters\n        Passed to `utils.transform_grid`.\n    r_2 : float\n        Amount to scale along y-axis.\n        Passed to `utils.transform_grid`.\n    r_3 : float\n        Amount to scale along z-axis.\n        Passed to `utils.transform_grid`.\n    theta : float\n        Angle to rotate in xy-plane.\n        Passed to `utils.transform_grid`.\n    P0 : float\n        Amplitude of the pressure profile\n    c500 : float\n        Concentration parameter at a density contrast of 500\n    m500 : float\n        Mass at a density contrast of 500\n    gamma : float\n        The central slope\n    alpha : float\n        The intermediate slope\n    beta : float\n        The outer slope\n    z : float\n        Redshift of cluster\n    xyz : tuple[jax.Array, jax.Array, jax.Array, float, float]\n        Coordinte grid to calculate model on.\n        See `containers.Model.xyz` for details.\n\n    Returns\n    -------\n    model : jax.Array\n        The gnfw model evaluated on the grid.\n    \"\"\"\n    nz = get_nz(z)\n    hz = get_hz(z)\n    da = get_da(z)  # TODO pass these arguments rather than recompute them everytime???\n\n    r500 = (m500 / (4.00 * jnp.pi / 3.00) / 5.00e02 / nz) ** (1.00 / 3.00)\n    r_ell = r500 / da\n    r_norm = (r_1 * r_2 * r_3) ** (1 / 3)\n\n    r_1 *= r_ell / r_norm\n    r_2 *= r_ell / r_norm\n    r_3 *= r_ell / r_norm\n\n    x, y, z = transform_grid(dx, dy, dz, r_1, r_2, r_3, theta, xyz)\n\n    r = c500 * jnp.sqrt(x**2 + y**2 + z**2)\n    denominator = (r**gamma) * (1 + r**alpha) ** ((beta - gamma) / alpha)\n\n    P500 = (\n        1.65e-03\n        * (m500 / (3.00e14 / h70)) ** (2.00 / 3.00 + ap)\n        * hz ** (8.00 / 3.00)\n        * h70**2\n    )\n\n    return P500 * P0 / denominator\n</code></pre>"},{"location":"reference/structure/#witch.structure.egaussian","title":"<code>egaussian(dx, dy, dz, r_1, r_2, r_3, theta, sigma, amp, xyz)</code>","text":"<p>Elliptical gaussian profile in 3d. This function does not include smoothing or declination stretch which should be applied at the end.</p> <p>Once the grid is transformed the profile is computed as:</p> \\[ P_{0} e^{-\\frac{x^2 + y^2 + z^2}{2\\sigma^2}} \\] <p>where \\(P_{0}\\) is <code>amp</code>.</p> <p>Parameters:</p> Name Type Description Default <code>dx</code> <code>float</code> <p>RA of cluster center relative to grid origin. Passed to <code>utils.transform_grid</code>.</p> required <code>dy</code> <code>float</code> <p>Dec of cluster center relative to grid origin. Passed to <code>utils.transform_grid</code>.</p> required <code>dz</code> <code>float</code> <p>Line of sight offset of cluster center relative to grid origin. Passed to <code>utils.transform_grid</code>.</p> required <code>r_1</code> <code>float</code> <p>Amount to scale along x-axis. Passed to <code>utils.transform_grid</code>.</p> required <code>r_2</code> <code>float</code> <p>Amount to scale along y-axis. Passed to <code>utils.transform_grid</code>.</p> required <code>r_3</code> <code>float</code> <p>Amount to scale along z-axis. Passed to <code>utils.transform_grid</code>.</p> required <code>theta</code> <code>float</code> <p>Angle to rotate in xy-plane. Passed to <code>utils.transform_grid</code>.</p> required <code>sigma</code> <code>float</code> <p>Sigma value of gaussian model.</p> required <code>amp</code> <code>float</code> <p>Amplitude of gaussian model.</p> required <code>xyz</code> <code>tuple[Array, Array, Array, float, float]</code> <p>Coordinte grid to calculate model on. See <code>containers.Model.xyz</code> for details.</p> required <p>Returns:</p> Name Type Description <code>model</code> <code>Array</code> <p>The gaussain model evaluated on the grid.</p> Source code in <code>witch/structure.py</code> <pre><code>@jax.jit\ndef egaussian(\n    dx: float,\n    dy: float,\n    dz: float,\n    r_1: float,\n    r_2: float,\n    r_3: float,\n    theta: float,\n    sigma: float,\n    amp: float,\n    xyz: tuple[jax.Array, jax.Array, jax.Array, float, float],\n) -&gt; jax.Array:\n    r\"\"\"\n    Elliptical gaussian profile in 3d.\n    This function does not include smoothing or declination stretch\n    which should be applied at the end.\n\n    Once the grid is transformed the profile is computed as:\n\n    $$\n    P_{0} e^{-\\frac{x^2 + y^2 + z^2}{2\\sigma^2}}\n    $$\n\n    where $P_{0}$ is `amp`.\n\n    Parameters\n    ----------\n    dx : float\n        RA of cluster center relative to grid origin.\n        Passed to `utils.transform_grid`.\n    dy : float\n        Dec of cluster center relative to grid origin.\n        Passed to `utils.transform_grid`.\n    dz : float\n        Line of sight offset of cluster center relative to grid origin.\n        Passed to `utils.transform_grid`.\n    r_1 : float\n        Amount to scale along x-axis.\n        Passed to `utils.transform_grid`.\n    r_2 : float\n        Amount to scale along y-axis.\n        Passed to `utils.transform_grid`.\n    r_3 : float\n        Amount to scale along z-axis.\n        Passed to `utils.transform_grid`.\n    theta : float\n        Angle to rotate in xy-plane.\n        Passed to `utils.transform_grid`.\n    sigma : float\n        Sigma value of gaussian model.\n    amp : float\n        Amplitude of gaussian model.\n    xyz : tuple[jax.Array, jax.Array, jax.Array, float, float]\n        Coordinte grid to calculate model on.\n        See `containers.Model.xyz` for details.\n\n    Returns\n    -------\n    model : jax.Array\n        The gaussain model evaluated on the grid.\n    \"\"\"\n    x, y, z = transform_grid(dx, dy, dz, r_1, r_2, r_3, theta, xyz)\n\n    rr = x**2 + y**2 + z**2\n    power = -1 * rr / (2 * sigma**2)\n\n    return amp * jnp.exp(power)\n</code></pre>"},{"location":"reference/structure/#witch.structure.gaussian","title":"<code>gaussian(dx, dy, sigma, amp, xyz)</code>","text":"<p>Standard gaussian profile in 2d. This function does not include smoothing or declination stretch which should be applied at the end. The transform_grid call is awkward and can probably be removed/worked around. Function exists to match existing guassian interfaces.</p> <p>Once the grid is transformed the profile is computed as:</p> \\[ P_{0} e^{-\\frac{x^2 + y^2}{2\\sigma^2}} \\] <p>where \\(P_{0}\\) is <code>amp</code>.</p> <p>Parameters:</p> Name Type Description Default <code>dx</code> <code>float</code> <p>RA of cluster center relative to grid origin. Passed to <code>utils.transform_grid</code>.</p> required <code>dy</code> <code>float</code> <p>Dec of cluster center relative to grid origin. Passed to <code>utils.transform_grid</code>.</p> required <code>sigma</code> <code>float</code> <p>Sigma value of gaussian model.</p> required <code>amp</code> <code>float</code> <p>Amplitude of gaussian model.</p> required <code>xyz</code> <code>tuple[Array, Array, Array, float, float]</code> <p>Coordinte grid to calculate model on. We only care about x and y here. See <code>containers.Model.xyz</code> for details.</p> required <p>Returns:</p> Name Type Description <code>model</code> <code>Array</code> <p>The gaussian model evaluated on only the 2d xy grid.</p> Source code in <code>witch/structure.py</code> <pre><code>@jax.jit\ndef gaussian(\n    dx: float,\n    dy: float,\n    sigma: float,\n    amp: float,\n    xyz: tuple[jax.Array, jax.Array, jax.Array, float, float],\n) -&gt; jax.Array:\n    r\"\"\"\n    Standard gaussian profile in 2d.\n    This function does not include smoothing or declination stretch\n    which should be applied at the end. The transform_grid call is\n    awkward and can probably be removed/worked around. Function exists\n    to match existing guassian interfaces.\n\n    Once the grid is transformed the profile is computed as:\n\n    $$\n    P_{0} e^{-\\frac{x^2 + y^2}{2\\sigma^2}}\n    $$\n\n    where $P_{0}$ is `amp`.\n\n    Parameters\n    ----------\n    dx : float\n        RA of cluster center relative to grid origin.\n        Passed to `utils.transform_grid`.\n    dy : float\n        Dec of cluster center relative to grid origin.\n        Passed to `utils.transform_grid`.\n    sigma : float\n        Sigma value of gaussian model.\n    amp : float\n        Amplitude of gaussian model.\n    xyz : tuple[jax.Array, jax.Array, jax.Array, float, float]\n        Coordinte grid to calculate model on.\n        We only care about x and y here.\n        See `containers.Model.xyz` for details.\n\n    Returns\n    -------\n    model : jax.Array\n        The gaussian model evaluated on only the 2d xy grid.\n    \"\"\"\n    x, y, _ = transform_grid(dx, dy, 0, 1, 1, 1, 0, xyz)\n    rr = x[..., 0] ** 2 + y[..., 0] ** 2\n    power = -1 * rr / (2 * sigma**2)\n\n    return amp * jnp.exp(power)\n</code></pre>"},{"location":"reference/structure/#witch.structure.gnfw","title":"<code>gnfw(dx, dy, dz, r_1, r_2, r_3, theta, P0, c500, m500, gamma, alpha, beta, z, xyz)</code>","text":"<p>Elliptical gNFW pressure profile in 3d. This function does not include smoothing or declination stretch which should be applied at the end. TODO: Add units to add parameters!</p> <p>Once the grid is transformed the profile is computed as:</p> \\[ \\dfrac{P_{500} * P_{0}}{{\\left( r^{\\gamma}\\left( 1 + r^{\\alpha} \\right) \\right)}^{\\dfrac{\\beta - \\gamma}{\\alpha}}} \\] <p>where:</p> \\[ r = c_{500} \\sqrt{x^2 + y^2 + z^2} {\\frac{3m_{500}}{2000 \\pi n_z}}^{-\\frac{1}{3}} \\] \\[ P_{500} = 1.65 \\times 10^{-3} {\\frac{m_{500}*h_{70}}{3 \\times 10^{14}}}^{\\frac{2}{3} + ap}{h_z}^{\\frac{8}{3}}{h_{70}}^2 \\] <p>\\(n_z\\) is the critical density at the cluster redshift and \\(h_z\\) is the Hubble constant at the cluster redshift.</p> <p>Parameters:</p> Name Type Description Default <code>dx</code> <code>float</code> <p>RA of cluster center relative to grid origin. Passed to <code>utils.transform_grid</code>.</p> required <code>dy</code> <code>float</code> <p>Dec of cluster center relative to grid origin. Passed to <code>utils.transform_grid</code>.</p> required <code>dz</code> <code>float</code> <p>Line of sight offset of cluster center relative to grid origin. Passed to <code>utils.transform_grid</code>.</p> required <code>r_1</code> <code>float</code> <p>Amount to scale along x-axis. Passed to <code>utils.transform_grid</code>.</p> required <code>r_2</code> <code>float</code> <p>Amount to scale along y-axis. Passed to <code>utils.transform_grid</code>.</p> required <code>r_3</code> <code>float</code> <p>Amount to scale along z-axis. Passed to <code>utils.transform_grid</code>.</p> required <code>theta</code> <code>float</code> <p>Angle to rotate in xy-plane. Passed to <code>utils.transform_grid</code>.</p> required <code>P0</code> <code>float</code> <p>Amplitude of the pressure profile.</p> required <code>c500</code> <code>float</code> <p>Concentration parameter at a density contrast of 500.</p> required <code>m500</code> <code>float</code> <p>Mass at a density contrast of 500.</p> required <code>gamma</code> <code>float</code> <p>The central slope.</p> required <code>alpha</code> <code>float</code> <p>The intermediate slope.</p> required <code>beta</code> <code>float</code> <p>The outer slope.</p> required <code>z</code> <code>float</code> <p>Redshift of cluster.</p> required <code>xyz</code> <code>tuple[Array, Array, Array, float, float]</code> <p>Coordinte grid to calculate model on. See <code>containers.Model.xyz</code> for details.</p> required <p>Returns:</p> Name Type Description <code>model</code> <code>Array</code> <p>The gnfw model evaluated on the grid.</p> Source code in <code>witch/structure.py</code> <pre><code>@jax.jit\ndef gnfw(\n    dx: float,\n    dy: float,\n    dz: float,\n    r_1: float,\n    r_2: float,\n    r_3: float,\n    theta: float,\n    P0: float,\n    c500: float,\n    m500: float,\n    gamma: float,\n    alpha: float,\n    beta: float,\n    z: float,\n    xyz: tuple[jax.Array, jax.Array, jax.Array, float, float],\n) -&gt; jax.Array:\n    r\"\"\"\n    Elliptical gNFW pressure profile in 3d.\n    This function does not include smoothing or declination stretch\n    which should be applied at the end.\n    TODO: Add units to add parameters!\n\n    Once the grid is transformed the profile is computed as:\n\n    $$\n    \\dfrac{P_{500} * P_{0}}{{\\left( r^{\\gamma}\\left( 1 + r^{\\alpha} \\right) \\right)}^{\\dfrac{\\beta - \\gamma}{\\alpha}}}\n    $$\n\n    where:\n\n    $$\n    r = c_{500} \\sqrt{x^2 + y^2 + z^2} {\\frac{3m_{500}}{2000 \\pi n_z}}^{-\\frac{1}{3}}\n    $$\n\n    $$\n    P_{500} = 1.65 \\times 10^{-3} {\\frac{m_{500}*h_{70}}{3 \\times 10^{14}}}^{\\frac{2}{3} + ap}{h_z}^{\\frac{8}{3}}{h_{70}}^2\n    $$\n\n    $n_z$ is the critical density at the cluster redshift and $h_z$ is the Hubble constant at the cluster redshift.\n\n    Parameters\n    ----------\n    dx : float\n        RA of cluster center relative to grid origin.\n        Passed to `utils.transform_grid`.\n    dy : float\n        Dec of cluster center relative to grid origin.\n        Passed to `utils.transform_grid`.\n    dz : float\n        Line of sight offset of cluster center relative to grid origin.\n        Passed to `utils.transform_grid`.\n    r_1 : float\n        Amount to scale along x-axis.\n        Passed to `utils.transform_grid`.\n    r_2 : float\n        Amount to scale along y-axis.\n        Passed to `utils.transform_grid`.\n    r_3 : float\n        Amount to scale along z-axis.\n        Passed to `utils.transform_grid`.\n    theta : float\n        Angle to rotate in xy-plane.\n        Passed to `utils.transform_grid`.\n    P0 : float\n        Amplitude of the pressure profile.\n    c500 : float\n        Concentration parameter at a density contrast of 500.\n    m500 : float\n        Mass at a density contrast of 500.\n    gamma : float\n        The central slope.\n    alpha : float\n        The intermediate slope.\n    beta : float\n        The outer slope.\n    z : float\n        Redshift of cluster.\n    xyz : tuple[jax.Array, jax.Array, jax.Array, float, float]\n        Coordinte grid to calculate model on.\n        See `containers.Model.xyz` for details.\n\n    Returns\n    -------\n    model : jax.Array\n        The gnfw model evaluated on the grid.\n    \"\"\"\n    nz = get_nz(z)\n    hz = get_hz(z)\n\n    x, y, z = transform_grid(dx, dy, dz, r_1, r_2, r_3, theta, xyz)\n\n    r500 = (m500 / (4.00 * jnp.pi / 3.00) / 5.00e02 / nz) ** (1.00 / 3.00)\n\n    r = c500 * jnp.sqrt(x**2 + y**2 + z**2) / r500\n    denominator = (r**gamma) * (1 + r**alpha) ** ((beta - gamma) / alpha)\n\n    P500 = (\n        1.65e-03\n        * (m500 / (3.00e14 / h70)) ** (2.00 / 3.00 + ap)\n        * hz ** (8.00 / 3.00)\n        * h70**2\n    )\n\n    return P500 * P0 / denominator\n</code></pre>"},{"location":"reference/structure/#witch.structure.isobeta","title":"<code>isobeta(dx, dy, dz, r_1, r_2, r_3, theta, beta, amp, xyz)</code>","text":"<p>Elliptical isobeta pressure profile in 3d. This function does not include smoothing or declination stretch which should be applied at the end.</p> <p>Once the grid is transformed the profile is computed as:</p> \\[ P_{0}\\left( 1 + x**2 + y**2 + z**2 \\right)^{-1.5\\beta} \\] <p>where \\(P_{0}\\) is <code>amp</code>.</p> <p>Parameters:</p> Name Type Description Default <code>dx</code> <code>float</code> <p>RA of cluster center relative to grid origin. Passed to <code>utils.transform_grid</code>.</p> required <code>dy</code> <code>float</code> <p>Dec of cluster center relative to grid origin. Passed to <code>utils.transform_grid</code>.</p> required <code>dz</code> <code>float</code> <p>Line of sight offset of cluster center relative to grid origin. Passed to <code>utils.transform_grid</code>.</p> required <code>r_1</code> <code>float</code> <p>Amount to scale along x-axis. Passed to <code>utils.transform_grid</code>.</p> required <code>r_2</code> <code>float</code> <p>Amount to scale along y-axis. Passed to <code>utils.transform_grid</code>.</p> required <code>r_3</code> <code>float</code> <p>Amount to scale along z-axis. Passed to <code>utils.transform_grid</code>.</p> required <code>theta</code> <code>float</code> <p>Angle to rotate in xy-plane. Passed to <code>utils.transform_grid</code>.</p> required <code>beta</code> <code>float</code> <p>Beta value of isobeta model.</p> required <code>amp</code> <code>float</code> <p>Amplitude of isobeta model.</p> required <code>xyz</code> <code>tuple[Array, Array, Array, float, float]</code> <p>Coordinte grid to calculate model on. See <code>containers.Model.xyz</code> for details.</p> required <p>Returns:</p> Name Type Description <code>model</code> <code>Array</code> <p>The jax.isobeta model evaluated on the grid.</p> Source code in <code>witch/structure.py</code> <pre><code>@jax.jit\ndef isobeta(\n    dx: float,\n    dy: float,\n    dz: float,\n    r_1: float,\n    r_2: float,\n    r_3: float,\n    theta: float,\n    beta: float,\n    amp: float,\n    xyz: tuple[jax.Array, jax.Array, jax.Array, float, float],\n) -&gt; jax.Array:\n    r\"\"\"\n    Elliptical isobeta pressure profile in 3d.\n    This function does not include smoothing or declination stretch\n    which should be applied at the end.\n\n    Once the grid is transformed the profile is computed as:\n\n    $$\n    P_{0}\\left( 1 + x**2 + y**2 + z**2 \\right)^{-1.5\\beta}\n    $$\n\n    where $P_{0}$ is `amp`.\n\n    Parameters\n    ----------\n    dx : float\n        RA of cluster center relative to grid origin.\n        Passed to `utils.transform_grid`.\n    dy : float\n        Dec of cluster center relative to grid origin.\n        Passed to `utils.transform_grid`.\n    dz : float\n        Line of sight offset of cluster center relative to grid origin.\n        Passed to `utils.transform_grid`.\n    r_1 : float\n        Amount to scale along x-axis.\n        Passed to `utils.transform_grid`.\n    r_2 : float\n        Amount to scale along y-axis.\n        Passed to `utils.transform_grid`.\n    r_3 : float\n        Amount to scale along z-axis.\n        Passed to `utils.transform_grid`.\n    theta : float\n        Angle to rotate in xy-plane.\n        Passed to `utils.transform_grid`.\n    beta : float\n        Beta value of isobeta model.\n    amp : float\n        Amplitude of isobeta model.\n    xyz : tuple[jax.Array, jax.Array, jax.Array, float, float]\n        Coordinte grid to calculate model on.\n        See `containers.Model.xyz` for details.\n\n    Returns\n    -------\n    model : Array\n        The jax.isobeta model evaluated on the grid.\n    \"\"\"\n    x, y, z = transform_grid(dx, dy, dz, r_1, r_2, r_3, theta, xyz)\n\n    rr = 1 + x**2 + y**2 + z**2\n    power = -1.5 * beta\n    rrpow = rr**power\n\n    return amp * rrpow\n</code></pre>"},{"location":"reference/utils/","title":"utils","text":"<p>A set of utility functions and constants used for unit conversions and adding generic structure common to multiple models.</p>"},{"location":"reference/utils/#witch.utils.K_CMB2K_RJ","title":"<code>K_CMB2K_RJ(freq)</code>","text":"<p>Convert from K_CMB to K_RJ.</p> <p>Arguments:</p> <pre><code>freq: The observing frequency in Hz.\n</code></pre> <p>Returns:</p> <pre><code>K_CMB2K_RJ: Conversion factor from K_CMB to K_RJ.\n</code></pre> Source code in <code>witch/utils.py</code> <pre><code>@partial(jax.jit, static_argnums=(0,))\ndef K_CMB2K_RJ(freq):\n    \"\"\"\n    Convert from K_CMB to K_RJ.\n\n    Arguments:\n\n        freq: The observing frequency in Hz.\n\n    Returns:\n\n        K_CMB2K_RJ: Conversion factor from K_CMB to K_RJ.\n    \"\"\"\n    x = freq * h / kb / Tcmb\n    return jnp.exp(x) * x * x / jnp.expm1(x) ** 2\n</code></pre>"},{"location":"reference/utils/#witch.utils.beam_double_gauss","title":"<code>beam_double_gauss(dr, fwhm1=9.735, amp1=0.9808, fwhm2=32.627, amp2=0.0192)</code>","text":"<p>Helper function to generate a double gaussian beam.</p> <p>Arguments:</p> <pre><code>dr: Pixel size.\n\nfwhm1: Full width half max of the primary gaussian.\n\namp1: Amplitude of the primary gaussian.\n\nfwhm2: Full width half max of the secondairy gaussian.\n\namp2: Amplitude of the secondairy gaussian.\n</code></pre> <p>Returns:</p> <pre><code>beam: Double gaussian beam.\n</code></pre> Source code in <code>witch/utils.py</code> <pre><code>def beam_double_gauss(dr, fwhm1=9.735, amp1=0.9808, fwhm2=32.627, amp2=0.0192):\n    \"\"\"\n    Helper function to generate a double gaussian beam.\n\n    Arguments:\n\n        dr: Pixel size.\n\n        fwhm1: Full width half max of the primary gaussian.\n\n        amp1: Amplitude of the primary gaussian.\n\n        fwhm2: Full width half max of the secondairy gaussian.\n\n        amp2: Amplitude of the secondairy gaussian.\n\n    Returns:\n\n        beam: Double gaussian beam.\n    \"\"\"\n    x = jnp.arange(-1.5 * fwhm1 // (dr), 1.5 * fwhm1 // (dr)) * (dr)\n    beam_xx, beam_yy = jnp.meshgrid(x, x)\n    beam_rr = jnp.sqrt(beam_xx**2 + beam_yy**2)\n    beam = amp1 * jnp.exp(-4 * jnp.log(2) * beam_rr**2 / fwhm1**2) + amp2 * jnp.exp(\n        -4 * jnp.log(2) * beam_rr**2 / fwhm2**2\n    )\n    return beam / jnp.sum(beam)\n</code></pre>"},{"location":"reference/utils/#witch.utils.bilinear_interp","title":"<code>bilinear_interp(x, y, xp, yp, fp)</code>","text":"<p>JAX implementation of bilinear interpolation. Out of bounds values are set to 0. Using the repeated linear interpolation method here, see https://en.wikipedia.org/wiki/Bilinear_interpolation#Repeated_linear_interpolation.</p> <p>Arguments:</p> <pre><code>x: X values to return interpolated values at.\n\ny: Y values to return interpolated values at.\n\nxp: X values to interpolate with, should be 1D.\n    Assumed to be sorted.\n\nyp: Y values to interpolate with, should be 1D.\n    Assumed to be sorted.\n\nfp: Functon values at (xp, yp), should have shape (len(xp), len(yp)).\n    Note that if you are using meshgrid, we assume 'ij' indexing.\n</code></pre> <p>Return:</p> <pre><code>f: The interpolated values\n</code></pre> Source code in <code>witch/utils.py</code> <pre><code>@jax.jit\ndef bilinear_interp(x, y, xp, yp, fp):\n    \"\"\"\n    JAX implementation of bilinear interpolation.\n    Out of bounds values are set to 0.\n    Using the repeated linear interpolation method here,\n    see https://en.wikipedia.org/wiki/Bilinear_interpolation#Repeated_linear_interpolation.\n\n    Arguments:\n\n        x: X values to return interpolated values at.\n\n        y: Y values to return interpolated values at.\n\n        xp: X values to interpolate with, should be 1D.\n            Assumed to be sorted.\n\n        yp: Y values to interpolate with, should be 1D.\n            Assumed to be sorted.\n\n        fp: Functon values at (xp, yp), should have shape (len(xp), len(yp)).\n            Note that if you are using meshgrid, we assume 'ij' indexing.\n\n    Return:\n\n        f: The interpolated values\n    \"\"\"\n    if len(xp.shape) != 1:\n        raise ValueError(\"xp must be 1D\")\n    if len(yp.shape) != 1:\n        raise ValueError(\"yp must be 1D\")\n    if fp.shape != xp.shape + yp.shape:\n        raise ValueError(\n            \"Incompatible shapes for fp, xp, yp: %s, %s, %s\",\n            fp.shape,\n            xp.shape,\n            yp.shape,\n        )\n\n    # Figure out bounds and mapping\n    # This breaks if xp, yp is not sorted\n    ix = jnp.clip(jnp.searchsorted(xp, x, side=\"right\"), 1, len(xp) - 1)\n    iy = jnp.clip(jnp.searchsorted(yp, y, side=\"right\"), 1, len(yp) - 1)\n    q_11 = fp[ix - 1, iy - 1]\n    q_21 = fp[ix, iy - 1]\n    q_12 = fp[ix - 1, iy]\n    q_22 = fp[ix, iy]\n\n    # Interpolate in x to start\n    denom_x = xp[ix] - xp[ix - 1]\n    dx_1 = x - xp[ix - 1]\n    dx_2 = xp[ix] - x\n    f_xy1 = (dx_2 * q_11 + dx_1 * q_21) / denom_x\n    f_xy2 = (dx_2 * q_12 + dx_1 * q_22) / denom_x\n\n    # Now do y as well\n    denom_y = yp[iy] - yp[iy - 1]\n    dy_1 = y - yp[iy - 1]\n    dy_2 = yp[iy] - y\n    f = (dy_2 * f_xy1 + dy_1 * f_xy2) / denom_y\n\n    # Zero out the out of bounds values\n    f = jnp.where((x &lt; xp[0]) + (x &gt; xp[-1]) + (y &lt; yp[0]) + (y &gt; yp[-1]), 0.0, f)\n\n    return f\n</code></pre>"},{"location":"reference/utils/#witch.utils.fft_conv","title":"<code>fft_conv(image, kernel)</code>","text":"<p>Perform a convolution using FFTs for speed.</p> <p>Arguments:</p> <pre><code>image: Data to be convolved\n\nkernel: Convolution kernel\n</code></pre> <p>Returns:</p> <pre><code>convolved_map: Image convolved with kernel.\n</code></pre> Source code in <code>witch/utils.py</code> <pre><code>@jax.jit\ndef fft_conv(image, kernel):\n    \"\"\"\n    Perform a convolution using FFTs for speed.\n\n    Arguments:\n\n        image: Data to be convolved\n\n        kernel: Convolution kernel\n\n    Returns:\n\n        convolved_map: Image convolved with kernel.\n    \"\"\"\n    Fmap = jnp.fft.fft2(jnp.fft.fftshift(image))\n    Fkernel = jnp.fft.fft2(jnp.fft.fftshift(kernel))\n    convolved_map = jnp.fft.fftshift(jnp.real(jnp.fft.ifft2(Fmap * Fkernel)))\n\n    return convolved_map\n</code></pre>"},{"location":"reference/utils/#witch.utils.get_da","title":"<code>get_da(z)</code>","text":"<p>Get factor to convert from arcseconds to MPc.</p> <p>Arguments:</p> <pre><code>z: The redshift at which to compute the factor.\n</code></pre> <p>Returns:</p> <pre><code>da: Conversion factor from arcseconds to MPc\n</code></pre> Source code in <code>witch/utils.py</code> <pre><code>def get_da(z):\n    \"\"\"\n    Get factor to convert from arcseconds to MPc.\n\n    Arguments:\n\n        z: The redshift at which to compute the factor.\n\n    Returns:\n\n        da: Conversion factor from arcseconds to MPc\n    \"\"\"\n    return jnp.interp(z, dzline, daline)\n</code></pre>"},{"location":"reference/utils/#witch.utils.get_hz","title":"<code>get_hz(z)</code>","text":"<p>Get h(z).</p> <p>Arguments:</p> <pre><code>z: The redshift at which to compute the factor.\n</code></pre> <p>Returns:</p> <pre><code>hz: h at the given z.\n</code></pre> Source code in <code>witch/utils.py</code> <pre><code>def get_hz(z):\n    \"\"\"\n    Get h(z).\n\n    Arguments:\n\n        z: The redshift at which to compute the factor.\n\n    Returns:\n\n        hz: h at the given z.\n    \"\"\"\n    return jnp.interp(z, dzline, hzline)\n</code></pre>"},{"location":"reference/utils/#witch.utils.get_nz","title":"<code>get_nz(z)</code>","text":"<p>Get n(z).</p> <p>Arguments:</p> <pre><code>z: The redshift at which to compute the factor.\n</code></pre> <p>Returns:</p> <pre><code>nz: n at the given z.\n</code></pre> Source code in <code>witch/utils.py</code> <pre><code>def get_nz(z):\n    \"\"\"\n    Get n(z).\n\n    Arguments:\n\n        z: The redshift at which to compute the factor.\n\n    Returns:\n\n        nz: n at the given z.\n    \"\"\"\n    return jnp.interp(z, dzline, nzline)\n</code></pre>"},{"location":"reference/utils/#witch.utils.make_grid","title":"<code>make_grid(r_map, dx, dy=None, dz=None, x0=0, y0=0)</code>","text":"<p>Make coordinate grids to build models in. All grids are sparse and are int(2*r_map / dr) in each dimension.</p> <p>Arguments:</p> <pre><code>r_map: Size of grid radially.\n\ndx: Grid resolution in x, should be in same units as r_map.\n\ndy: Grid resolution in y, should be in same units as r_map.\n    If None then dy is set to dx.\n\ndz: Grid resolution in z, should be in same units as r_map.\n    If None then dz is set to dx.\n\nx0: Origin of grid in RA, assumed to be in same units as r_map.\n\ny0: Origin of grid in Dec, assumed to be in same units as r_map.\n</code></pre> <p>Returns:</p> <pre><code>x: Grid of x coordinates in same units as r_map.\n\ny: Grid of y coordinates in same units as r_map\n\nz: Grid of z coordinates in same units as r_map\n</code></pre> Source code in <code>witch/utils.py</code> <pre><code>def make_grid(r_map, dx, dy=None, dz=None, x0=0, y0=0):\n    \"\"\"\n    Make coordinate grids to build models in.\n    All grids are sparse and are int(2*r_map / dr) in each dimension.\n\n    Arguments:\n\n        r_map: Size of grid radially.\n\n        dx: Grid resolution in x, should be in same units as r_map.\n\n        dy: Grid resolution in y, should be in same units as r_map.\n            If None then dy is set to dx.\n\n        dz: Grid resolution in z, should be in same units as r_map.\n            If None then dz is set to dx.\n\n        x0: Origin of grid in RA, assumed to be in same units as r_map.\n\n        y0: Origin of grid in Dec, assumed to be in same units as r_map.\n\n    Returns:\n\n        x: Grid of x coordinates in same units as r_map.\n\n        y: Grid of y coordinates in same units as r_map\n\n        z: Grid of z coordinates in same units as r_map\n    \"\"\"\n    if dy is None:\n        dy = dx\n    if dz is None:\n        dz = dx\n\n    # Make grid with resolution dr and size r_map\n    x = (\n        jnp.linspace(-1 * r_map, r_map, 2 * int(r_map / dx))\n        / jnp.cos(y0 / rad_to_arcsec)\n        + x0\n    )\n    y = jnp.linspace(-1 * r_map, r_map, 2 * int(r_map / dy)) + y0\n    z = jnp.linspace(-1 * r_map, r_map, 2 * int(r_map / dz))\n\n    return tuple(jnp.meshgrid(x, y, z, sparse=True, indexing=\"ij\") + [x0, y0])\n</code></pre>"},{"location":"reference/utils/#witch.utils.make_grid_from_skymap","title":"<code>make_grid_from_skymap(skymap, z_map, dz, x0=None, y0=None)</code>","text":"<p>Make coordinate grids to build models in. All grids are sparse and are int(2*r_map / dr) in each dimension.</p> <p>Arguments:</p> <pre><code>z_map: Size of grid along LOS, in radians.\n\ndz: Grid resolution along LOS, in radians.\n\nx0: Map x center in radians. If None, grid center is used.\n\ny0: Map y center in radians. If None, grid center is used.\n</code></pre> <p>Returns:</p> <pre><code>x: Grid of x coordinates in radians.\n\ny: Grid of y coordinates in radians.\n\nz: Grid of z coordinates in radians.\n</code></pre> Source code in <code>witch/utils.py</code> <pre><code>def make_grid_from_skymap(skymap, z_map, dz, x0=None, y0=None):\n    \"\"\"\n    Make coordinate grids to build models in.\n    All grids are sparse and are int(2*r_map / dr) in each dimension.\n\n    Arguments:\n\n        z_map: Size of grid along LOS, in radians.\n\n        dz: Grid resolution along LOS, in radians.\n\n        x0: Map x center in radians. If None, grid center is used.\n\n        y0: Map y center in radians. If None, grid center is used.\n\n    Returns:\n\n        x: Grid of x coordinates in radians.\n\n        y: Grid of y coordinates in radians.\n\n        z: Grid of z coordinates in radians.\n    \"\"\"\n    # make grid\n    _x = jnp.arange(skymap.nx, dtype=float)\n    _y = jnp.arange(skymap.ny, dtype=float)\n    _z = jnp.linspace(-1 * z_map, z_map, 2 * int(z_map / dz), dtype=float)\n    x, y, z = jnp.meshgrid(_x, _y, _z, sparse=True, indexing=\"ij\")\n\n    # Pad so we don't need to broadcast\n    x_flat = x.ravel()\n    y_flat = y.ravel()\n    len_diff = len(x_flat) - len(y_flat)\n    if len_diff &gt; 0:\n        y_flat = jnp.pad(y_flat, (0, len_diff), \"edge\")\n    elif len_diff &lt; 0:\n        x_flat = jnp.pad(x_flat, (0, abs(len_diff)), \"edge\")\n\n    # Convert x and y to ra/dec\n    ra_dec = skymap.wcs.wcs_pix2world(\n        jnp.column_stack((x_flat, y_flat)), 0, ra_dec_order=True\n    )\n    ra_dec = np.deg2rad(ra_dec)\n    ra = ra_dec[:, 0]\n    dec = ra_dec[:, 1]\n\n    # Remove padding\n    if len_diff &gt; 0:\n        dec = dec[: (-1 * len_diff)]\n    elif len_diff &lt; 0:\n        ra = ra[:len_diff]\n\n    if not x0:\n        x0 = (skymap.lims[1] + skymap.lims[0]) / 2\n    if not y0:\n        y0 = (skymap.lims[3] + skymap.lims[2]) / 2\n\n    ra -= x0\n    dec -= y0\n\n    # Sparse indexing to save mem\n    x = x.at[:, 0, 0].set(ra)\n    y = y.at[0, :, 0].set(dec)\n\n    return x, y, z\n</code></pre>"},{"location":"reference/utils/#witch.utils.tod_hi_pass","title":"<code>tod_hi_pass(tod, N_filt)</code>","text":"<p>High pass a tod with a tophat</p> <p>Arguments:</p> <pre><code>tod: TOD to high pass\n\nN_filt: N_filt of tophat\n</code></pre> <p>Returns:</p> <pre><code>tod_filtered: Filtered TOD\n</code></pre> Source code in <code>witch/utils.py</code> <pre><code>@partial(jax.jit, static_argnums=(1,))\ndef tod_hi_pass(tod, N_filt):\n    \"\"\"\n    High pass a tod with a tophat\n\n    Arguments:\n\n        tod: TOD to high pass\n\n        N_filt: N_filt of tophat\n\n\n    Returns:\n\n        tod_filtered: Filtered TOD\n    \"\"\"\n    mask = jnp.ones(tod.shape)\n    mask = jax.ops.index_update(mask, jax.ops.index[..., :N_filt], 0.0)\n\n    ## apply the filter in fourier space\n    Ftod = jnp.fft.fft(tod)\n    Ftod_filtered = Ftod * mask\n    tod_filtered = jnp.fft.ifft(Ftod_filtered).real\n    return tod_filtered\n</code></pre>"},{"location":"reference/utils/#witch.utils.tod_to_index","title":"<code>tod_to_index(xi, yi, x0, y0, grid, conv_factor)</code>","text":"<p>Convert RA/Dec TODs to index space.</p> <p>Arguments:</p> <pre><code>xi: RA TOD\n\nyi: Dec TOD\n\nx0: RA at center of model. Nominally the cluster center.\n\ny0: Dec at center of model. Nominally the cluster center.\n\ngrid: The grid to index on.\n\nconv_factor: Conversion factor to put RA and Dec in same units as r_map.\n             Nominally (da * 180 * 3600) / pi\n</code></pre> <p>Returns:</p> <pre><code>idx: The RA TOD in index space\n\nidy: The Dec TOD in index space.\n</code></pre> Source code in <code>witch/utils.py</code> <pre><code>def tod_to_index(xi, yi, x0, y0, grid, conv_factor):\n    \"\"\"\n    Convert RA/Dec TODs to index space.\n\n    Arguments:\n\n        xi: RA TOD\n\n        yi: Dec TOD\n\n        x0: RA at center of model. Nominally the cluster center.\n\n        y0: Dec at center of model. Nominally the cluster center.\n\n        grid: The grid to index on.\n\n        conv_factor: Conversion factor to put RA and Dec in same units as r_map.\n                     Nominally (da * 180 * 3600) / pi\n\n    Returns:\n\n        idx: The RA TOD in index space\n\n        idy: The Dec TOD in index space.\n    \"\"\"\n    dx = (xi - x0) * jnp.cos(yi)\n    dy = yi - y0\n\n    dx *= conv_factor\n    dy *= conv_factor\n\n    # Assuming sparse indexing here\n    idx = np.digitize(dx, grid[0].ravel())\n    idy = np.digitize(dy, grid[1].ravel())\n\n    idx = np.rint(idx).astype(int)\n    idy = np.rint(idy).astype(int)\n\n    # Ensure out of bounds for stuff not in grid\n    idx = jnp.where((idx &lt; 0) + (idx &gt;= grid[0].shape[0]), 2 * grid[0].shape[0], idx)\n    idy = jnp.where((idy &lt; 0) + (idy &gt;= grid[1].shape[1]), 2 * grid[1].shape[1], idy)\n\n    return idx, idy\n</code></pre>"},{"location":"reference/utils/#witch.utils.transform_grid","title":"<code>transform_grid(dx, dy, dz, r_1, r_2, r_3, theta, xyz)</code>","text":"<p>Shift, rotate, and apply ellipticity to coordinate grid.</p> <p>Arguments:</p> <pre><code>dx: RA of cluster center relative to grid origin\n\ndy: Dec of cluster center relative to grid origin\n\ndz: Line of sight offset of cluster center relative to grid origin\n\nr_1: Amount to scale along x-axis\n\nr_2: Amount to scale along y-axis\n\nr_3: Amount to scale along z-axis\n\ntheta: Angle to rotate in xy-plane\n\nxyz: Coordinte grid to transform\n</code></pre> <p>Returns:</p> <pre><code>xyz: Transformed coordinate grid\n</code></pre> Source code in <code>witch/utils.py</code> <pre><code>@jax.jit\ndef transform_grid(dx, dy, dz, r_1, r_2, r_3, theta, xyz):\n    \"\"\"\n    Shift, rotate, and apply ellipticity to coordinate grid.\n\n    Arguments:\n\n        dx: RA of cluster center relative to grid origin\n\n        dy: Dec of cluster center relative to grid origin\n\n        dz: Line of sight offset of cluster center relative to grid origin\n\n        r_1: Amount to scale along x-axis\n\n        r_2: Amount to scale along y-axis\n\n        r_3: Amount to scale along z-axis\n\n        theta: Angle to rotate in xy-plane\n\n        xyz: Coordinte grid to transform\n\n    Returns:\n\n        xyz: Transformed coordinate grid\n    \"\"\"\n    # Get origin\n    x0, y0 = xyz[3], xyz[4]\n    # Shift origin\n    x = (xyz[0] - (x0 + dx / jnp.cos(y0 / rad_to_arcsec))) * jnp.cos(\n        (y0 + dy) / rad_to_arcsec\n    )\n    y = xyz[1] - (y0 + dy)\n    z = xyz[2] - dz\n\n    # Rotate\n    xx = x * jnp.cos(theta) + y * jnp.sin(theta)\n    yy = y * jnp.cos(theta) - x * jnp.sin(theta)\n\n    # Apply ellipticity\n    x = xx / r_1\n    y = yy / r_2\n    z = z / r_3\n\n    return x, y, z\n</code></pre>"},{"location":"reference/utils/#witch.utils.y2K_CMB","title":"<code>y2K_CMB(freq, Te)</code>","text":"<p>Convert from compton y to K_CMB.</p> <p>Arguments:</p> <pre><code>freq: The observing frequency in Hz.\n\nTe: Electron temperature\n</code></pre> <p>Returns:</p> <pre><code>y2K_CMB: Conversion factor from compton y to K_CMB.\n</code></pre> Source code in <code>witch/utils.py</code> <pre><code>@partial(jax.jit, static_argnums=(0, 1))\ndef y2K_CMB(freq, Te):\n    \"\"\"\n    Convert from compton y to K_CMB.\n\n    Arguments:\n\n        freq: The observing frequency in Hz.\n\n        Te: Electron temperature\n\n    Returns:\n\n        y2K_CMB: Conversion factor from compton y to K_CMB.\n    \"\"\"\n    x = freq * h / kb / Tcmb\n    xt = x / jnp.tanh(0.5 * x)\n    st = x / jnp.sinh(0.5 * x)\n    # fmt:off\n    Y0 = -4.0 + xt\n    Y1 = (-10.0\n        + ((47.0 / 2.0) + (-(42.0 / 5.0) + (7.0 / 10.0) * xt) * xt) * xt\n        + st * st * (-(21.0 / 5.0) + (7.0 / 5.0) * xt)\n    )\n    Y2 = ((-15.0 / 2.0)\n        + ((1023.0 / 8.0) + ((-868.0 / 5.0) + ((329.0 / 5.0) + ((-44.0 / 5.0) + (11.0 / 30.0) * xt) * xt) * xt) * xt) * xt\n        + ((-434.0 / 5.0) + ((658.0 / 5.0) + ((-242.0 / 5.0) + (143.0 / 30.0) * xt) * xt) * xt\n        + (-(44.0 / 5.0) + (187.0 / 60.0) * xt) * (st * st)) * st * st\n    )\n    Y3 = ((15.0 / 2.0)\n        + ((2505.0 / 8.0) + ((-7098.0 / 5.0) + ((14253.0 / 10.0) + ((-18594.0 / 35.0) \n         + ((12059.0 / 140.0) + ((-128.0 / 21.0) + (16.0 / 105.0) * xt) * xt) * xt) * xt) * xt) * xt) * xt\n        + (((-7098.0 / 10.0) + ((14253.0 / 5.0) + ((-102267.0 / 35.0) + ((156767.0 / 140.0)\n         + ((-1216.0 / 7.0) + (64.0 / 7.0) * xt) * xt) * xt) * xt) * xt)\n         + (((-18594.0 / 35.0) + ((205003.0 / 280.0) + ((-1920.0 / 7.0) + (1024.0 / 35.0) * xt) * xt) * xt)\n          + ((-544.0 / 21.0) + (992.0 / 105.0) * xt) * st * st) * st * st) * st * st\n    )\n    Y4 = ((-135.0 / 32.0)\n        + ((30375.0 / 128.0) + ((-62391.0 / 10.0) + ((614727.0 / 40.0) + ((-124389.0 / 10.0) + ((355703.0 / 80.0) + ((-16568.0 / 21.0)\n         + ((7516.0 / 105.0) + ((-22.0 / 7.0) + (11.0 / 210.0) * xt) * xt) * xt) * xt) * xt) * xt) * xt) * xt) * xt\n        + ((-62391.0 / 20.0) + ((614727.0 / 20.0) + ((-1368279.0 / 20.0) + ((4624139.0 / 80.0) + ((-157396.0 / 7.0) + ((30064.0 / 7.0)\n         + ((-2717.0 / 7.0) + (2761.0 / 210.0) * xt) * xt) * xt) * xt) * xt) * xt) * xt\n         + ((-124389.0 / 10.0)\n          + ((6046951.0 / 160.0) + ((-248520.0 / 7.0) + ((481024.0 / 35.0) + ((-15972.0 / 7.0) + (18689.0 / 140.0) * xt) * xt) * xt) * xt) * xt\n          + ((-70414.0 / 21.0) + ((465992.0 / 105.0) + ((-11792.0 / 7.0) + (19778.0 / 105.0) * xt) * xt) * xt\n           + ((-682.0 / 7.0) + (7601.0 / 210.0) * xt) * st * st) * st * st) * st * st) * st * st\n    )\n    # fmt:on\n    factor = Y0 + (Te / me) * (\n        Y1 + (Te / me) * (Y2 + (Te / me) * (Y3 + (Te / me) * Y4))\n    )\n    return factor * Tcmb\n</code></pre>"},{"location":"reference/utils/#witch.utils.y2K_RJ","title":"<code>y2K_RJ(freq, Te)</code>","text":"<p>Convert from compton y to K_RJ.</p> <p>Arguments:</p> <pre><code>freq: The observing frequency in Hz.\n\nTe: Electron temperature\n</code></pre> <p>Returns:</p> <pre><code>y2K_RJ: Conversion factor from compton y to K_RJ.\n</code></pre> Source code in <code>witch/utils.py</code> <pre><code>@partial(jax.jit, static_argnums=(0, 1))\ndef y2K_RJ(freq, Te):\n    \"\"\"\n    Convert from compton y to K_RJ.\n\n    Arguments:\n\n        freq: The observing frequency in Hz.\n\n        Te: Electron temperature\n\n    Returns:\n\n        y2K_RJ: Conversion factor from compton y to K_RJ.\n    \"\"\"\n    factor = y2K_CMB(freq, Te)\n    return factor * K_CMB2K_RJ(freq)\n</code></pre>"}]}